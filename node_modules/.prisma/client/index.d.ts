
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model tb_mhs
 * 
 */
export type tb_mhs = $Result.DefaultSelection<Prisma.$tb_mhsPayload>
/**
 * Model tb_dosen
 * 
 */
export type tb_dosen = $Result.DefaultSelection<Prisma.$tb_dosenPayload>
/**
 * Model tb_irs
 * 
 */
export type tb_irs = $Result.DefaultSelection<Prisma.$tb_irsPayload>
/**
 * Model tb_khs
 * 
 */
export type tb_khs = $Result.DefaultSelection<Prisma.$tb_khsPayload>
/**
 * Model tb_pkl
 * 
 */
export type tb_pkl = $Result.DefaultSelection<Prisma.$tb_pklPayload>
/**
 * Model tb_skripsi
 * 
 */
export type tb_skripsi = $Result.DefaultSelection<Prisma.$tb_skripsiPayload>
/**
 * Model tb_provinsi
 * 
 */
export type tb_provinsi = $Result.DefaultSelection<Prisma.$tb_provinsiPayload>
/**
 * Model tb_kabupaten
 * 
 */
export type tb_kabupaten = $Result.DefaultSelection<Prisma.$tb_kabupatenPayload>
/**
 * Model tb_akun_mhs
 * 
 */
export type tb_akun_mhs = $Result.DefaultSelection<Prisma.$tb_akun_mhsPayload>
/**
 * Model tb_akun_dosen
 * 
 */
export type tb_akun_dosen = $Result.DefaultSelection<Prisma.$tb_akun_dosenPayload>
/**
 * Model tb_role_akun_dosen
 * 
 */
export type tb_role_akun_dosen = $Result.DefaultSelection<Prisma.$tb_role_akun_dosenPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const StatusMhs: {
  Aktif: 'Aktif',
  Cuti: 'Cuti',
  Lulus: 'Lulus',
  Mangkir: 'Mangkir',
  DO: 'DO',
  UndurDiri: 'UndurDiri',
  MeninggalDunia: 'MeninggalDunia'
};

export type StatusMhs = (typeof StatusMhs)[keyof typeof StatusMhs]


export const JalurMasuk: {
  SBMPTN: 'SBMPTN',
  SNMPTN: 'SNMPTN',
  Mandiri: 'Mandiri',
  Lainnya: 'Lainnya'
};

export type JalurMasuk = (typeof JalurMasuk)[keyof typeof JalurMasuk]


export const StatusAktif: {
  Aktif: 'Aktif',
  Cuti: 'Cuti'
};

export type StatusAktif = (typeof StatusAktif)[keyof typeof StatusAktif]


export const StatusAkun: {
  Aktif: 'Aktif',
  NonAktif: 'NonAktif'
};

export type StatusAkun = (typeof StatusAkun)[keyof typeof StatusAkun]


export const Role: {
  Operator: 'Operator',
  Departemen: 'Departemen',
  Dosen: 'Dosen'
};

export type Role = (typeof Role)[keyof typeof Role]

}

export type StatusMhs = $Enums.StatusMhs

export const StatusMhs: typeof $Enums.StatusMhs

export type JalurMasuk = $Enums.JalurMasuk

export const JalurMasuk: typeof $Enums.JalurMasuk

export type StatusAktif = $Enums.StatusAktif

export const StatusAktif: typeof $Enums.StatusAktif

export type StatusAkun = $Enums.StatusAkun

export const StatusAkun: typeof $Enums.StatusAkun

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tb_mhs
 * const tb_mhs = await prisma.tb_mhs.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tb_mhs
   * const tb_mhs = await prisma.tb_mhs.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.tb_mhs`: Exposes CRUD operations for the **tb_mhs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_mhs
    * const tb_mhs = await prisma.tb_mhs.findMany()
    * ```
    */
  get tb_mhs(): Prisma.tb_mhsDelegate<ExtArgs>;

  /**
   * `prisma.tb_dosen`: Exposes CRUD operations for the **tb_dosen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_dosens
    * const tb_dosens = await prisma.tb_dosen.findMany()
    * ```
    */
  get tb_dosen(): Prisma.tb_dosenDelegate<ExtArgs>;

  /**
   * `prisma.tb_irs`: Exposes CRUD operations for the **tb_irs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_irs
    * const tb_irs = await prisma.tb_irs.findMany()
    * ```
    */
  get tb_irs(): Prisma.tb_irsDelegate<ExtArgs>;

  /**
   * `prisma.tb_khs`: Exposes CRUD operations for the **tb_khs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_khs
    * const tb_khs = await prisma.tb_khs.findMany()
    * ```
    */
  get tb_khs(): Prisma.tb_khsDelegate<ExtArgs>;

  /**
   * `prisma.tb_pkl`: Exposes CRUD operations for the **tb_pkl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_pkls
    * const tb_pkls = await prisma.tb_pkl.findMany()
    * ```
    */
  get tb_pkl(): Prisma.tb_pklDelegate<ExtArgs>;

  /**
   * `prisma.tb_skripsi`: Exposes CRUD operations for the **tb_skripsi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_skripsis
    * const tb_skripsis = await prisma.tb_skripsi.findMany()
    * ```
    */
  get tb_skripsi(): Prisma.tb_skripsiDelegate<ExtArgs>;

  /**
   * `prisma.tb_provinsi`: Exposes CRUD operations for the **tb_provinsi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_provinsis
    * const tb_provinsis = await prisma.tb_provinsi.findMany()
    * ```
    */
  get tb_provinsi(): Prisma.tb_provinsiDelegate<ExtArgs>;

  /**
   * `prisma.tb_kabupaten`: Exposes CRUD operations for the **tb_kabupaten** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_kabupatens
    * const tb_kabupatens = await prisma.tb_kabupaten.findMany()
    * ```
    */
  get tb_kabupaten(): Prisma.tb_kabupatenDelegate<ExtArgs>;

  /**
   * `prisma.tb_akun_mhs`: Exposes CRUD operations for the **tb_akun_mhs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_akun_mhs
    * const tb_akun_mhs = await prisma.tb_akun_mhs.findMany()
    * ```
    */
  get tb_akun_mhs(): Prisma.tb_akun_mhsDelegate<ExtArgs>;

  /**
   * `prisma.tb_akun_dosen`: Exposes CRUD operations for the **tb_akun_dosen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_akun_dosens
    * const tb_akun_dosens = await prisma.tb_akun_dosen.findMany()
    * ```
    */
  get tb_akun_dosen(): Prisma.tb_akun_dosenDelegate<ExtArgs>;

  /**
   * `prisma.tb_role_akun_dosen`: Exposes CRUD operations for the **tb_role_akun_dosen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_role_akun_dosens
    * const tb_role_akun_dosens = await prisma.tb_role_akun_dosen.findMany()
    * ```
    */
  get tb_role_akun_dosen(): Prisma.tb_role_akun_dosenDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.5.2
   * Query Engine version: aebc046ce8b88ebbcb45efe31cbe7d06fd6abc0a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    tb_mhs: 'tb_mhs',
    tb_dosen: 'tb_dosen',
    tb_irs: 'tb_irs',
    tb_khs: 'tb_khs',
    tb_pkl: 'tb_pkl',
    tb_skripsi: 'tb_skripsi',
    tb_provinsi: 'tb_provinsi',
    tb_kabupaten: 'tb_kabupaten',
    tb_akun_mhs: 'tb_akun_mhs',
    tb_akun_dosen: 'tb_akun_dosen',
    tb_role_akun_dosen: 'tb_role_akun_dosen'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'tb_mhs' | 'tb_dosen' | 'tb_irs' | 'tb_khs' | 'tb_pkl' | 'tb_skripsi' | 'tb_provinsi' | 'tb_kabupaten' | 'tb_akun_mhs' | 'tb_akun_dosen' | 'tb_role_akun_dosen'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      tb_mhs: {
        payload: Prisma.$tb_mhsPayload<ExtArgs>
        fields: Prisma.tb_mhsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_mhsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_mhsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_mhsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_mhsPayload>
          }
          findFirst: {
            args: Prisma.tb_mhsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_mhsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_mhsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_mhsPayload>
          }
          findMany: {
            args: Prisma.tb_mhsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_mhsPayload>[]
          }
          create: {
            args: Prisma.tb_mhsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_mhsPayload>
          }
          createMany: {
            args: Prisma.tb_mhsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tb_mhsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_mhsPayload>
          }
          update: {
            args: Prisma.tb_mhsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_mhsPayload>
          }
          deleteMany: {
            args: Prisma.tb_mhsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tb_mhsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tb_mhsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_mhsPayload>
          }
          aggregate: {
            args: Prisma.Tb_mhsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTb_mhs>
          }
          groupBy: {
            args: Prisma.tb_mhsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tb_mhsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_mhsCountArgs<ExtArgs>,
            result: $Utils.Optional<Tb_mhsCountAggregateOutputType> | number
          }
        }
      }
      tb_dosen: {
        payload: Prisma.$tb_dosenPayload<ExtArgs>
        fields: Prisma.tb_dosenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_dosenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_dosenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_dosenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_dosenPayload>
          }
          findFirst: {
            args: Prisma.tb_dosenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_dosenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_dosenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_dosenPayload>
          }
          findMany: {
            args: Prisma.tb_dosenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_dosenPayload>[]
          }
          create: {
            args: Prisma.tb_dosenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_dosenPayload>
          }
          createMany: {
            args: Prisma.tb_dosenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tb_dosenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_dosenPayload>
          }
          update: {
            args: Prisma.tb_dosenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_dosenPayload>
          }
          deleteMany: {
            args: Prisma.tb_dosenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tb_dosenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tb_dosenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_dosenPayload>
          }
          aggregate: {
            args: Prisma.Tb_dosenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTb_dosen>
          }
          groupBy: {
            args: Prisma.tb_dosenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tb_dosenGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_dosenCountArgs<ExtArgs>,
            result: $Utils.Optional<Tb_dosenCountAggregateOutputType> | number
          }
        }
      }
      tb_irs: {
        payload: Prisma.$tb_irsPayload<ExtArgs>
        fields: Prisma.tb_irsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_irsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_irsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_irsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_irsPayload>
          }
          findFirst: {
            args: Prisma.tb_irsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_irsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_irsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_irsPayload>
          }
          findMany: {
            args: Prisma.tb_irsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_irsPayload>[]
          }
          create: {
            args: Prisma.tb_irsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_irsPayload>
          }
          createMany: {
            args: Prisma.tb_irsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tb_irsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_irsPayload>
          }
          update: {
            args: Prisma.tb_irsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_irsPayload>
          }
          deleteMany: {
            args: Prisma.tb_irsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tb_irsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tb_irsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_irsPayload>
          }
          aggregate: {
            args: Prisma.Tb_irsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTb_irs>
          }
          groupBy: {
            args: Prisma.tb_irsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tb_irsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_irsCountArgs<ExtArgs>,
            result: $Utils.Optional<Tb_irsCountAggregateOutputType> | number
          }
        }
      }
      tb_khs: {
        payload: Prisma.$tb_khsPayload<ExtArgs>
        fields: Prisma.tb_khsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_khsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_khsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_khsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_khsPayload>
          }
          findFirst: {
            args: Prisma.tb_khsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_khsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_khsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_khsPayload>
          }
          findMany: {
            args: Prisma.tb_khsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_khsPayload>[]
          }
          create: {
            args: Prisma.tb_khsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_khsPayload>
          }
          createMany: {
            args: Prisma.tb_khsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tb_khsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_khsPayload>
          }
          update: {
            args: Prisma.tb_khsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_khsPayload>
          }
          deleteMany: {
            args: Prisma.tb_khsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tb_khsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tb_khsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_khsPayload>
          }
          aggregate: {
            args: Prisma.Tb_khsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTb_khs>
          }
          groupBy: {
            args: Prisma.tb_khsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tb_khsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_khsCountArgs<ExtArgs>,
            result: $Utils.Optional<Tb_khsCountAggregateOutputType> | number
          }
        }
      }
      tb_pkl: {
        payload: Prisma.$tb_pklPayload<ExtArgs>
        fields: Prisma.tb_pklFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_pklFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_pklPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_pklFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_pklPayload>
          }
          findFirst: {
            args: Prisma.tb_pklFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_pklPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_pklFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_pklPayload>
          }
          findMany: {
            args: Prisma.tb_pklFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_pklPayload>[]
          }
          create: {
            args: Prisma.tb_pklCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_pklPayload>
          }
          createMany: {
            args: Prisma.tb_pklCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tb_pklDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_pklPayload>
          }
          update: {
            args: Prisma.tb_pklUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_pklPayload>
          }
          deleteMany: {
            args: Prisma.tb_pklDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tb_pklUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tb_pklUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_pklPayload>
          }
          aggregate: {
            args: Prisma.Tb_pklAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTb_pkl>
          }
          groupBy: {
            args: Prisma.tb_pklGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tb_pklGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_pklCountArgs<ExtArgs>,
            result: $Utils.Optional<Tb_pklCountAggregateOutputType> | number
          }
        }
      }
      tb_skripsi: {
        payload: Prisma.$tb_skripsiPayload<ExtArgs>
        fields: Prisma.tb_skripsiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_skripsiFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_skripsiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_skripsiFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_skripsiPayload>
          }
          findFirst: {
            args: Prisma.tb_skripsiFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_skripsiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_skripsiFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_skripsiPayload>
          }
          findMany: {
            args: Prisma.tb_skripsiFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_skripsiPayload>[]
          }
          create: {
            args: Prisma.tb_skripsiCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_skripsiPayload>
          }
          createMany: {
            args: Prisma.tb_skripsiCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tb_skripsiDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_skripsiPayload>
          }
          update: {
            args: Prisma.tb_skripsiUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_skripsiPayload>
          }
          deleteMany: {
            args: Prisma.tb_skripsiDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tb_skripsiUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tb_skripsiUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_skripsiPayload>
          }
          aggregate: {
            args: Prisma.Tb_skripsiAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTb_skripsi>
          }
          groupBy: {
            args: Prisma.tb_skripsiGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tb_skripsiGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_skripsiCountArgs<ExtArgs>,
            result: $Utils.Optional<Tb_skripsiCountAggregateOutputType> | number
          }
        }
      }
      tb_provinsi: {
        payload: Prisma.$tb_provinsiPayload<ExtArgs>
        fields: Prisma.tb_provinsiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_provinsiFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_provinsiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_provinsiFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_provinsiPayload>
          }
          findFirst: {
            args: Prisma.tb_provinsiFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_provinsiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_provinsiFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_provinsiPayload>
          }
          findMany: {
            args: Prisma.tb_provinsiFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_provinsiPayload>[]
          }
          create: {
            args: Prisma.tb_provinsiCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_provinsiPayload>
          }
          createMany: {
            args: Prisma.tb_provinsiCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tb_provinsiDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_provinsiPayload>
          }
          update: {
            args: Prisma.tb_provinsiUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_provinsiPayload>
          }
          deleteMany: {
            args: Prisma.tb_provinsiDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tb_provinsiUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tb_provinsiUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_provinsiPayload>
          }
          aggregate: {
            args: Prisma.Tb_provinsiAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTb_provinsi>
          }
          groupBy: {
            args: Prisma.tb_provinsiGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tb_provinsiGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_provinsiCountArgs<ExtArgs>,
            result: $Utils.Optional<Tb_provinsiCountAggregateOutputType> | number
          }
        }
      }
      tb_kabupaten: {
        payload: Prisma.$tb_kabupatenPayload<ExtArgs>
        fields: Prisma.tb_kabupatenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_kabupatenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_kabupatenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_kabupatenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_kabupatenPayload>
          }
          findFirst: {
            args: Prisma.tb_kabupatenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_kabupatenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_kabupatenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_kabupatenPayload>
          }
          findMany: {
            args: Prisma.tb_kabupatenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_kabupatenPayload>[]
          }
          create: {
            args: Prisma.tb_kabupatenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_kabupatenPayload>
          }
          createMany: {
            args: Prisma.tb_kabupatenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tb_kabupatenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_kabupatenPayload>
          }
          update: {
            args: Prisma.tb_kabupatenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_kabupatenPayload>
          }
          deleteMany: {
            args: Prisma.tb_kabupatenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tb_kabupatenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tb_kabupatenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_kabupatenPayload>
          }
          aggregate: {
            args: Prisma.Tb_kabupatenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTb_kabupaten>
          }
          groupBy: {
            args: Prisma.tb_kabupatenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tb_kabupatenGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_kabupatenCountArgs<ExtArgs>,
            result: $Utils.Optional<Tb_kabupatenCountAggregateOutputType> | number
          }
        }
      }
      tb_akun_mhs: {
        payload: Prisma.$tb_akun_mhsPayload<ExtArgs>
        fields: Prisma.tb_akun_mhsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_akun_mhsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_akun_mhsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_akun_mhsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_akun_mhsPayload>
          }
          findFirst: {
            args: Prisma.tb_akun_mhsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_akun_mhsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_akun_mhsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_akun_mhsPayload>
          }
          findMany: {
            args: Prisma.tb_akun_mhsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_akun_mhsPayload>[]
          }
          create: {
            args: Prisma.tb_akun_mhsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_akun_mhsPayload>
          }
          createMany: {
            args: Prisma.tb_akun_mhsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tb_akun_mhsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_akun_mhsPayload>
          }
          update: {
            args: Prisma.tb_akun_mhsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_akun_mhsPayload>
          }
          deleteMany: {
            args: Prisma.tb_akun_mhsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tb_akun_mhsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tb_akun_mhsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_akun_mhsPayload>
          }
          aggregate: {
            args: Prisma.Tb_akun_mhsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTb_akun_mhs>
          }
          groupBy: {
            args: Prisma.tb_akun_mhsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tb_akun_mhsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_akun_mhsCountArgs<ExtArgs>,
            result: $Utils.Optional<Tb_akun_mhsCountAggregateOutputType> | number
          }
        }
      }
      tb_akun_dosen: {
        payload: Prisma.$tb_akun_dosenPayload<ExtArgs>
        fields: Prisma.tb_akun_dosenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_akun_dosenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_akun_dosenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_akun_dosenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_akun_dosenPayload>
          }
          findFirst: {
            args: Prisma.tb_akun_dosenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_akun_dosenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_akun_dosenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_akun_dosenPayload>
          }
          findMany: {
            args: Prisma.tb_akun_dosenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_akun_dosenPayload>[]
          }
          create: {
            args: Prisma.tb_akun_dosenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_akun_dosenPayload>
          }
          createMany: {
            args: Prisma.tb_akun_dosenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tb_akun_dosenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_akun_dosenPayload>
          }
          update: {
            args: Prisma.tb_akun_dosenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_akun_dosenPayload>
          }
          deleteMany: {
            args: Prisma.tb_akun_dosenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tb_akun_dosenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tb_akun_dosenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_akun_dosenPayload>
          }
          aggregate: {
            args: Prisma.Tb_akun_dosenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTb_akun_dosen>
          }
          groupBy: {
            args: Prisma.tb_akun_dosenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tb_akun_dosenGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_akun_dosenCountArgs<ExtArgs>,
            result: $Utils.Optional<Tb_akun_dosenCountAggregateOutputType> | number
          }
        }
      }
      tb_role_akun_dosen: {
        payload: Prisma.$tb_role_akun_dosenPayload<ExtArgs>
        fields: Prisma.tb_role_akun_dosenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_role_akun_dosenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_role_akun_dosenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_role_akun_dosenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_role_akun_dosenPayload>
          }
          findFirst: {
            args: Prisma.tb_role_akun_dosenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_role_akun_dosenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_role_akun_dosenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_role_akun_dosenPayload>
          }
          findMany: {
            args: Prisma.tb_role_akun_dosenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_role_akun_dosenPayload>[]
          }
          create: {
            args: Prisma.tb_role_akun_dosenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_role_akun_dosenPayload>
          }
          createMany: {
            args: Prisma.tb_role_akun_dosenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tb_role_akun_dosenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_role_akun_dosenPayload>
          }
          update: {
            args: Prisma.tb_role_akun_dosenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_role_akun_dosenPayload>
          }
          deleteMany: {
            args: Prisma.tb_role_akun_dosenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tb_role_akun_dosenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tb_role_akun_dosenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tb_role_akun_dosenPayload>
          }
          aggregate: {
            args: Prisma.Tb_role_akun_dosenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTb_role_akun_dosen>
          }
          groupBy: {
            args: Prisma.tb_role_akun_dosenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tb_role_akun_dosenGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_role_akun_dosenCountArgs<ExtArgs>,
            result: $Utils.Optional<Tb_role_akun_dosenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Tb_mhsCountOutputType
   */

  export type Tb_mhsCountOutputType = {
    fk_nim_irs: number
    fk_nim_khs: number
    fk_nim_pkl: number
    fk_nim_skripsi: number
  }

  export type Tb_mhsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fk_nim_irs?: boolean | Tb_mhsCountOutputTypeCountFk_nim_irsArgs
    fk_nim_khs?: boolean | Tb_mhsCountOutputTypeCountFk_nim_khsArgs
    fk_nim_pkl?: boolean | Tb_mhsCountOutputTypeCountFk_nim_pklArgs
    fk_nim_skripsi?: boolean | Tb_mhsCountOutputTypeCountFk_nim_skripsiArgs
  }

  // Custom InputTypes

  /**
   * Tb_mhsCountOutputType without action
   */
  export type Tb_mhsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_mhsCountOutputType
     */
    select?: Tb_mhsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Tb_mhsCountOutputType without action
   */
  export type Tb_mhsCountOutputTypeCountFk_nim_irsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_irsWhereInput
  }


  /**
   * Tb_mhsCountOutputType without action
   */
  export type Tb_mhsCountOutputTypeCountFk_nim_khsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_khsWhereInput
  }


  /**
   * Tb_mhsCountOutputType without action
   */
  export type Tb_mhsCountOutputTypeCountFk_nim_pklArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_pklWhereInput
  }


  /**
   * Tb_mhsCountOutputType without action
   */
  export type Tb_mhsCountOutputTypeCountFk_nim_skripsiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_skripsiWhereInput
  }



  /**
   * Count Type Tb_dosenCountOutputType
   */

  export type Tb_dosenCountOutputType = {
    fk_kodeWali_mhs: number
  }

  export type Tb_dosenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fk_kodeWali_mhs?: boolean | Tb_dosenCountOutputTypeCountFk_kodeWali_mhsArgs
  }

  // Custom InputTypes

  /**
   * Tb_dosenCountOutputType without action
   */
  export type Tb_dosenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_dosenCountOutputType
     */
    select?: Tb_dosenCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Tb_dosenCountOutputType without action
   */
  export type Tb_dosenCountOutputTypeCountFk_kodeWali_mhsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_mhsWhereInput
  }



  /**
   * Count Type Tb_provinsiCountOutputType
   */

  export type Tb_provinsiCountOutputType = {
    fk_kodeProv_mhs: number
    fk_kodeProv_dosen: number
    fk_kodeProv_kabupaten: number
  }

  export type Tb_provinsiCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fk_kodeProv_mhs?: boolean | Tb_provinsiCountOutputTypeCountFk_kodeProv_mhsArgs
    fk_kodeProv_dosen?: boolean | Tb_provinsiCountOutputTypeCountFk_kodeProv_dosenArgs
    fk_kodeProv_kabupaten?: boolean | Tb_provinsiCountOutputTypeCountFk_kodeProv_kabupatenArgs
  }

  // Custom InputTypes

  /**
   * Tb_provinsiCountOutputType without action
   */
  export type Tb_provinsiCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_provinsiCountOutputType
     */
    select?: Tb_provinsiCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Tb_provinsiCountOutputType without action
   */
  export type Tb_provinsiCountOutputTypeCountFk_kodeProv_mhsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_mhsWhereInput
  }


  /**
   * Tb_provinsiCountOutputType without action
   */
  export type Tb_provinsiCountOutputTypeCountFk_kodeProv_dosenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_dosenWhereInput
  }


  /**
   * Tb_provinsiCountOutputType without action
   */
  export type Tb_provinsiCountOutputTypeCountFk_kodeProv_kabupatenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_kabupatenWhereInput
  }



  /**
   * Count Type Tb_kabupatenCountOutputType
   */

  export type Tb_kabupatenCountOutputType = {
    fk_kodeKab_mhs: number
    fk_kodeKab_dosen: number
  }

  export type Tb_kabupatenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fk_kodeKab_mhs?: boolean | Tb_kabupatenCountOutputTypeCountFk_kodeKab_mhsArgs
    fk_kodeKab_dosen?: boolean | Tb_kabupatenCountOutputTypeCountFk_kodeKab_dosenArgs
  }

  // Custom InputTypes

  /**
   * Tb_kabupatenCountOutputType without action
   */
  export type Tb_kabupatenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_kabupatenCountOutputType
     */
    select?: Tb_kabupatenCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Tb_kabupatenCountOutputType without action
   */
  export type Tb_kabupatenCountOutputTypeCountFk_kodeKab_mhsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_mhsWhereInput
  }


  /**
   * Tb_kabupatenCountOutputType without action
   */
  export type Tb_kabupatenCountOutputTypeCountFk_kodeKab_dosenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_dosenWhereInput
  }



  /**
   * Count Type Tb_akun_dosenCountOutputType
   */

  export type Tb_akun_dosenCountOutputType = {
    fk_username_role: number
  }

  export type Tb_akun_dosenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fk_username_role?: boolean | Tb_akun_dosenCountOutputTypeCountFk_username_roleArgs
  }

  // Custom InputTypes

  /**
   * Tb_akun_dosenCountOutputType without action
   */
  export type Tb_akun_dosenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_akun_dosenCountOutputType
     */
    select?: Tb_akun_dosenCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Tb_akun_dosenCountOutputType without action
   */
  export type Tb_akun_dosenCountOutputTypeCountFk_username_roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_role_akun_dosenWhereInput
  }



  /**
   * Models
   */

  /**
   * Model tb_mhs
   */

  export type AggregateTb_mhs = {
    _count: Tb_mhsCountAggregateOutputType | null
    _avg: Tb_mhsAvgAggregateOutputType | null
    _sum: Tb_mhsSumAggregateOutputType | null
    _min: Tb_mhsMinAggregateOutputType | null
    _max: Tb_mhsMaxAggregateOutputType | null
  }

  export type Tb_mhsAvgAggregateOutputType = {
    angkatan: number | null
  }

  export type Tb_mhsSumAggregateOutputType = {
    angkatan: number | null
  }

  export type Tb_mhsMinAggregateOutputType = {
    nim: string | null
    nama: string | null
    statusAktif: $Enums.StatusMhs | null
    alamat: string | null
    email: string | null
    kodeKab: string | null
    kodeProv: string | null
    jalurMasuk: $Enums.JalurMasuk | null
    angkatan: number | null
    noHP: string | null
    kodeWali: string | null
    foto: string | null
  }

  export type Tb_mhsMaxAggregateOutputType = {
    nim: string | null
    nama: string | null
    statusAktif: $Enums.StatusMhs | null
    alamat: string | null
    email: string | null
    kodeKab: string | null
    kodeProv: string | null
    jalurMasuk: $Enums.JalurMasuk | null
    angkatan: number | null
    noHP: string | null
    kodeWali: string | null
    foto: string | null
  }

  export type Tb_mhsCountAggregateOutputType = {
    nim: number
    nama: number
    statusAktif: number
    alamat: number
    email: number
    kodeKab: number
    kodeProv: number
    jalurMasuk: number
    angkatan: number
    noHP: number
    kodeWali: number
    foto: number
    _all: number
  }


  export type Tb_mhsAvgAggregateInputType = {
    angkatan?: true
  }

  export type Tb_mhsSumAggregateInputType = {
    angkatan?: true
  }

  export type Tb_mhsMinAggregateInputType = {
    nim?: true
    nama?: true
    statusAktif?: true
    alamat?: true
    email?: true
    kodeKab?: true
    kodeProv?: true
    jalurMasuk?: true
    angkatan?: true
    noHP?: true
    kodeWali?: true
    foto?: true
  }

  export type Tb_mhsMaxAggregateInputType = {
    nim?: true
    nama?: true
    statusAktif?: true
    alamat?: true
    email?: true
    kodeKab?: true
    kodeProv?: true
    jalurMasuk?: true
    angkatan?: true
    noHP?: true
    kodeWali?: true
    foto?: true
  }

  export type Tb_mhsCountAggregateInputType = {
    nim?: true
    nama?: true
    statusAktif?: true
    alamat?: true
    email?: true
    kodeKab?: true
    kodeProv?: true
    jalurMasuk?: true
    angkatan?: true
    noHP?: true
    kodeWali?: true
    foto?: true
    _all?: true
  }

  export type Tb_mhsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_mhs to aggregate.
     */
    where?: tb_mhsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_mhs to fetch.
     */
    orderBy?: tb_mhsOrderByWithRelationInput | tb_mhsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_mhsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_mhs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_mhs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_mhs
    **/
    _count?: true | Tb_mhsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_mhsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_mhsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_mhsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_mhsMaxAggregateInputType
  }

  export type GetTb_mhsAggregateType<T extends Tb_mhsAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_mhs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_mhs[P]>
      : GetScalarType<T[P], AggregateTb_mhs[P]>
  }




  export type tb_mhsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_mhsWhereInput
    orderBy?: tb_mhsOrderByWithAggregationInput | tb_mhsOrderByWithAggregationInput[]
    by: Tb_mhsScalarFieldEnum[] | Tb_mhsScalarFieldEnum
    having?: tb_mhsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_mhsCountAggregateInputType | true
    _avg?: Tb_mhsAvgAggregateInputType
    _sum?: Tb_mhsSumAggregateInputType
    _min?: Tb_mhsMinAggregateInputType
    _max?: Tb_mhsMaxAggregateInputType
  }

  export type Tb_mhsGroupByOutputType = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat: string | null
    email: string | null
    kodeKab: string | null
    kodeProv: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP: string | null
    kodeWali: string
    foto: string | null
    _count: Tb_mhsCountAggregateOutputType | null
    _avg: Tb_mhsAvgAggregateOutputType | null
    _sum: Tb_mhsSumAggregateOutputType | null
    _min: Tb_mhsMinAggregateOutputType | null
    _max: Tb_mhsMaxAggregateOutputType | null
  }

  type GetTb_mhsGroupByPayload<T extends tb_mhsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_mhsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_mhsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_mhsGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_mhsGroupByOutputType[P]>
        }
      >
    >


  export type tb_mhsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nim?: boolean
    nama?: boolean
    statusAktif?: boolean
    alamat?: boolean
    email?: boolean
    kodeKab?: boolean
    kodeProv?: boolean
    jalurMasuk?: boolean
    angkatan?: boolean
    noHP?: boolean
    kodeWali?: boolean
    foto?: boolean
    fk_kodeKab?: boolean | tb_mhs$fk_kodeKabArgs<ExtArgs>
    fk_kodeProv?: boolean | tb_mhs$fk_kodeProvArgs<ExtArgs>
    fk_kodeWali?: boolean | tb_dosenDefaultArgs<ExtArgs>
    fk_nim_irs?: boolean | tb_mhs$fk_nim_irsArgs<ExtArgs>
    fk_nim_khs?: boolean | tb_mhs$fk_nim_khsArgs<ExtArgs>
    fk_nim_pkl?: boolean | tb_mhs$fk_nim_pklArgs<ExtArgs>
    fk_nim_skripsi?: boolean | tb_mhs$fk_nim_skripsiArgs<ExtArgs>
    fk_pemilik_akun_mhs?: boolean | tb_mhs$fk_pemilik_akun_mhsArgs<ExtArgs>
    _count?: boolean | Tb_mhsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tb_mhs"]>

  export type tb_mhsSelectScalar = {
    nim?: boolean
    nama?: boolean
    statusAktif?: boolean
    alamat?: boolean
    email?: boolean
    kodeKab?: boolean
    kodeProv?: boolean
    jalurMasuk?: boolean
    angkatan?: boolean
    noHP?: boolean
    kodeWali?: boolean
    foto?: boolean
  }

  export type tb_mhsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fk_kodeKab?: boolean | tb_mhs$fk_kodeKabArgs<ExtArgs>
    fk_kodeProv?: boolean | tb_mhs$fk_kodeProvArgs<ExtArgs>
    fk_kodeWali?: boolean | tb_dosenDefaultArgs<ExtArgs>
    fk_nim_irs?: boolean | tb_mhs$fk_nim_irsArgs<ExtArgs>
    fk_nim_khs?: boolean | tb_mhs$fk_nim_khsArgs<ExtArgs>
    fk_nim_pkl?: boolean | tb_mhs$fk_nim_pklArgs<ExtArgs>
    fk_nim_skripsi?: boolean | tb_mhs$fk_nim_skripsiArgs<ExtArgs>
    fk_pemilik_akun_mhs?: boolean | tb_mhs$fk_pemilik_akun_mhsArgs<ExtArgs>
    _count?: boolean | Tb_mhsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $tb_mhsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_mhs"
    objects: {
      fk_kodeKab: Prisma.$tb_kabupatenPayload<ExtArgs> | null
      fk_kodeProv: Prisma.$tb_provinsiPayload<ExtArgs> | null
      fk_kodeWali: Prisma.$tb_dosenPayload<ExtArgs>
      fk_nim_irs: Prisma.$tb_irsPayload<ExtArgs>[]
      fk_nim_khs: Prisma.$tb_khsPayload<ExtArgs>[]
      fk_nim_pkl: Prisma.$tb_pklPayload<ExtArgs>[]
      fk_nim_skripsi: Prisma.$tb_skripsiPayload<ExtArgs>[]
      fk_pemilik_akun_mhs: Prisma.$tb_akun_mhsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      nim: string
      nama: string
      statusAktif: $Enums.StatusMhs
      alamat: string | null
      email: string | null
      kodeKab: string | null
      kodeProv: string | null
      jalurMasuk: $Enums.JalurMasuk
      angkatan: number
      noHP: string | null
      kodeWali: string
      foto: string | null
    }, ExtArgs["result"]["tb_mhs"]>
    composites: {}
  }


  type tb_mhsGetPayload<S extends boolean | null | undefined | tb_mhsDefaultArgs> = $Result.GetResult<Prisma.$tb_mhsPayload, S>

  type tb_mhsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tb_mhsFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Tb_mhsCountAggregateInputType | true
    }

  export interface tb_mhsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_mhs'], meta: { name: 'tb_mhs' } }
    /**
     * Find zero or one Tb_mhs that matches the filter.
     * @param {tb_mhsFindUniqueArgs} args - Arguments to find a Tb_mhs
     * @example
     * // Get one Tb_mhs
     * const tb_mhs = await prisma.tb_mhs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tb_mhsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tb_mhsFindUniqueArgs<ExtArgs>>
    ): Prisma__tb_mhsClient<$Result.GetResult<Prisma.$tb_mhsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tb_mhs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tb_mhsFindUniqueOrThrowArgs} args - Arguments to find a Tb_mhs
     * @example
     * // Get one Tb_mhs
     * const tb_mhs = await prisma.tb_mhs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tb_mhsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_mhsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tb_mhsClient<$Result.GetResult<Prisma.$tb_mhsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tb_mhs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_mhsFindFirstArgs} args - Arguments to find a Tb_mhs
     * @example
     * // Get one Tb_mhs
     * const tb_mhs = await prisma.tb_mhs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tb_mhsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_mhsFindFirstArgs<ExtArgs>>
    ): Prisma__tb_mhsClient<$Result.GetResult<Prisma.$tb_mhsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tb_mhs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_mhsFindFirstOrThrowArgs} args - Arguments to find a Tb_mhs
     * @example
     * // Get one Tb_mhs
     * const tb_mhs = await prisma.tb_mhs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tb_mhsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_mhsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tb_mhsClient<$Result.GetResult<Prisma.$tb_mhsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tb_mhs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_mhsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_mhs
     * const tb_mhs = await prisma.tb_mhs.findMany()
     * 
     * // Get first 10 Tb_mhs
     * const tb_mhs = await prisma.tb_mhs.findMany({ take: 10 })
     * 
     * // Only select the `nim`
     * const tb_mhsWithNimOnly = await prisma.tb_mhs.findMany({ select: { nim: true } })
     * 
    **/
    findMany<T extends tb_mhsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_mhsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_mhsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tb_mhs.
     * @param {tb_mhsCreateArgs} args - Arguments to create a Tb_mhs.
     * @example
     * // Create one Tb_mhs
     * const Tb_mhs = await prisma.tb_mhs.create({
     *   data: {
     *     // ... data to create a Tb_mhs
     *   }
     * })
     * 
    **/
    create<T extends tb_mhsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_mhsCreateArgs<ExtArgs>>
    ): Prisma__tb_mhsClient<$Result.GetResult<Prisma.$tb_mhsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tb_mhs.
     *     @param {tb_mhsCreateManyArgs} args - Arguments to create many Tb_mhs.
     *     @example
     *     // Create many Tb_mhs
     *     const tb_mhs = await prisma.tb_mhs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tb_mhsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_mhsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_mhs.
     * @param {tb_mhsDeleteArgs} args - Arguments to delete one Tb_mhs.
     * @example
     * // Delete one Tb_mhs
     * const Tb_mhs = await prisma.tb_mhs.delete({
     *   where: {
     *     // ... filter to delete one Tb_mhs
     *   }
     * })
     * 
    **/
    delete<T extends tb_mhsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tb_mhsDeleteArgs<ExtArgs>>
    ): Prisma__tb_mhsClient<$Result.GetResult<Prisma.$tb_mhsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tb_mhs.
     * @param {tb_mhsUpdateArgs} args - Arguments to update one Tb_mhs.
     * @example
     * // Update one Tb_mhs
     * const tb_mhs = await prisma.tb_mhs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tb_mhsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_mhsUpdateArgs<ExtArgs>>
    ): Prisma__tb_mhsClient<$Result.GetResult<Prisma.$tb_mhsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tb_mhs.
     * @param {tb_mhsDeleteManyArgs} args - Arguments to filter Tb_mhs to delete.
     * @example
     * // Delete a few Tb_mhs
     * const { count } = await prisma.tb_mhs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tb_mhsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_mhsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_mhs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_mhsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_mhs
     * const tb_mhs = await prisma.tb_mhs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tb_mhsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tb_mhsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_mhs.
     * @param {tb_mhsUpsertArgs} args - Arguments to update or create a Tb_mhs.
     * @example
     * // Update or create a Tb_mhs
     * const tb_mhs = await prisma.tb_mhs.upsert({
     *   create: {
     *     // ... data to create a Tb_mhs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_mhs we want to update
     *   }
     * })
    **/
    upsert<T extends tb_mhsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tb_mhsUpsertArgs<ExtArgs>>
    ): Prisma__tb_mhsClient<$Result.GetResult<Prisma.$tb_mhsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tb_mhs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_mhsCountArgs} args - Arguments to filter Tb_mhs to count.
     * @example
     * // Count the number of Tb_mhs
     * const count = await prisma.tb_mhs.count({
     *   where: {
     *     // ... the filter for the Tb_mhs we want to count
     *   }
     * })
    **/
    count<T extends tb_mhsCountArgs>(
      args?: Subset<T, tb_mhsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_mhsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_mhs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_mhsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_mhsAggregateArgs>(args: Subset<T, Tb_mhsAggregateArgs>): Prisma.PrismaPromise<GetTb_mhsAggregateType<T>>

    /**
     * Group by Tb_mhs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_mhsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_mhsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_mhsGroupByArgs['orderBy'] }
        : { orderBy?: tb_mhsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_mhsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_mhsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_mhs model
   */
  readonly fields: tb_mhsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_mhs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_mhsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    fk_kodeKab<T extends tb_mhs$fk_kodeKabArgs<ExtArgs> = {}>(args?: Subset<T, tb_mhs$fk_kodeKabArgs<ExtArgs>>): Prisma__tb_kabupatenClient<$Result.GetResult<Prisma.$tb_kabupatenPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    fk_kodeProv<T extends tb_mhs$fk_kodeProvArgs<ExtArgs> = {}>(args?: Subset<T, tb_mhs$fk_kodeProvArgs<ExtArgs>>): Prisma__tb_provinsiClient<$Result.GetResult<Prisma.$tb_provinsiPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    fk_kodeWali<T extends tb_dosenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tb_dosenDefaultArgs<ExtArgs>>): Prisma__tb_dosenClient<$Result.GetResult<Prisma.$tb_dosenPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    fk_nim_irs<T extends tb_mhs$fk_nim_irsArgs<ExtArgs> = {}>(args?: Subset<T, tb_mhs$fk_nim_irsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_irsPayload<ExtArgs>, T, 'findMany'> | Null>;

    fk_nim_khs<T extends tb_mhs$fk_nim_khsArgs<ExtArgs> = {}>(args?: Subset<T, tb_mhs$fk_nim_khsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_khsPayload<ExtArgs>, T, 'findMany'> | Null>;

    fk_nim_pkl<T extends tb_mhs$fk_nim_pklArgs<ExtArgs> = {}>(args?: Subset<T, tb_mhs$fk_nim_pklArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_pklPayload<ExtArgs>, T, 'findMany'> | Null>;

    fk_nim_skripsi<T extends tb_mhs$fk_nim_skripsiArgs<ExtArgs> = {}>(args?: Subset<T, tb_mhs$fk_nim_skripsiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_skripsiPayload<ExtArgs>, T, 'findMany'> | Null>;

    fk_pemilik_akun_mhs<T extends tb_mhs$fk_pemilik_akun_mhsArgs<ExtArgs> = {}>(args?: Subset<T, tb_mhs$fk_pemilik_akun_mhsArgs<ExtArgs>>): Prisma__tb_akun_mhsClient<$Result.GetResult<Prisma.$tb_akun_mhsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tb_mhs model
   */ 
  interface tb_mhsFieldRefs {
    readonly nim: FieldRef<"tb_mhs", 'String'>
    readonly nama: FieldRef<"tb_mhs", 'String'>
    readonly statusAktif: FieldRef<"tb_mhs", 'StatusMhs'>
    readonly alamat: FieldRef<"tb_mhs", 'String'>
    readonly email: FieldRef<"tb_mhs", 'String'>
    readonly kodeKab: FieldRef<"tb_mhs", 'String'>
    readonly kodeProv: FieldRef<"tb_mhs", 'String'>
    readonly jalurMasuk: FieldRef<"tb_mhs", 'JalurMasuk'>
    readonly angkatan: FieldRef<"tb_mhs", 'Int'>
    readonly noHP: FieldRef<"tb_mhs", 'String'>
    readonly kodeWali: FieldRef<"tb_mhs", 'String'>
    readonly foto: FieldRef<"tb_mhs", 'String'>
  }
    

  // Custom InputTypes

  /**
   * tb_mhs findUnique
   */
  export type tb_mhsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_mhs
     */
    select?: tb_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_mhsInclude<ExtArgs> | null
    /**
     * Filter, which tb_mhs to fetch.
     */
    where: tb_mhsWhereUniqueInput
  }


  /**
   * tb_mhs findUniqueOrThrow
   */
  export type tb_mhsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_mhs
     */
    select?: tb_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_mhsInclude<ExtArgs> | null
    /**
     * Filter, which tb_mhs to fetch.
     */
    where: tb_mhsWhereUniqueInput
  }


  /**
   * tb_mhs findFirst
   */
  export type tb_mhsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_mhs
     */
    select?: tb_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_mhsInclude<ExtArgs> | null
    /**
     * Filter, which tb_mhs to fetch.
     */
    where?: tb_mhsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_mhs to fetch.
     */
    orderBy?: tb_mhsOrderByWithRelationInput | tb_mhsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_mhs.
     */
    cursor?: tb_mhsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_mhs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_mhs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_mhs.
     */
    distinct?: Tb_mhsScalarFieldEnum | Tb_mhsScalarFieldEnum[]
  }


  /**
   * tb_mhs findFirstOrThrow
   */
  export type tb_mhsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_mhs
     */
    select?: tb_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_mhsInclude<ExtArgs> | null
    /**
     * Filter, which tb_mhs to fetch.
     */
    where?: tb_mhsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_mhs to fetch.
     */
    orderBy?: tb_mhsOrderByWithRelationInput | tb_mhsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_mhs.
     */
    cursor?: tb_mhsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_mhs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_mhs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_mhs.
     */
    distinct?: Tb_mhsScalarFieldEnum | Tb_mhsScalarFieldEnum[]
  }


  /**
   * tb_mhs findMany
   */
  export type tb_mhsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_mhs
     */
    select?: tb_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_mhsInclude<ExtArgs> | null
    /**
     * Filter, which tb_mhs to fetch.
     */
    where?: tb_mhsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_mhs to fetch.
     */
    orderBy?: tb_mhsOrderByWithRelationInput | tb_mhsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_mhs.
     */
    cursor?: tb_mhsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_mhs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_mhs.
     */
    skip?: number
    distinct?: Tb_mhsScalarFieldEnum | Tb_mhsScalarFieldEnum[]
  }


  /**
   * tb_mhs create
   */
  export type tb_mhsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_mhs
     */
    select?: tb_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_mhsInclude<ExtArgs> | null
    /**
     * The data needed to create a tb_mhs.
     */
    data: XOR<tb_mhsCreateInput, tb_mhsUncheckedCreateInput>
  }


  /**
   * tb_mhs createMany
   */
  export type tb_mhsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_mhs.
     */
    data: tb_mhsCreateManyInput | tb_mhsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tb_mhs update
   */
  export type tb_mhsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_mhs
     */
    select?: tb_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_mhsInclude<ExtArgs> | null
    /**
     * The data needed to update a tb_mhs.
     */
    data: XOR<tb_mhsUpdateInput, tb_mhsUncheckedUpdateInput>
    /**
     * Choose, which tb_mhs to update.
     */
    where: tb_mhsWhereUniqueInput
  }


  /**
   * tb_mhs updateMany
   */
  export type tb_mhsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_mhs.
     */
    data: XOR<tb_mhsUpdateManyMutationInput, tb_mhsUncheckedUpdateManyInput>
    /**
     * Filter which tb_mhs to update
     */
    where?: tb_mhsWhereInput
  }


  /**
   * tb_mhs upsert
   */
  export type tb_mhsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_mhs
     */
    select?: tb_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_mhsInclude<ExtArgs> | null
    /**
     * The filter to search for the tb_mhs to update in case it exists.
     */
    where: tb_mhsWhereUniqueInput
    /**
     * In case the tb_mhs found by the `where` argument doesn't exist, create a new tb_mhs with this data.
     */
    create: XOR<tb_mhsCreateInput, tb_mhsUncheckedCreateInput>
    /**
     * In case the tb_mhs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_mhsUpdateInput, tb_mhsUncheckedUpdateInput>
  }


  /**
   * tb_mhs delete
   */
  export type tb_mhsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_mhs
     */
    select?: tb_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_mhsInclude<ExtArgs> | null
    /**
     * Filter which tb_mhs to delete.
     */
    where: tb_mhsWhereUniqueInput
  }


  /**
   * tb_mhs deleteMany
   */
  export type tb_mhsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_mhs to delete
     */
    where?: tb_mhsWhereInput
  }


  /**
   * tb_mhs.fk_kodeKab
   */
  export type tb_mhs$fk_kodeKabArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_kabupaten
     */
    select?: tb_kabupatenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_kabupatenInclude<ExtArgs> | null
    where?: tb_kabupatenWhereInput
  }


  /**
   * tb_mhs.fk_kodeProv
   */
  export type tb_mhs$fk_kodeProvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_provinsi
     */
    select?: tb_provinsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_provinsiInclude<ExtArgs> | null
    where?: tb_provinsiWhereInput
  }


  /**
   * tb_mhs.fk_nim_irs
   */
  export type tb_mhs$fk_nim_irsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_irs
     */
    select?: tb_irsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_irsInclude<ExtArgs> | null
    where?: tb_irsWhereInput
    orderBy?: tb_irsOrderByWithRelationInput | tb_irsOrderByWithRelationInput[]
    cursor?: tb_irsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tb_irsScalarFieldEnum | Tb_irsScalarFieldEnum[]
  }


  /**
   * tb_mhs.fk_nim_khs
   */
  export type tb_mhs$fk_nim_khsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_khs
     */
    select?: tb_khsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_khsInclude<ExtArgs> | null
    where?: tb_khsWhereInput
    orderBy?: tb_khsOrderByWithRelationInput | tb_khsOrderByWithRelationInput[]
    cursor?: tb_khsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tb_khsScalarFieldEnum | Tb_khsScalarFieldEnum[]
  }


  /**
   * tb_mhs.fk_nim_pkl
   */
  export type tb_mhs$fk_nim_pklArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_pkl
     */
    select?: tb_pklSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_pklInclude<ExtArgs> | null
    where?: tb_pklWhereInput
    orderBy?: tb_pklOrderByWithRelationInput | tb_pklOrderByWithRelationInput[]
    cursor?: tb_pklWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tb_pklScalarFieldEnum | Tb_pklScalarFieldEnum[]
  }


  /**
   * tb_mhs.fk_nim_skripsi
   */
  export type tb_mhs$fk_nim_skripsiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_skripsi
     */
    select?: tb_skripsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_skripsiInclude<ExtArgs> | null
    where?: tb_skripsiWhereInput
    orderBy?: tb_skripsiOrderByWithRelationInput | tb_skripsiOrderByWithRelationInput[]
    cursor?: tb_skripsiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tb_skripsiScalarFieldEnum | Tb_skripsiScalarFieldEnum[]
  }


  /**
   * tb_mhs.fk_pemilik_akun_mhs
   */
  export type tb_mhs$fk_pemilik_akun_mhsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_mhs
     */
    select?: tb_akun_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_mhsInclude<ExtArgs> | null
    where?: tb_akun_mhsWhereInput
  }


  /**
   * tb_mhs without action
   */
  export type tb_mhsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_mhs
     */
    select?: tb_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_mhsInclude<ExtArgs> | null
  }



  /**
   * Model tb_dosen
   */

  export type AggregateTb_dosen = {
    _count: Tb_dosenCountAggregateOutputType | null
    _min: Tb_dosenMinAggregateOutputType | null
    _max: Tb_dosenMaxAggregateOutputType | null
  }

  export type Tb_dosenMinAggregateOutputType = {
    nip: string | null
    nama: string | null
    alamat: string | null
    email: string | null
    kodeKab: string | null
    kodeProv: string | null
    noHP: string | null
    foto: string | null
  }

  export type Tb_dosenMaxAggregateOutputType = {
    nip: string | null
    nama: string | null
    alamat: string | null
    email: string | null
    kodeKab: string | null
    kodeProv: string | null
    noHP: string | null
    foto: string | null
  }

  export type Tb_dosenCountAggregateOutputType = {
    nip: number
    nama: number
    alamat: number
    email: number
    kodeKab: number
    kodeProv: number
    noHP: number
    foto: number
    _all: number
  }


  export type Tb_dosenMinAggregateInputType = {
    nip?: true
    nama?: true
    alamat?: true
    email?: true
    kodeKab?: true
    kodeProv?: true
    noHP?: true
    foto?: true
  }

  export type Tb_dosenMaxAggregateInputType = {
    nip?: true
    nama?: true
    alamat?: true
    email?: true
    kodeKab?: true
    kodeProv?: true
    noHP?: true
    foto?: true
  }

  export type Tb_dosenCountAggregateInputType = {
    nip?: true
    nama?: true
    alamat?: true
    email?: true
    kodeKab?: true
    kodeProv?: true
    noHP?: true
    foto?: true
    _all?: true
  }

  export type Tb_dosenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_dosen to aggregate.
     */
    where?: tb_dosenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_dosens to fetch.
     */
    orderBy?: tb_dosenOrderByWithRelationInput | tb_dosenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_dosenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_dosens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_dosens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_dosens
    **/
    _count?: true | Tb_dosenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_dosenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_dosenMaxAggregateInputType
  }

  export type GetTb_dosenAggregateType<T extends Tb_dosenAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_dosen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_dosen[P]>
      : GetScalarType<T[P], AggregateTb_dosen[P]>
  }




  export type tb_dosenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_dosenWhereInput
    orderBy?: tb_dosenOrderByWithAggregationInput | tb_dosenOrderByWithAggregationInput[]
    by: Tb_dosenScalarFieldEnum[] | Tb_dosenScalarFieldEnum
    having?: tb_dosenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_dosenCountAggregateInputType | true
    _min?: Tb_dosenMinAggregateInputType
    _max?: Tb_dosenMaxAggregateInputType
  }

  export type Tb_dosenGroupByOutputType = {
    nip: string
    nama: string
    alamat: string | null
    email: string | null
    kodeKab: string | null
    kodeProv: string | null
    noHP: string | null
    foto: string | null
    _count: Tb_dosenCountAggregateOutputType | null
    _min: Tb_dosenMinAggregateOutputType | null
    _max: Tb_dosenMaxAggregateOutputType | null
  }

  type GetTb_dosenGroupByPayload<T extends tb_dosenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_dosenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_dosenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_dosenGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_dosenGroupByOutputType[P]>
        }
      >
    >


  export type tb_dosenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nip?: boolean
    nama?: boolean
    alamat?: boolean
    email?: boolean
    kodeKab?: boolean
    kodeProv?: boolean
    noHP?: boolean
    foto?: boolean
    fk_kodeKab?: boolean | tb_dosen$fk_kodeKabArgs<ExtArgs>
    fk_kodeProv?: boolean | tb_dosen$fk_kodeProvArgs<ExtArgs>
    fk_kodeWali_mhs?: boolean | tb_dosen$fk_kodeWali_mhsArgs<ExtArgs>
    fk_pemilik_akun_dosen?: boolean | tb_dosen$fk_pemilik_akun_dosenArgs<ExtArgs>
    _count?: boolean | Tb_dosenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tb_dosen"]>

  export type tb_dosenSelectScalar = {
    nip?: boolean
    nama?: boolean
    alamat?: boolean
    email?: boolean
    kodeKab?: boolean
    kodeProv?: boolean
    noHP?: boolean
    foto?: boolean
  }

  export type tb_dosenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fk_kodeKab?: boolean | tb_dosen$fk_kodeKabArgs<ExtArgs>
    fk_kodeProv?: boolean | tb_dosen$fk_kodeProvArgs<ExtArgs>
    fk_kodeWali_mhs?: boolean | tb_dosen$fk_kodeWali_mhsArgs<ExtArgs>
    fk_pemilik_akun_dosen?: boolean | tb_dosen$fk_pemilik_akun_dosenArgs<ExtArgs>
    _count?: boolean | Tb_dosenCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $tb_dosenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_dosen"
    objects: {
      fk_kodeKab: Prisma.$tb_kabupatenPayload<ExtArgs> | null
      fk_kodeProv: Prisma.$tb_provinsiPayload<ExtArgs> | null
      fk_kodeWali_mhs: Prisma.$tb_mhsPayload<ExtArgs>[]
      fk_pemilik_akun_dosen: Prisma.$tb_akun_dosenPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      nip: string
      nama: string
      alamat: string | null
      email: string | null
      kodeKab: string | null
      kodeProv: string | null
      noHP: string | null
      foto: string | null
    }, ExtArgs["result"]["tb_dosen"]>
    composites: {}
  }


  type tb_dosenGetPayload<S extends boolean | null | undefined | tb_dosenDefaultArgs> = $Result.GetResult<Prisma.$tb_dosenPayload, S>

  type tb_dosenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tb_dosenFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Tb_dosenCountAggregateInputType | true
    }

  export interface tb_dosenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_dosen'], meta: { name: 'tb_dosen' } }
    /**
     * Find zero or one Tb_dosen that matches the filter.
     * @param {tb_dosenFindUniqueArgs} args - Arguments to find a Tb_dosen
     * @example
     * // Get one Tb_dosen
     * const tb_dosen = await prisma.tb_dosen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tb_dosenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tb_dosenFindUniqueArgs<ExtArgs>>
    ): Prisma__tb_dosenClient<$Result.GetResult<Prisma.$tb_dosenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tb_dosen that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tb_dosenFindUniqueOrThrowArgs} args - Arguments to find a Tb_dosen
     * @example
     * // Get one Tb_dosen
     * const tb_dosen = await prisma.tb_dosen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tb_dosenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_dosenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tb_dosenClient<$Result.GetResult<Prisma.$tb_dosenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tb_dosen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_dosenFindFirstArgs} args - Arguments to find a Tb_dosen
     * @example
     * // Get one Tb_dosen
     * const tb_dosen = await prisma.tb_dosen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tb_dosenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_dosenFindFirstArgs<ExtArgs>>
    ): Prisma__tb_dosenClient<$Result.GetResult<Prisma.$tb_dosenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tb_dosen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_dosenFindFirstOrThrowArgs} args - Arguments to find a Tb_dosen
     * @example
     * // Get one Tb_dosen
     * const tb_dosen = await prisma.tb_dosen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tb_dosenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_dosenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tb_dosenClient<$Result.GetResult<Prisma.$tb_dosenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tb_dosens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_dosenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_dosens
     * const tb_dosens = await prisma.tb_dosen.findMany()
     * 
     * // Get first 10 Tb_dosens
     * const tb_dosens = await prisma.tb_dosen.findMany({ take: 10 })
     * 
     * // Only select the `nip`
     * const tb_dosenWithNipOnly = await prisma.tb_dosen.findMany({ select: { nip: true } })
     * 
    **/
    findMany<T extends tb_dosenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_dosenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_dosenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tb_dosen.
     * @param {tb_dosenCreateArgs} args - Arguments to create a Tb_dosen.
     * @example
     * // Create one Tb_dosen
     * const Tb_dosen = await prisma.tb_dosen.create({
     *   data: {
     *     // ... data to create a Tb_dosen
     *   }
     * })
     * 
    **/
    create<T extends tb_dosenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_dosenCreateArgs<ExtArgs>>
    ): Prisma__tb_dosenClient<$Result.GetResult<Prisma.$tb_dosenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tb_dosens.
     *     @param {tb_dosenCreateManyArgs} args - Arguments to create many Tb_dosens.
     *     @example
     *     // Create many Tb_dosens
     *     const tb_dosen = await prisma.tb_dosen.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tb_dosenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_dosenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_dosen.
     * @param {tb_dosenDeleteArgs} args - Arguments to delete one Tb_dosen.
     * @example
     * // Delete one Tb_dosen
     * const Tb_dosen = await prisma.tb_dosen.delete({
     *   where: {
     *     // ... filter to delete one Tb_dosen
     *   }
     * })
     * 
    **/
    delete<T extends tb_dosenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tb_dosenDeleteArgs<ExtArgs>>
    ): Prisma__tb_dosenClient<$Result.GetResult<Prisma.$tb_dosenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tb_dosen.
     * @param {tb_dosenUpdateArgs} args - Arguments to update one Tb_dosen.
     * @example
     * // Update one Tb_dosen
     * const tb_dosen = await prisma.tb_dosen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tb_dosenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_dosenUpdateArgs<ExtArgs>>
    ): Prisma__tb_dosenClient<$Result.GetResult<Prisma.$tb_dosenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tb_dosens.
     * @param {tb_dosenDeleteManyArgs} args - Arguments to filter Tb_dosens to delete.
     * @example
     * // Delete a few Tb_dosens
     * const { count } = await prisma.tb_dosen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tb_dosenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_dosenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_dosens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_dosenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_dosens
     * const tb_dosen = await prisma.tb_dosen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tb_dosenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tb_dosenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_dosen.
     * @param {tb_dosenUpsertArgs} args - Arguments to update or create a Tb_dosen.
     * @example
     * // Update or create a Tb_dosen
     * const tb_dosen = await prisma.tb_dosen.upsert({
     *   create: {
     *     // ... data to create a Tb_dosen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_dosen we want to update
     *   }
     * })
    **/
    upsert<T extends tb_dosenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tb_dosenUpsertArgs<ExtArgs>>
    ): Prisma__tb_dosenClient<$Result.GetResult<Prisma.$tb_dosenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tb_dosens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_dosenCountArgs} args - Arguments to filter Tb_dosens to count.
     * @example
     * // Count the number of Tb_dosens
     * const count = await prisma.tb_dosen.count({
     *   where: {
     *     // ... the filter for the Tb_dosens we want to count
     *   }
     * })
    **/
    count<T extends tb_dosenCountArgs>(
      args?: Subset<T, tb_dosenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_dosenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_dosen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_dosenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_dosenAggregateArgs>(args: Subset<T, Tb_dosenAggregateArgs>): Prisma.PrismaPromise<GetTb_dosenAggregateType<T>>

    /**
     * Group by Tb_dosen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_dosenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_dosenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_dosenGroupByArgs['orderBy'] }
        : { orderBy?: tb_dosenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_dosenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_dosenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_dosen model
   */
  readonly fields: tb_dosenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_dosen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_dosenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    fk_kodeKab<T extends tb_dosen$fk_kodeKabArgs<ExtArgs> = {}>(args?: Subset<T, tb_dosen$fk_kodeKabArgs<ExtArgs>>): Prisma__tb_kabupatenClient<$Result.GetResult<Prisma.$tb_kabupatenPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    fk_kodeProv<T extends tb_dosen$fk_kodeProvArgs<ExtArgs> = {}>(args?: Subset<T, tb_dosen$fk_kodeProvArgs<ExtArgs>>): Prisma__tb_provinsiClient<$Result.GetResult<Prisma.$tb_provinsiPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    fk_kodeWali_mhs<T extends tb_dosen$fk_kodeWali_mhsArgs<ExtArgs> = {}>(args?: Subset<T, tb_dosen$fk_kodeWali_mhsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_mhsPayload<ExtArgs>, T, 'findMany'> | Null>;

    fk_pemilik_akun_dosen<T extends tb_dosen$fk_pemilik_akun_dosenArgs<ExtArgs> = {}>(args?: Subset<T, tb_dosen$fk_pemilik_akun_dosenArgs<ExtArgs>>): Prisma__tb_akun_dosenClient<$Result.GetResult<Prisma.$tb_akun_dosenPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tb_dosen model
   */ 
  interface tb_dosenFieldRefs {
    readonly nip: FieldRef<"tb_dosen", 'String'>
    readonly nama: FieldRef<"tb_dosen", 'String'>
    readonly alamat: FieldRef<"tb_dosen", 'String'>
    readonly email: FieldRef<"tb_dosen", 'String'>
    readonly kodeKab: FieldRef<"tb_dosen", 'String'>
    readonly kodeProv: FieldRef<"tb_dosen", 'String'>
    readonly noHP: FieldRef<"tb_dosen", 'String'>
    readonly foto: FieldRef<"tb_dosen", 'String'>
  }
    

  // Custom InputTypes

  /**
   * tb_dosen findUnique
   */
  export type tb_dosenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_dosen
     */
    select?: tb_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_dosenInclude<ExtArgs> | null
    /**
     * Filter, which tb_dosen to fetch.
     */
    where: tb_dosenWhereUniqueInput
  }


  /**
   * tb_dosen findUniqueOrThrow
   */
  export type tb_dosenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_dosen
     */
    select?: tb_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_dosenInclude<ExtArgs> | null
    /**
     * Filter, which tb_dosen to fetch.
     */
    where: tb_dosenWhereUniqueInput
  }


  /**
   * tb_dosen findFirst
   */
  export type tb_dosenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_dosen
     */
    select?: tb_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_dosenInclude<ExtArgs> | null
    /**
     * Filter, which tb_dosen to fetch.
     */
    where?: tb_dosenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_dosens to fetch.
     */
    orderBy?: tb_dosenOrderByWithRelationInput | tb_dosenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_dosens.
     */
    cursor?: tb_dosenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_dosens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_dosens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_dosens.
     */
    distinct?: Tb_dosenScalarFieldEnum | Tb_dosenScalarFieldEnum[]
  }


  /**
   * tb_dosen findFirstOrThrow
   */
  export type tb_dosenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_dosen
     */
    select?: tb_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_dosenInclude<ExtArgs> | null
    /**
     * Filter, which tb_dosen to fetch.
     */
    where?: tb_dosenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_dosens to fetch.
     */
    orderBy?: tb_dosenOrderByWithRelationInput | tb_dosenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_dosens.
     */
    cursor?: tb_dosenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_dosens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_dosens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_dosens.
     */
    distinct?: Tb_dosenScalarFieldEnum | Tb_dosenScalarFieldEnum[]
  }


  /**
   * tb_dosen findMany
   */
  export type tb_dosenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_dosen
     */
    select?: tb_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_dosenInclude<ExtArgs> | null
    /**
     * Filter, which tb_dosens to fetch.
     */
    where?: tb_dosenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_dosens to fetch.
     */
    orderBy?: tb_dosenOrderByWithRelationInput | tb_dosenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_dosens.
     */
    cursor?: tb_dosenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_dosens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_dosens.
     */
    skip?: number
    distinct?: Tb_dosenScalarFieldEnum | Tb_dosenScalarFieldEnum[]
  }


  /**
   * tb_dosen create
   */
  export type tb_dosenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_dosen
     */
    select?: tb_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_dosenInclude<ExtArgs> | null
    /**
     * The data needed to create a tb_dosen.
     */
    data: XOR<tb_dosenCreateInput, tb_dosenUncheckedCreateInput>
  }


  /**
   * tb_dosen createMany
   */
  export type tb_dosenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_dosens.
     */
    data: tb_dosenCreateManyInput | tb_dosenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tb_dosen update
   */
  export type tb_dosenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_dosen
     */
    select?: tb_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_dosenInclude<ExtArgs> | null
    /**
     * The data needed to update a tb_dosen.
     */
    data: XOR<tb_dosenUpdateInput, tb_dosenUncheckedUpdateInput>
    /**
     * Choose, which tb_dosen to update.
     */
    where: tb_dosenWhereUniqueInput
  }


  /**
   * tb_dosen updateMany
   */
  export type tb_dosenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_dosens.
     */
    data: XOR<tb_dosenUpdateManyMutationInput, tb_dosenUncheckedUpdateManyInput>
    /**
     * Filter which tb_dosens to update
     */
    where?: tb_dosenWhereInput
  }


  /**
   * tb_dosen upsert
   */
  export type tb_dosenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_dosen
     */
    select?: tb_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_dosenInclude<ExtArgs> | null
    /**
     * The filter to search for the tb_dosen to update in case it exists.
     */
    where: tb_dosenWhereUniqueInput
    /**
     * In case the tb_dosen found by the `where` argument doesn't exist, create a new tb_dosen with this data.
     */
    create: XOR<tb_dosenCreateInput, tb_dosenUncheckedCreateInput>
    /**
     * In case the tb_dosen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_dosenUpdateInput, tb_dosenUncheckedUpdateInput>
  }


  /**
   * tb_dosen delete
   */
  export type tb_dosenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_dosen
     */
    select?: tb_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_dosenInclude<ExtArgs> | null
    /**
     * Filter which tb_dosen to delete.
     */
    where: tb_dosenWhereUniqueInput
  }


  /**
   * tb_dosen deleteMany
   */
  export type tb_dosenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_dosens to delete
     */
    where?: tb_dosenWhereInput
  }


  /**
   * tb_dosen.fk_kodeKab
   */
  export type tb_dosen$fk_kodeKabArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_kabupaten
     */
    select?: tb_kabupatenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_kabupatenInclude<ExtArgs> | null
    where?: tb_kabupatenWhereInput
  }


  /**
   * tb_dosen.fk_kodeProv
   */
  export type tb_dosen$fk_kodeProvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_provinsi
     */
    select?: tb_provinsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_provinsiInclude<ExtArgs> | null
    where?: tb_provinsiWhereInput
  }


  /**
   * tb_dosen.fk_kodeWali_mhs
   */
  export type tb_dosen$fk_kodeWali_mhsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_mhs
     */
    select?: tb_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_mhsInclude<ExtArgs> | null
    where?: tb_mhsWhereInput
    orderBy?: tb_mhsOrderByWithRelationInput | tb_mhsOrderByWithRelationInput[]
    cursor?: tb_mhsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tb_mhsScalarFieldEnum | Tb_mhsScalarFieldEnum[]
  }


  /**
   * tb_dosen.fk_pemilik_akun_dosen
   */
  export type tb_dosen$fk_pemilik_akun_dosenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_dosen
     */
    select?: tb_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_dosenInclude<ExtArgs> | null
    where?: tb_akun_dosenWhereInput
  }


  /**
   * tb_dosen without action
   */
  export type tb_dosenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_dosen
     */
    select?: tb_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_dosenInclude<ExtArgs> | null
  }



  /**
   * Model tb_irs
   */

  export type AggregateTb_irs = {
    _count: Tb_irsCountAggregateOutputType | null
    _min: Tb_irsMinAggregateOutputType | null
    _max: Tb_irsMaxAggregateOutputType | null
  }

  export type Tb_irsMinAggregateOutputType = {
    nim: string | null
    semester: string | null
    status: $Enums.StatusAktif | null
    jumlahSks: string | null
    fileIrs: string | null
    statusValidasi: boolean | null
  }

  export type Tb_irsMaxAggregateOutputType = {
    nim: string | null
    semester: string | null
    status: $Enums.StatusAktif | null
    jumlahSks: string | null
    fileIrs: string | null
    statusValidasi: boolean | null
  }

  export type Tb_irsCountAggregateOutputType = {
    nim: number
    semester: number
    status: number
    jumlahSks: number
    fileIrs: number
    statusValidasi: number
    _all: number
  }


  export type Tb_irsMinAggregateInputType = {
    nim?: true
    semester?: true
    status?: true
    jumlahSks?: true
    fileIrs?: true
    statusValidasi?: true
  }

  export type Tb_irsMaxAggregateInputType = {
    nim?: true
    semester?: true
    status?: true
    jumlahSks?: true
    fileIrs?: true
    statusValidasi?: true
  }

  export type Tb_irsCountAggregateInputType = {
    nim?: true
    semester?: true
    status?: true
    jumlahSks?: true
    fileIrs?: true
    statusValidasi?: true
    _all?: true
  }

  export type Tb_irsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_irs to aggregate.
     */
    where?: tb_irsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_irs to fetch.
     */
    orderBy?: tb_irsOrderByWithRelationInput | tb_irsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_irsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_irs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_irs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_irs
    **/
    _count?: true | Tb_irsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_irsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_irsMaxAggregateInputType
  }

  export type GetTb_irsAggregateType<T extends Tb_irsAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_irs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_irs[P]>
      : GetScalarType<T[P], AggregateTb_irs[P]>
  }




  export type tb_irsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_irsWhereInput
    orderBy?: tb_irsOrderByWithAggregationInput | tb_irsOrderByWithAggregationInput[]
    by: Tb_irsScalarFieldEnum[] | Tb_irsScalarFieldEnum
    having?: tb_irsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_irsCountAggregateInputType | true
    _min?: Tb_irsMinAggregateInputType
    _max?: Tb_irsMaxAggregateInputType
  }

  export type Tb_irsGroupByOutputType = {
    nim: string
    semester: string
    status: $Enums.StatusAktif
    jumlahSks: string | null
    fileIrs: string | null
    statusValidasi: boolean
    _count: Tb_irsCountAggregateOutputType | null
    _min: Tb_irsMinAggregateOutputType | null
    _max: Tb_irsMaxAggregateOutputType | null
  }

  type GetTb_irsGroupByPayload<T extends tb_irsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_irsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_irsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_irsGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_irsGroupByOutputType[P]>
        }
      >
    >


  export type tb_irsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nim?: boolean
    semester?: boolean
    status?: boolean
    jumlahSks?: boolean
    fileIrs?: boolean
    statusValidasi?: boolean
    fk_nim?: boolean | tb_mhsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tb_irs"]>

  export type tb_irsSelectScalar = {
    nim?: boolean
    semester?: boolean
    status?: boolean
    jumlahSks?: boolean
    fileIrs?: boolean
    statusValidasi?: boolean
  }

  export type tb_irsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fk_nim?: boolean | tb_mhsDefaultArgs<ExtArgs>
  }


  export type $tb_irsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_irs"
    objects: {
      fk_nim: Prisma.$tb_mhsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      nim: string
      semester: string
      status: $Enums.StatusAktif
      jumlahSks: string | null
      fileIrs: string | null
      statusValidasi: boolean
    }, ExtArgs["result"]["tb_irs"]>
    composites: {}
  }


  type tb_irsGetPayload<S extends boolean | null | undefined | tb_irsDefaultArgs> = $Result.GetResult<Prisma.$tb_irsPayload, S>

  type tb_irsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tb_irsFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Tb_irsCountAggregateInputType | true
    }

  export interface tb_irsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_irs'], meta: { name: 'tb_irs' } }
    /**
     * Find zero or one Tb_irs that matches the filter.
     * @param {tb_irsFindUniqueArgs} args - Arguments to find a Tb_irs
     * @example
     * // Get one Tb_irs
     * const tb_irs = await prisma.tb_irs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tb_irsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tb_irsFindUniqueArgs<ExtArgs>>
    ): Prisma__tb_irsClient<$Result.GetResult<Prisma.$tb_irsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tb_irs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tb_irsFindUniqueOrThrowArgs} args - Arguments to find a Tb_irs
     * @example
     * // Get one Tb_irs
     * const tb_irs = await prisma.tb_irs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tb_irsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_irsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tb_irsClient<$Result.GetResult<Prisma.$tb_irsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tb_irs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_irsFindFirstArgs} args - Arguments to find a Tb_irs
     * @example
     * // Get one Tb_irs
     * const tb_irs = await prisma.tb_irs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tb_irsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_irsFindFirstArgs<ExtArgs>>
    ): Prisma__tb_irsClient<$Result.GetResult<Prisma.$tb_irsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tb_irs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_irsFindFirstOrThrowArgs} args - Arguments to find a Tb_irs
     * @example
     * // Get one Tb_irs
     * const tb_irs = await prisma.tb_irs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tb_irsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_irsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tb_irsClient<$Result.GetResult<Prisma.$tb_irsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tb_irs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_irsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_irs
     * const tb_irs = await prisma.tb_irs.findMany()
     * 
     * // Get first 10 Tb_irs
     * const tb_irs = await prisma.tb_irs.findMany({ take: 10 })
     * 
     * // Only select the `nim`
     * const tb_irsWithNimOnly = await prisma.tb_irs.findMany({ select: { nim: true } })
     * 
    **/
    findMany<T extends tb_irsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_irsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_irsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tb_irs.
     * @param {tb_irsCreateArgs} args - Arguments to create a Tb_irs.
     * @example
     * // Create one Tb_irs
     * const Tb_irs = await prisma.tb_irs.create({
     *   data: {
     *     // ... data to create a Tb_irs
     *   }
     * })
     * 
    **/
    create<T extends tb_irsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_irsCreateArgs<ExtArgs>>
    ): Prisma__tb_irsClient<$Result.GetResult<Prisma.$tb_irsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tb_irs.
     *     @param {tb_irsCreateManyArgs} args - Arguments to create many Tb_irs.
     *     @example
     *     // Create many Tb_irs
     *     const tb_irs = await prisma.tb_irs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tb_irsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_irsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_irs.
     * @param {tb_irsDeleteArgs} args - Arguments to delete one Tb_irs.
     * @example
     * // Delete one Tb_irs
     * const Tb_irs = await prisma.tb_irs.delete({
     *   where: {
     *     // ... filter to delete one Tb_irs
     *   }
     * })
     * 
    **/
    delete<T extends tb_irsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tb_irsDeleteArgs<ExtArgs>>
    ): Prisma__tb_irsClient<$Result.GetResult<Prisma.$tb_irsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tb_irs.
     * @param {tb_irsUpdateArgs} args - Arguments to update one Tb_irs.
     * @example
     * // Update one Tb_irs
     * const tb_irs = await prisma.tb_irs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tb_irsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_irsUpdateArgs<ExtArgs>>
    ): Prisma__tb_irsClient<$Result.GetResult<Prisma.$tb_irsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tb_irs.
     * @param {tb_irsDeleteManyArgs} args - Arguments to filter Tb_irs to delete.
     * @example
     * // Delete a few Tb_irs
     * const { count } = await prisma.tb_irs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tb_irsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_irsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_irs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_irsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_irs
     * const tb_irs = await prisma.tb_irs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tb_irsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tb_irsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_irs.
     * @param {tb_irsUpsertArgs} args - Arguments to update or create a Tb_irs.
     * @example
     * // Update or create a Tb_irs
     * const tb_irs = await prisma.tb_irs.upsert({
     *   create: {
     *     // ... data to create a Tb_irs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_irs we want to update
     *   }
     * })
    **/
    upsert<T extends tb_irsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tb_irsUpsertArgs<ExtArgs>>
    ): Prisma__tb_irsClient<$Result.GetResult<Prisma.$tb_irsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tb_irs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_irsCountArgs} args - Arguments to filter Tb_irs to count.
     * @example
     * // Count the number of Tb_irs
     * const count = await prisma.tb_irs.count({
     *   where: {
     *     // ... the filter for the Tb_irs we want to count
     *   }
     * })
    **/
    count<T extends tb_irsCountArgs>(
      args?: Subset<T, tb_irsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_irsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_irs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_irsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_irsAggregateArgs>(args: Subset<T, Tb_irsAggregateArgs>): Prisma.PrismaPromise<GetTb_irsAggregateType<T>>

    /**
     * Group by Tb_irs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_irsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_irsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_irsGroupByArgs['orderBy'] }
        : { orderBy?: tb_irsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_irsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_irsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_irs model
   */
  readonly fields: tb_irsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_irs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_irsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    fk_nim<T extends tb_mhsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tb_mhsDefaultArgs<ExtArgs>>): Prisma__tb_mhsClient<$Result.GetResult<Prisma.$tb_mhsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tb_irs model
   */ 
  interface tb_irsFieldRefs {
    readonly nim: FieldRef<"tb_irs", 'String'>
    readonly semester: FieldRef<"tb_irs", 'String'>
    readonly status: FieldRef<"tb_irs", 'StatusAktif'>
    readonly jumlahSks: FieldRef<"tb_irs", 'String'>
    readonly fileIrs: FieldRef<"tb_irs", 'String'>
    readonly statusValidasi: FieldRef<"tb_irs", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * tb_irs findUnique
   */
  export type tb_irsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_irs
     */
    select?: tb_irsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_irsInclude<ExtArgs> | null
    /**
     * Filter, which tb_irs to fetch.
     */
    where: tb_irsWhereUniqueInput
  }


  /**
   * tb_irs findUniqueOrThrow
   */
  export type tb_irsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_irs
     */
    select?: tb_irsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_irsInclude<ExtArgs> | null
    /**
     * Filter, which tb_irs to fetch.
     */
    where: tb_irsWhereUniqueInput
  }


  /**
   * tb_irs findFirst
   */
  export type tb_irsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_irs
     */
    select?: tb_irsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_irsInclude<ExtArgs> | null
    /**
     * Filter, which tb_irs to fetch.
     */
    where?: tb_irsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_irs to fetch.
     */
    orderBy?: tb_irsOrderByWithRelationInput | tb_irsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_irs.
     */
    cursor?: tb_irsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_irs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_irs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_irs.
     */
    distinct?: Tb_irsScalarFieldEnum | Tb_irsScalarFieldEnum[]
  }


  /**
   * tb_irs findFirstOrThrow
   */
  export type tb_irsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_irs
     */
    select?: tb_irsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_irsInclude<ExtArgs> | null
    /**
     * Filter, which tb_irs to fetch.
     */
    where?: tb_irsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_irs to fetch.
     */
    orderBy?: tb_irsOrderByWithRelationInput | tb_irsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_irs.
     */
    cursor?: tb_irsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_irs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_irs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_irs.
     */
    distinct?: Tb_irsScalarFieldEnum | Tb_irsScalarFieldEnum[]
  }


  /**
   * tb_irs findMany
   */
  export type tb_irsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_irs
     */
    select?: tb_irsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_irsInclude<ExtArgs> | null
    /**
     * Filter, which tb_irs to fetch.
     */
    where?: tb_irsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_irs to fetch.
     */
    orderBy?: tb_irsOrderByWithRelationInput | tb_irsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_irs.
     */
    cursor?: tb_irsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_irs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_irs.
     */
    skip?: number
    distinct?: Tb_irsScalarFieldEnum | Tb_irsScalarFieldEnum[]
  }


  /**
   * tb_irs create
   */
  export type tb_irsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_irs
     */
    select?: tb_irsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_irsInclude<ExtArgs> | null
    /**
     * The data needed to create a tb_irs.
     */
    data: XOR<tb_irsCreateInput, tb_irsUncheckedCreateInput>
  }


  /**
   * tb_irs createMany
   */
  export type tb_irsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_irs.
     */
    data: tb_irsCreateManyInput | tb_irsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tb_irs update
   */
  export type tb_irsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_irs
     */
    select?: tb_irsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_irsInclude<ExtArgs> | null
    /**
     * The data needed to update a tb_irs.
     */
    data: XOR<tb_irsUpdateInput, tb_irsUncheckedUpdateInput>
    /**
     * Choose, which tb_irs to update.
     */
    where: tb_irsWhereUniqueInput
  }


  /**
   * tb_irs updateMany
   */
  export type tb_irsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_irs.
     */
    data: XOR<tb_irsUpdateManyMutationInput, tb_irsUncheckedUpdateManyInput>
    /**
     * Filter which tb_irs to update
     */
    where?: tb_irsWhereInput
  }


  /**
   * tb_irs upsert
   */
  export type tb_irsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_irs
     */
    select?: tb_irsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_irsInclude<ExtArgs> | null
    /**
     * The filter to search for the tb_irs to update in case it exists.
     */
    where: tb_irsWhereUniqueInput
    /**
     * In case the tb_irs found by the `where` argument doesn't exist, create a new tb_irs with this data.
     */
    create: XOR<tb_irsCreateInput, tb_irsUncheckedCreateInput>
    /**
     * In case the tb_irs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_irsUpdateInput, tb_irsUncheckedUpdateInput>
  }


  /**
   * tb_irs delete
   */
  export type tb_irsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_irs
     */
    select?: tb_irsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_irsInclude<ExtArgs> | null
    /**
     * Filter which tb_irs to delete.
     */
    where: tb_irsWhereUniqueInput
  }


  /**
   * tb_irs deleteMany
   */
  export type tb_irsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_irs to delete
     */
    where?: tb_irsWhereInput
  }


  /**
   * tb_irs without action
   */
  export type tb_irsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_irs
     */
    select?: tb_irsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_irsInclude<ExtArgs> | null
  }



  /**
   * Model tb_khs
   */

  export type AggregateTb_khs = {
    _count: Tb_khsCountAggregateOutputType | null
    _min: Tb_khsMinAggregateOutputType | null
    _max: Tb_khsMaxAggregateOutputType | null
  }

  export type Tb_khsMinAggregateOutputType = {
    nim: string | null
    semester: string | null
    status: $Enums.StatusAktif | null
    jumlahSksSemester: string | null
    ips: string | null
    jumlahSksKumulatif: string | null
    ipk: string | null
    fileKhs: string | null
    statusValidasi: boolean | null
  }

  export type Tb_khsMaxAggregateOutputType = {
    nim: string | null
    semester: string | null
    status: $Enums.StatusAktif | null
    jumlahSksSemester: string | null
    ips: string | null
    jumlahSksKumulatif: string | null
    ipk: string | null
    fileKhs: string | null
    statusValidasi: boolean | null
  }

  export type Tb_khsCountAggregateOutputType = {
    nim: number
    semester: number
    status: number
    jumlahSksSemester: number
    ips: number
    jumlahSksKumulatif: number
    ipk: number
    fileKhs: number
    statusValidasi: number
    _all: number
  }


  export type Tb_khsMinAggregateInputType = {
    nim?: true
    semester?: true
    status?: true
    jumlahSksSemester?: true
    ips?: true
    jumlahSksKumulatif?: true
    ipk?: true
    fileKhs?: true
    statusValidasi?: true
  }

  export type Tb_khsMaxAggregateInputType = {
    nim?: true
    semester?: true
    status?: true
    jumlahSksSemester?: true
    ips?: true
    jumlahSksKumulatif?: true
    ipk?: true
    fileKhs?: true
    statusValidasi?: true
  }

  export type Tb_khsCountAggregateInputType = {
    nim?: true
    semester?: true
    status?: true
    jumlahSksSemester?: true
    ips?: true
    jumlahSksKumulatif?: true
    ipk?: true
    fileKhs?: true
    statusValidasi?: true
    _all?: true
  }

  export type Tb_khsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_khs to aggregate.
     */
    where?: tb_khsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_khs to fetch.
     */
    orderBy?: tb_khsOrderByWithRelationInput | tb_khsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_khsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_khs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_khs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_khs
    **/
    _count?: true | Tb_khsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_khsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_khsMaxAggregateInputType
  }

  export type GetTb_khsAggregateType<T extends Tb_khsAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_khs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_khs[P]>
      : GetScalarType<T[P], AggregateTb_khs[P]>
  }




  export type tb_khsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_khsWhereInput
    orderBy?: tb_khsOrderByWithAggregationInput | tb_khsOrderByWithAggregationInput[]
    by: Tb_khsScalarFieldEnum[] | Tb_khsScalarFieldEnum
    having?: tb_khsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_khsCountAggregateInputType | true
    _min?: Tb_khsMinAggregateInputType
    _max?: Tb_khsMaxAggregateInputType
  }

  export type Tb_khsGroupByOutputType = {
    nim: string
    semester: string
    status: $Enums.StatusAktif
    jumlahSksSemester: string | null
    ips: string | null
    jumlahSksKumulatif: string | null
    ipk: string | null
    fileKhs: string | null
    statusValidasi: boolean
    _count: Tb_khsCountAggregateOutputType | null
    _min: Tb_khsMinAggregateOutputType | null
    _max: Tb_khsMaxAggregateOutputType | null
  }

  type GetTb_khsGroupByPayload<T extends tb_khsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_khsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_khsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_khsGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_khsGroupByOutputType[P]>
        }
      >
    >


  export type tb_khsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nim?: boolean
    semester?: boolean
    status?: boolean
    jumlahSksSemester?: boolean
    ips?: boolean
    jumlahSksKumulatif?: boolean
    ipk?: boolean
    fileKhs?: boolean
    statusValidasi?: boolean
    fk_nim?: boolean | tb_mhsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tb_khs"]>

  export type tb_khsSelectScalar = {
    nim?: boolean
    semester?: boolean
    status?: boolean
    jumlahSksSemester?: boolean
    ips?: boolean
    jumlahSksKumulatif?: boolean
    ipk?: boolean
    fileKhs?: boolean
    statusValidasi?: boolean
  }

  export type tb_khsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fk_nim?: boolean | tb_mhsDefaultArgs<ExtArgs>
  }


  export type $tb_khsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_khs"
    objects: {
      fk_nim: Prisma.$tb_mhsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      nim: string
      semester: string
      status: $Enums.StatusAktif
      jumlahSksSemester: string | null
      ips: string | null
      jumlahSksKumulatif: string | null
      ipk: string | null
      fileKhs: string | null
      statusValidasi: boolean
    }, ExtArgs["result"]["tb_khs"]>
    composites: {}
  }


  type tb_khsGetPayload<S extends boolean | null | undefined | tb_khsDefaultArgs> = $Result.GetResult<Prisma.$tb_khsPayload, S>

  type tb_khsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tb_khsFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Tb_khsCountAggregateInputType | true
    }

  export interface tb_khsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_khs'], meta: { name: 'tb_khs' } }
    /**
     * Find zero or one Tb_khs that matches the filter.
     * @param {tb_khsFindUniqueArgs} args - Arguments to find a Tb_khs
     * @example
     * // Get one Tb_khs
     * const tb_khs = await prisma.tb_khs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tb_khsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tb_khsFindUniqueArgs<ExtArgs>>
    ): Prisma__tb_khsClient<$Result.GetResult<Prisma.$tb_khsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tb_khs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tb_khsFindUniqueOrThrowArgs} args - Arguments to find a Tb_khs
     * @example
     * // Get one Tb_khs
     * const tb_khs = await prisma.tb_khs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tb_khsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_khsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tb_khsClient<$Result.GetResult<Prisma.$tb_khsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tb_khs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_khsFindFirstArgs} args - Arguments to find a Tb_khs
     * @example
     * // Get one Tb_khs
     * const tb_khs = await prisma.tb_khs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tb_khsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_khsFindFirstArgs<ExtArgs>>
    ): Prisma__tb_khsClient<$Result.GetResult<Prisma.$tb_khsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tb_khs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_khsFindFirstOrThrowArgs} args - Arguments to find a Tb_khs
     * @example
     * // Get one Tb_khs
     * const tb_khs = await prisma.tb_khs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tb_khsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_khsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tb_khsClient<$Result.GetResult<Prisma.$tb_khsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tb_khs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_khsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_khs
     * const tb_khs = await prisma.tb_khs.findMany()
     * 
     * // Get first 10 Tb_khs
     * const tb_khs = await prisma.tb_khs.findMany({ take: 10 })
     * 
     * // Only select the `nim`
     * const tb_khsWithNimOnly = await prisma.tb_khs.findMany({ select: { nim: true } })
     * 
    **/
    findMany<T extends tb_khsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_khsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_khsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tb_khs.
     * @param {tb_khsCreateArgs} args - Arguments to create a Tb_khs.
     * @example
     * // Create one Tb_khs
     * const Tb_khs = await prisma.tb_khs.create({
     *   data: {
     *     // ... data to create a Tb_khs
     *   }
     * })
     * 
    **/
    create<T extends tb_khsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_khsCreateArgs<ExtArgs>>
    ): Prisma__tb_khsClient<$Result.GetResult<Prisma.$tb_khsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tb_khs.
     *     @param {tb_khsCreateManyArgs} args - Arguments to create many Tb_khs.
     *     @example
     *     // Create many Tb_khs
     *     const tb_khs = await prisma.tb_khs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tb_khsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_khsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_khs.
     * @param {tb_khsDeleteArgs} args - Arguments to delete one Tb_khs.
     * @example
     * // Delete one Tb_khs
     * const Tb_khs = await prisma.tb_khs.delete({
     *   where: {
     *     // ... filter to delete one Tb_khs
     *   }
     * })
     * 
    **/
    delete<T extends tb_khsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tb_khsDeleteArgs<ExtArgs>>
    ): Prisma__tb_khsClient<$Result.GetResult<Prisma.$tb_khsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tb_khs.
     * @param {tb_khsUpdateArgs} args - Arguments to update one Tb_khs.
     * @example
     * // Update one Tb_khs
     * const tb_khs = await prisma.tb_khs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tb_khsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_khsUpdateArgs<ExtArgs>>
    ): Prisma__tb_khsClient<$Result.GetResult<Prisma.$tb_khsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tb_khs.
     * @param {tb_khsDeleteManyArgs} args - Arguments to filter Tb_khs to delete.
     * @example
     * // Delete a few Tb_khs
     * const { count } = await prisma.tb_khs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tb_khsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_khsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_khs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_khsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_khs
     * const tb_khs = await prisma.tb_khs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tb_khsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tb_khsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_khs.
     * @param {tb_khsUpsertArgs} args - Arguments to update or create a Tb_khs.
     * @example
     * // Update or create a Tb_khs
     * const tb_khs = await prisma.tb_khs.upsert({
     *   create: {
     *     // ... data to create a Tb_khs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_khs we want to update
     *   }
     * })
    **/
    upsert<T extends tb_khsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tb_khsUpsertArgs<ExtArgs>>
    ): Prisma__tb_khsClient<$Result.GetResult<Prisma.$tb_khsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tb_khs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_khsCountArgs} args - Arguments to filter Tb_khs to count.
     * @example
     * // Count the number of Tb_khs
     * const count = await prisma.tb_khs.count({
     *   where: {
     *     // ... the filter for the Tb_khs we want to count
     *   }
     * })
    **/
    count<T extends tb_khsCountArgs>(
      args?: Subset<T, tb_khsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_khsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_khs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_khsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_khsAggregateArgs>(args: Subset<T, Tb_khsAggregateArgs>): Prisma.PrismaPromise<GetTb_khsAggregateType<T>>

    /**
     * Group by Tb_khs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_khsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_khsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_khsGroupByArgs['orderBy'] }
        : { orderBy?: tb_khsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_khsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_khsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_khs model
   */
  readonly fields: tb_khsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_khs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_khsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    fk_nim<T extends tb_mhsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tb_mhsDefaultArgs<ExtArgs>>): Prisma__tb_mhsClient<$Result.GetResult<Prisma.$tb_mhsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tb_khs model
   */ 
  interface tb_khsFieldRefs {
    readonly nim: FieldRef<"tb_khs", 'String'>
    readonly semester: FieldRef<"tb_khs", 'String'>
    readonly status: FieldRef<"tb_khs", 'StatusAktif'>
    readonly jumlahSksSemester: FieldRef<"tb_khs", 'String'>
    readonly ips: FieldRef<"tb_khs", 'String'>
    readonly jumlahSksKumulatif: FieldRef<"tb_khs", 'String'>
    readonly ipk: FieldRef<"tb_khs", 'String'>
    readonly fileKhs: FieldRef<"tb_khs", 'String'>
    readonly statusValidasi: FieldRef<"tb_khs", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * tb_khs findUnique
   */
  export type tb_khsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_khs
     */
    select?: tb_khsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_khsInclude<ExtArgs> | null
    /**
     * Filter, which tb_khs to fetch.
     */
    where: tb_khsWhereUniqueInput
  }


  /**
   * tb_khs findUniqueOrThrow
   */
  export type tb_khsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_khs
     */
    select?: tb_khsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_khsInclude<ExtArgs> | null
    /**
     * Filter, which tb_khs to fetch.
     */
    where: tb_khsWhereUniqueInput
  }


  /**
   * tb_khs findFirst
   */
  export type tb_khsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_khs
     */
    select?: tb_khsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_khsInclude<ExtArgs> | null
    /**
     * Filter, which tb_khs to fetch.
     */
    where?: tb_khsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_khs to fetch.
     */
    orderBy?: tb_khsOrderByWithRelationInput | tb_khsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_khs.
     */
    cursor?: tb_khsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_khs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_khs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_khs.
     */
    distinct?: Tb_khsScalarFieldEnum | Tb_khsScalarFieldEnum[]
  }


  /**
   * tb_khs findFirstOrThrow
   */
  export type tb_khsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_khs
     */
    select?: tb_khsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_khsInclude<ExtArgs> | null
    /**
     * Filter, which tb_khs to fetch.
     */
    where?: tb_khsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_khs to fetch.
     */
    orderBy?: tb_khsOrderByWithRelationInput | tb_khsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_khs.
     */
    cursor?: tb_khsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_khs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_khs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_khs.
     */
    distinct?: Tb_khsScalarFieldEnum | Tb_khsScalarFieldEnum[]
  }


  /**
   * tb_khs findMany
   */
  export type tb_khsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_khs
     */
    select?: tb_khsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_khsInclude<ExtArgs> | null
    /**
     * Filter, which tb_khs to fetch.
     */
    where?: tb_khsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_khs to fetch.
     */
    orderBy?: tb_khsOrderByWithRelationInput | tb_khsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_khs.
     */
    cursor?: tb_khsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_khs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_khs.
     */
    skip?: number
    distinct?: Tb_khsScalarFieldEnum | Tb_khsScalarFieldEnum[]
  }


  /**
   * tb_khs create
   */
  export type tb_khsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_khs
     */
    select?: tb_khsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_khsInclude<ExtArgs> | null
    /**
     * The data needed to create a tb_khs.
     */
    data: XOR<tb_khsCreateInput, tb_khsUncheckedCreateInput>
  }


  /**
   * tb_khs createMany
   */
  export type tb_khsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_khs.
     */
    data: tb_khsCreateManyInput | tb_khsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tb_khs update
   */
  export type tb_khsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_khs
     */
    select?: tb_khsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_khsInclude<ExtArgs> | null
    /**
     * The data needed to update a tb_khs.
     */
    data: XOR<tb_khsUpdateInput, tb_khsUncheckedUpdateInput>
    /**
     * Choose, which tb_khs to update.
     */
    where: tb_khsWhereUniqueInput
  }


  /**
   * tb_khs updateMany
   */
  export type tb_khsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_khs.
     */
    data: XOR<tb_khsUpdateManyMutationInput, tb_khsUncheckedUpdateManyInput>
    /**
     * Filter which tb_khs to update
     */
    where?: tb_khsWhereInput
  }


  /**
   * tb_khs upsert
   */
  export type tb_khsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_khs
     */
    select?: tb_khsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_khsInclude<ExtArgs> | null
    /**
     * The filter to search for the tb_khs to update in case it exists.
     */
    where: tb_khsWhereUniqueInput
    /**
     * In case the tb_khs found by the `where` argument doesn't exist, create a new tb_khs with this data.
     */
    create: XOR<tb_khsCreateInput, tb_khsUncheckedCreateInput>
    /**
     * In case the tb_khs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_khsUpdateInput, tb_khsUncheckedUpdateInput>
  }


  /**
   * tb_khs delete
   */
  export type tb_khsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_khs
     */
    select?: tb_khsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_khsInclude<ExtArgs> | null
    /**
     * Filter which tb_khs to delete.
     */
    where: tb_khsWhereUniqueInput
  }


  /**
   * tb_khs deleteMany
   */
  export type tb_khsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_khs to delete
     */
    where?: tb_khsWhereInput
  }


  /**
   * tb_khs without action
   */
  export type tb_khsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_khs
     */
    select?: tb_khsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_khsInclude<ExtArgs> | null
  }



  /**
   * Model tb_pkl
   */

  export type AggregateTb_pkl = {
    _count: Tb_pklCountAggregateOutputType | null
    _min: Tb_pklMinAggregateOutputType | null
    _max: Tb_pklMaxAggregateOutputType | null
  }

  export type Tb_pklMinAggregateOutputType = {
    nim: string | null
    semester: string | null
    nilai: string | null
    filePkl: string | null
    statusValidasi: boolean | null
  }

  export type Tb_pklMaxAggregateOutputType = {
    nim: string | null
    semester: string | null
    nilai: string | null
    filePkl: string | null
    statusValidasi: boolean | null
  }

  export type Tb_pklCountAggregateOutputType = {
    nim: number
    semester: number
    nilai: number
    filePkl: number
    statusValidasi: number
    _all: number
  }


  export type Tb_pklMinAggregateInputType = {
    nim?: true
    semester?: true
    nilai?: true
    filePkl?: true
    statusValidasi?: true
  }

  export type Tb_pklMaxAggregateInputType = {
    nim?: true
    semester?: true
    nilai?: true
    filePkl?: true
    statusValidasi?: true
  }

  export type Tb_pklCountAggregateInputType = {
    nim?: true
    semester?: true
    nilai?: true
    filePkl?: true
    statusValidasi?: true
    _all?: true
  }

  export type Tb_pklAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_pkl to aggregate.
     */
    where?: tb_pklWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_pkls to fetch.
     */
    orderBy?: tb_pklOrderByWithRelationInput | tb_pklOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_pklWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_pkls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_pkls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_pkls
    **/
    _count?: true | Tb_pklCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_pklMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_pklMaxAggregateInputType
  }

  export type GetTb_pklAggregateType<T extends Tb_pklAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_pkl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_pkl[P]>
      : GetScalarType<T[P], AggregateTb_pkl[P]>
  }




  export type tb_pklGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_pklWhereInput
    orderBy?: tb_pklOrderByWithAggregationInput | tb_pklOrderByWithAggregationInput[]
    by: Tb_pklScalarFieldEnum[] | Tb_pklScalarFieldEnum
    having?: tb_pklScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_pklCountAggregateInputType | true
    _min?: Tb_pklMinAggregateInputType
    _max?: Tb_pklMaxAggregateInputType
  }

  export type Tb_pklGroupByOutputType = {
    nim: string
    semester: string
    nilai: string
    filePkl: string
    statusValidasi: boolean
    _count: Tb_pklCountAggregateOutputType | null
    _min: Tb_pklMinAggregateOutputType | null
    _max: Tb_pklMaxAggregateOutputType | null
  }

  type GetTb_pklGroupByPayload<T extends tb_pklGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_pklGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_pklGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_pklGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_pklGroupByOutputType[P]>
        }
      >
    >


  export type tb_pklSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nim?: boolean
    semester?: boolean
    nilai?: boolean
    filePkl?: boolean
    statusValidasi?: boolean
    fk_nim?: boolean | tb_mhsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tb_pkl"]>

  export type tb_pklSelectScalar = {
    nim?: boolean
    semester?: boolean
    nilai?: boolean
    filePkl?: boolean
    statusValidasi?: boolean
  }

  export type tb_pklInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fk_nim?: boolean | tb_mhsDefaultArgs<ExtArgs>
  }


  export type $tb_pklPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_pkl"
    objects: {
      fk_nim: Prisma.$tb_mhsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      nim: string
      semester: string
      nilai: string
      filePkl: string
      statusValidasi: boolean
    }, ExtArgs["result"]["tb_pkl"]>
    composites: {}
  }


  type tb_pklGetPayload<S extends boolean | null | undefined | tb_pklDefaultArgs> = $Result.GetResult<Prisma.$tb_pklPayload, S>

  type tb_pklCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tb_pklFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Tb_pklCountAggregateInputType | true
    }

  export interface tb_pklDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_pkl'], meta: { name: 'tb_pkl' } }
    /**
     * Find zero or one Tb_pkl that matches the filter.
     * @param {tb_pklFindUniqueArgs} args - Arguments to find a Tb_pkl
     * @example
     * // Get one Tb_pkl
     * const tb_pkl = await prisma.tb_pkl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tb_pklFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tb_pklFindUniqueArgs<ExtArgs>>
    ): Prisma__tb_pklClient<$Result.GetResult<Prisma.$tb_pklPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tb_pkl that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tb_pklFindUniqueOrThrowArgs} args - Arguments to find a Tb_pkl
     * @example
     * // Get one Tb_pkl
     * const tb_pkl = await prisma.tb_pkl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tb_pklFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_pklFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tb_pklClient<$Result.GetResult<Prisma.$tb_pklPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tb_pkl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_pklFindFirstArgs} args - Arguments to find a Tb_pkl
     * @example
     * // Get one Tb_pkl
     * const tb_pkl = await prisma.tb_pkl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tb_pklFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_pklFindFirstArgs<ExtArgs>>
    ): Prisma__tb_pklClient<$Result.GetResult<Prisma.$tb_pklPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tb_pkl that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_pklFindFirstOrThrowArgs} args - Arguments to find a Tb_pkl
     * @example
     * // Get one Tb_pkl
     * const tb_pkl = await prisma.tb_pkl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tb_pklFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_pklFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tb_pklClient<$Result.GetResult<Prisma.$tb_pklPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tb_pkls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_pklFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_pkls
     * const tb_pkls = await prisma.tb_pkl.findMany()
     * 
     * // Get first 10 Tb_pkls
     * const tb_pkls = await prisma.tb_pkl.findMany({ take: 10 })
     * 
     * // Only select the `nim`
     * const tb_pklWithNimOnly = await prisma.tb_pkl.findMany({ select: { nim: true } })
     * 
    **/
    findMany<T extends tb_pklFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_pklFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_pklPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tb_pkl.
     * @param {tb_pklCreateArgs} args - Arguments to create a Tb_pkl.
     * @example
     * // Create one Tb_pkl
     * const Tb_pkl = await prisma.tb_pkl.create({
     *   data: {
     *     // ... data to create a Tb_pkl
     *   }
     * })
     * 
    **/
    create<T extends tb_pklCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_pklCreateArgs<ExtArgs>>
    ): Prisma__tb_pklClient<$Result.GetResult<Prisma.$tb_pklPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tb_pkls.
     *     @param {tb_pklCreateManyArgs} args - Arguments to create many Tb_pkls.
     *     @example
     *     // Create many Tb_pkls
     *     const tb_pkl = await prisma.tb_pkl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tb_pklCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_pklCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_pkl.
     * @param {tb_pklDeleteArgs} args - Arguments to delete one Tb_pkl.
     * @example
     * // Delete one Tb_pkl
     * const Tb_pkl = await prisma.tb_pkl.delete({
     *   where: {
     *     // ... filter to delete one Tb_pkl
     *   }
     * })
     * 
    **/
    delete<T extends tb_pklDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tb_pklDeleteArgs<ExtArgs>>
    ): Prisma__tb_pklClient<$Result.GetResult<Prisma.$tb_pklPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tb_pkl.
     * @param {tb_pklUpdateArgs} args - Arguments to update one Tb_pkl.
     * @example
     * // Update one Tb_pkl
     * const tb_pkl = await prisma.tb_pkl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tb_pklUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_pklUpdateArgs<ExtArgs>>
    ): Prisma__tb_pklClient<$Result.GetResult<Prisma.$tb_pklPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tb_pkls.
     * @param {tb_pklDeleteManyArgs} args - Arguments to filter Tb_pkls to delete.
     * @example
     * // Delete a few Tb_pkls
     * const { count } = await prisma.tb_pkl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tb_pklDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_pklDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_pkls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_pklUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_pkls
     * const tb_pkl = await prisma.tb_pkl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tb_pklUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tb_pklUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_pkl.
     * @param {tb_pklUpsertArgs} args - Arguments to update or create a Tb_pkl.
     * @example
     * // Update or create a Tb_pkl
     * const tb_pkl = await prisma.tb_pkl.upsert({
     *   create: {
     *     // ... data to create a Tb_pkl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_pkl we want to update
     *   }
     * })
    **/
    upsert<T extends tb_pklUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tb_pklUpsertArgs<ExtArgs>>
    ): Prisma__tb_pklClient<$Result.GetResult<Prisma.$tb_pklPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tb_pkls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_pklCountArgs} args - Arguments to filter Tb_pkls to count.
     * @example
     * // Count the number of Tb_pkls
     * const count = await prisma.tb_pkl.count({
     *   where: {
     *     // ... the filter for the Tb_pkls we want to count
     *   }
     * })
    **/
    count<T extends tb_pklCountArgs>(
      args?: Subset<T, tb_pklCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_pklCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_pkl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_pklAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_pklAggregateArgs>(args: Subset<T, Tb_pklAggregateArgs>): Prisma.PrismaPromise<GetTb_pklAggregateType<T>>

    /**
     * Group by Tb_pkl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_pklGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_pklGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_pklGroupByArgs['orderBy'] }
        : { orderBy?: tb_pklGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_pklGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_pklGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_pkl model
   */
  readonly fields: tb_pklFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_pkl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_pklClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    fk_nim<T extends tb_mhsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tb_mhsDefaultArgs<ExtArgs>>): Prisma__tb_mhsClient<$Result.GetResult<Prisma.$tb_mhsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tb_pkl model
   */ 
  interface tb_pklFieldRefs {
    readonly nim: FieldRef<"tb_pkl", 'String'>
    readonly semester: FieldRef<"tb_pkl", 'String'>
    readonly nilai: FieldRef<"tb_pkl", 'String'>
    readonly filePkl: FieldRef<"tb_pkl", 'String'>
    readonly statusValidasi: FieldRef<"tb_pkl", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * tb_pkl findUnique
   */
  export type tb_pklFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_pkl
     */
    select?: tb_pklSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_pklInclude<ExtArgs> | null
    /**
     * Filter, which tb_pkl to fetch.
     */
    where: tb_pklWhereUniqueInput
  }


  /**
   * tb_pkl findUniqueOrThrow
   */
  export type tb_pklFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_pkl
     */
    select?: tb_pklSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_pklInclude<ExtArgs> | null
    /**
     * Filter, which tb_pkl to fetch.
     */
    where: tb_pklWhereUniqueInput
  }


  /**
   * tb_pkl findFirst
   */
  export type tb_pklFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_pkl
     */
    select?: tb_pklSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_pklInclude<ExtArgs> | null
    /**
     * Filter, which tb_pkl to fetch.
     */
    where?: tb_pklWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_pkls to fetch.
     */
    orderBy?: tb_pklOrderByWithRelationInput | tb_pklOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_pkls.
     */
    cursor?: tb_pklWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_pkls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_pkls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_pkls.
     */
    distinct?: Tb_pklScalarFieldEnum | Tb_pklScalarFieldEnum[]
  }


  /**
   * tb_pkl findFirstOrThrow
   */
  export type tb_pklFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_pkl
     */
    select?: tb_pklSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_pklInclude<ExtArgs> | null
    /**
     * Filter, which tb_pkl to fetch.
     */
    where?: tb_pklWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_pkls to fetch.
     */
    orderBy?: tb_pklOrderByWithRelationInput | tb_pklOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_pkls.
     */
    cursor?: tb_pklWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_pkls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_pkls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_pkls.
     */
    distinct?: Tb_pklScalarFieldEnum | Tb_pklScalarFieldEnum[]
  }


  /**
   * tb_pkl findMany
   */
  export type tb_pklFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_pkl
     */
    select?: tb_pklSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_pklInclude<ExtArgs> | null
    /**
     * Filter, which tb_pkls to fetch.
     */
    where?: tb_pklWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_pkls to fetch.
     */
    orderBy?: tb_pklOrderByWithRelationInput | tb_pklOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_pkls.
     */
    cursor?: tb_pklWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_pkls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_pkls.
     */
    skip?: number
    distinct?: Tb_pklScalarFieldEnum | Tb_pklScalarFieldEnum[]
  }


  /**
   * tb_pkl create
   */
  export type tb_pklCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_pkl
     */
    select?: tb_pklSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_pklInclude<ExtArgs> | null
    /**
     * The data needed to create a tb_pkl.
     */
    data: XOR<tb_pklCreateInput, tb_pklUncheckedCreateInput>
  }


  /**
   * tb_pkl createMany
   */
  export type tb_pklCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_pkls.
     */
    data: tb_pklCreateManyInput | tb_pklCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tb_pkl update
   */
  export type tb_pklUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_pkl
     */
    select?: tb_pklSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_pklInclude<ExtArgs> | null
    /**
     * The data needed to update a tb_pkl.
     */
    data: XOR<tb_pklUpdateInput, tb_pklUncheckedUpdateInput>
    /**
     * Choose, which tb_pkl to update.
     */
    where: tb_pklWhereUniqueInput
  }


  /**
   * tb_pkl updateMany
   */
  export type tb_pklUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_pkls.
     */
    data: XOR<tb_pklUpdateManyMutationInput, tb_pklUncheckedUpdateManyInput>
    /**
     * Filter which tb_pkls to update
     */
    where?: tb_pklWhereInput
  }


  /**
   * tb_pkl upsert
   */
  export type tb_pklUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_pkl
     */
    select?: tb_pklSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_pklInclude<ExtArgs> | null
    /**
     * The filter to search for the tb_pkl to update in case it exists.
     */
    where: tb_pklWhereUniqueInput
    /**
     * In case the tb_pkl found by the `where` argument doesn't exist, create a new tb_pkl with this data.
     */
    create: XOR<tb_pklCreateInput, tb_pklUncheckedCreateInput>
    /**
     * In case the tb_pkl was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_pklUpdateInput, tb_pklUncheckedUpdateInput>
  }


  /**
   * tb_pkl delete
   */
  export type tb_pklDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_pkl
     */
    select?: tb_pklSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_pklInclude<ExtArgs> | null
    /**
     * Filter which tb_pkl to delete.
     */
    where: tb_pklWhereUniqueInput
  }


  /**
   * tb_pkl deleteMany
   */
  export type tb_pklDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_pkls to delete
     */
    where?: tb_pklWhereInput
  }


  /**
   * tb_pkl without action
   */
  export type tb_pklDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_pkl
     */
    select?: tb_pklSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_pklInclude<ExtArgs> | null
  }



  /**
   * Model tb_skripsi
   */

  export type AggregateTb_skripsi = {
    _count: Tb_skripsiCountAggregateOutputType | null
    _avg: Tb_skripsiAvgAggregateOutputType | null
    _sum: Tb_skripsiSumAggregateOutputType | null
    _min: Tb_skripsiMinAggregateOutputType | null
    _max: Tb_skripsiMaxAggregateOutputType | null
  }

  export type Tb_skripsiAvgAggregateOutputType = {
    lamaStudi: number | null
  }

  export type Tb_skripsiSumAggregateOutputType = {
    lamaStudi: number | null
  }

  export type Tb_skripsiMinAggregateOutputType = {
    nim: string | null
    semester: string | null
    nilai: string | null
    tanggalLulusSidang: Date | null
    lamaStudi: number | null
    fileSkripsi: string | null
    statusValidasi: boolean | null
  }

  export type Tb_skripsiMaxAggregateOutputType = {
    nim: string | null
    semester: string | null
    nilai: string | null
    tanggalLulusSidang: Date | null
    lamaStudi: number | null
    fileSkripsi: string | null
    statusValidasi: boolean | null
  }

  export type Tb_skripsiCountAggregateOutputType = {
    nim: number
    semester: number
    nilai: number
    tanggalLulusSidang: number
    lamaStudi: number
    fileSkripsi: number
    statusValidasi: number
    _all: number
  }


  export type Tb_skripsiAvgAggregateInputType = {
    lamaStudi?: true
  }

  export type Tb_skripsiSumAggregateInputType = {
    lamaStudi?: true
  }

  export type Tb_skripsiMinAggregateInputType = {
    nim?: true
    semester?: true
    nilai?: true
    tanggalLulusSidang?: true
    lamaStudi?: true
    fileSkripsi?: true
    statusValidasi?: true
  }

  export type Tb_skripsiMaxAggregateInputType = {
    nim?: true
    semester?: true
    nilai?: true
    tanggalLulusSidang?: true
    lamaStudi?: true
    fileSkripsi?: true
    statusValidasi?: true
  }

  export type Tb_skripsiCountAggregateInputType = {
    nim?: true
    semester?: true
    nilai?: true
    tanggalLulusSidang?: true
    lamaStudi?: true
    fileSkripsi?: true
    statusValidasi?: true
    _all?: true
  }

  export type Tb_skripsiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_skripsi to aggregate.
     */
    where?: tb_skripsiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_skripsis to fetch.
     */
    orderBy?: tb_skripsiOrderByWithRelationInput | tb_skripsiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_skripsiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_skripsis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_skripsis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_skripsis
    **/
    _count?: true | Tb_skripsiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_skripsiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_skripsiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_skripsiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_skripsiMaxAggregateInputType
  }

  export type GetTb_skripsiAggregateType<T extends Tb_skripsiAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_skripsi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_skripsi[P]>
      : GetScalarType<T[P], AggregateTb_skripsi[P]>
  }




  export type tb_skripsiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_skripsiWhereInput
    orderBy?: tb_skripsiOrderByWithAggregationInput | tb_skripsiOrderByWithAggregationInput[]
    by: Tb_skripsiScalarFieldEnum[] | Tb_skripsiScalarFieldEnum
    having?: tb_skripsiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_skripsiCountAggregateInputType | true
    _avg?: Tb_skripsiAvgAggregateInputType
    _sum?: Tb_skripsiSumAggregateInputType
    _min?: Tb_skripsiMinAggregateInputType
    _max?: Tb_skripsiMaxAggregateInputType
  }

  export type Tb_skripsiGroupByOutputType = {
    nim: string
    semester: string
    nilai: string
    tanggalLulusSidang: Date
    lamaStudi: number
    fileSkripsi: string
    statusValidasi: boolean
    _count: Tb_skripsiCountAggregateOutputType | null
    _avg: Tb_skripsiAvgAggregateOutputType | null
    _sum: Tb_skripsiSumAggregateOutputType | null
    _min: Tb_skripsiMinAggregateOutputType | null
    _max: Tb_skripsiMaxAggregateOutputType | null
  }

  type GetTb_skripsiGroupByPayload<T extends tb_skripsiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_skripsiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_skripsiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_skripsiGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_skripsiGroupByOutputType[P]>
        }
      >
    >


  export type tb_skripsiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nim?: boolean
    semester?: boolean
    nilai?: boolean
    tanggalLulusSidang?: boolean
    lamaStudi?: boolean
    fileSkripsi?: boolean
    statusValidasi?: boolean
    fk_nim?: boolean | tb_mhsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tb_skripsi"]>

  export type tb_skripsiSelectScalar = {
    nim?: boolean
    semester?: boolean
    nilai?: boolean
    tanggalLulusSidang?: boolean
    lamaStudi?: boolean
    fileSkripsi?: boolean
    statusValidasi?: boolean
  }

  export type tb_skripsiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fk_nim?: boolean | tb_mhsDefaultArgs<ExtArgs>
  }


  export type $tb_skripsiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_skripsi"
    objects: {
      fk_nim: Prisma.$tb_mhsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      nim: string
      semester: string
      nilai: string
      tanggalLulusSidang: Date
      lamaStudi: number
      fileSkripsi: string
      statusValidasi: boolean
    }, ExtArgs["result"]["tb_skripsi"]>
    composites: {}
  }


  type tb_skripsiGetPayload<S extends boolean | null | undefined | tb_skripsiDefaultArgs> = $Result.GetResult<Prisma.$tb_skripsiPayload, S>

  type tb_skripsiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tb_skripsiFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Tb_skripsiCountAggregateInputType | true
    }

  export interface tb_skripsiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_skripsi'], meta: { name: 'tb_skripsi' } }
    /**
     * Find zero or one Tb_skripsi that matches the filter.
     * @param {tb_skripsiFindUniqueArgs} args - Arguments to find a Tb_skripsi
     * @example
     * // Get one Tb_skripsi
     * const tb_skripsi = await prisma.tb_skripsi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tb_skripsiFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tb_skripsiFindUniqueArgs<ExtArgs>>
    ): Prisma__tb_skripsiClient<$Result.GetResult<Prisma.$tb_skripsiPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tb_skripsi that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tb_skripsiFindUniqueOrThrowArgs} args - Arguments to find a Tb_skripsi
     * @example
     * // Get one Tb_skripsi
     * const tb_skripsi = await prisma.tb_skripsi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tb_skripsiFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_skripsiFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tb_skripsiClient<$Result.GetResult<Prisma.$tb_skripsiPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tb_skripsi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_skripsiFindFirstArgs} args - Arguments to find a Tb_skripsi
     * @example
     * // Get one Tb_skripsi
     * const tb_skripsi = await prisma.tb_skripsi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tb_skripsiFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_skripsiFindFirstArgs<ExtArgs>>
    ): Prisma__tb_skripsiClient<$Result.GetResult<Prisma.$tb_skripsiPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tb_skripsi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_skripsiFindFirstOrThrowArgs} args - Arguments to find a Tb_skripsi
     * @example
     * // Get one Tb_skripsi
     * const tb_skripsi = await prisma.tb_skripsi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tb_skripsiFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_skripsiFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tb_skripsiClient<$Result.GetResult<Prisma.$tb_skripsiPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tb_skripsis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_skripsiFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_skripsis
     * const tb_skripsis = await prisma.tb_skripsi.findMany()
     * 
     * // Get first 10 Tb_skripsis
     * const tb_skripsis = await prisma.tb_skripsi.findMany({ take: 10 })
     * 
     * // Only select the `nim`
     * const tb_skripsiWithNimOnly = await prisma.tb_skripsi.findMany({ select: { nim: true } })
     * 
    **/
    findMany<T extends tb_skripsiFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_skripsiFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_skripsiPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tb_skripsi.
     * @param {tb_skripsiCreateArgs} args - Arguments to create a Tb_skripsi.
     * @example
     * // Create one Tb_skripsi
     * const Tb_skripsi = await prisma.tb_skripsi.create({
     *   data: {
     *     // ... data to create a Tb_skripsi
     *   }
     * })
     * 
    **/
    create<T extends tb_skripsiCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_skripsiCreateArgs<ExtArgs>>
    ): Prisma__tb_skripsiClient<$Result.GetResult<Prisma.$tb_skripsiPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tb_skripsis.
     *     @param {tb_skripsiCreateManyArgs} args - Arguments to create many Tb_skripsis.
     *     @example
     *     // Create many Tb_skripsis
     *     const tb_skripsi = await prisma.tb_skripsi.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tb_skripsiCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_skripsiCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_skripsi.
     * @param {tb_skripsiDeleteArgs} args - Arguments to delete one Tb_skripsi.
     * @example
     * // Delete one Tb_skripsi
     * const Tb_skripsi = await prisma.tb_skripsi.delete({
     *   where: {
     *     // ... filter to delete one Tb_skripsi
     *   }
     * })
     * 
    **/
    delete<T extends tb_skripsiDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tb_skripsiDeleteArgs<ExtArgs>>
    ): Prisma__tb_skripsiClient<$Result.GetResult<Prisma.$tb_skripsiPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tb_skripsi.
     * @param {tb_skripsiUpdateArgs} args - Arguments to update one Tb_skripsi.
     * @example
     * // Update one Tb_skripsi
     * const tb_skripsi = await prisma.tb_skripsi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tb_skripsiUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_skripsiUpdateArgs<ExtArgs>>
    ): Prisma__tb_skripsiClient<$Result.GetResult<Prisma.$tb_skripsiPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tb_skripsis.
     * @param {tb_skripsiDeleteManyArgs} args - Arguments to filter Tb_skripsis to delete.
     * @example
     * // Delete a few Tb_skripsis
     * const { count } = await prisma.tb_skripsi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tb_skripsiDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_skripsiDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_skripsis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_skripsiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_skripsis
     * const tb_skripsi = await prisma.tb_skripsi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tb_skripsiUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tb_skripsiUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_skripsi.
     * @param {tb_skripsiUpsertArgs} args - Arguments to update or create a Tb_skripsi.
     * @example
     * // Update or create a Tb_skripsi
     * const tb_skripsi = await prisma.tb_skripsi.upsert({
     *   create: {
     *     // ... data to create a Tb_skripsi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_skripsi we want to update
     *   }
     * })
    **/
    upsert<T extends tb_skripsiUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tb_skripsiUpsertArgs<ExtArgs>>
    ): Prisma__tb_skripsiClient<$Result.GetResult<Prisma.$tb_skripsiPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tb_skripsis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_skripsiCountArgs} args - Arguments to filter Tb_skripsis to count.
     * @example
     * // Count the number of Tb_skripsis
     * const count = await prisma.tb_skripsi.count({
     *   where: {
     *     // ... the filter for the Tb_skripsis we want to count
     *   }
     * })
    **/
    count<T extends tb_skripsiCountArgs>(
      args?: Subset<T, tb_skripsiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_skripsiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_skripsi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_skripsiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_skripsiAggregateArgs>(args: Subset<T, Tb_skripsiAggregateArgs>): Prisma.PrismaPromise<GetTb_skripsiAggregateType<T>>

    /**
     * Group by Tb_skripsi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_skripsiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_skripsiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_skripsiGroupByArgs['orderBy'] }
        : { orderBy?: tb_skripsiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_skripsiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_skripsiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_skripsi model
   */
  readonly fields: tb_skripsiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_skripsi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_skripsiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    fk_nim<T extends tb_mhsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tb_mhsDefaultArgs<ExtArgs>>): Prisma__tb_mhsClient<$Result.GetResult<Prisma.$tb_mhsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tb_skripsi model
   */ 
  interface tb_skripsiFieldRefs {
    readonly nim: FieldRef<"tb_skripsi", 'String'>
    readonly semester: FieldRef<"tb_skripsi", 'String'>
    readonly nilai: FieldRef<"tb_skripsi", 'String'>
    readonly tanggalLulusSidang: FieldRef<"tb_skripsi", 'DateTime'>
    readonly lamaStudi: FieldRef<"tb_skripsi", 'Int'>
    readonly fileSkripsi: FieldRef<"tb_skripsi", 'String'>
    readonly statusValidasi: FieldRef<"tb_skripsi", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * tb_skripsi findUnique
   */
  export type tb_skripsiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_skripsi
     */
    select?: tb_skripsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_skripsiInclude<ExtArgs> | null
    /**
     * Filter, which tb_skripsi to fetch.
     */
    where: tb_skripsiWhereUniqueInput
  }


  /**
   * tb_skripsi findUniqueOrThrow
   */
  export type tb_skripsiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_skripsi
     */
    select?: tb_skripsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_skripsiInclude<ExtArgs> | null
    /**
     * Filter, which tb_skripsi to fetch.
     */
    where: tb_skripsiWhereUniqueInput
  }


  /**
   * tb_skripsi findFirst
   */
  export type tb_skripsiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_skripsi
     */
    select?: tb_skripsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_skripsiInclude<ExtArgs> | null
    /**
     * Filter, which tb_skripsi to fetch.
     */
    where?: tb_skripsiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_skripsis to fetch.
     */
    orderBy?: tb_skripsiOrderByWithRelationInput | tb_skripsiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_skripsis.
     */
    cursor?: tb_skripsiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_skripsis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_skripsis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_skripsis.
     */
    distinct?: Tb_skripsiScalarFieldEnum | Tb_skripsiScalarFieldEnum[]
  }


  /**
   * tb_skripsi findFirstOrThrow
   */
  export type tb_skripsiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_skripsi
     */
    select?: tb_skripsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_skripsiInclude<ExtArgs> | null
    /**
     * Filter, which tb_skripsi to fetch.
     */
    where?: tb_skripsiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_skripsis to fetch.
     */
    orderBy?: tb_skripsiOrderByWithRelationInput | tb_skripsiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_skripsis.
     */
    cursor?: tb_skripsiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_skripsis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_skripsis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_skripsis.
     */
    distinct?: Tb_skripsiScalarFieldEnum | Tb_skripsiScalarFieldEnum[]
  }


  /**
   * tb_skripsi findMany
   */
  export type tb_skripsiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_skripsi
     */
    select?: tb_skripsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_skripsiInclude<ExtArgs> | null
    /**
     * Filter, which tb_skripsis to fetch.
     */
    where?: tb_skripsiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_skripsis to fetch.
     */
    orderBy?: tb_skripsiOrderByWithRelationInput | tb_skripsiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_skripsis.
     */
    cursor?: tb_skripsiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_skripsis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_skripsis.
     */
    skip?: number
    distinct?: Tb_skripsiScalarFieldEnum | Tb_skripsiScalarFieldEnum[]
  }


  /**
   * tb_skripsi create
   */
  export type tb_skripsiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_skripsi
     */
    select?: tb_skripsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_skripsiInclude<ExtArgs> | null
    /**
     * The data needed to create a tb_skripsi.
     */
    data: XOR<tb_skripsiCreateInput, tb_skripsiUncheckedCreateInput>
  }


  /**
   * tb_skripsi createMany
   */
  export type tb_skripsiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_skripsis.
     */
    data: tb_skripsiCreateManyInput | tb_skripsiCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tb_skripsi update
   */
  export type tb_skripsiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_skripsi
     */
    select?: tb_skripsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_skripsiInclude<ExtArgs> | null
    /**
     * The data needed to update a tb_skripsi.
     */
    data: XOR<tb_skripsiUpdateInput, tb_skripsiUncheckedUpdateInput>
    /**
     * Choose, which tb_skripsi to update.
     */
    where: tb_skripsiWhereUniqueInput
  }


  /**
   * tb_skripsi updateMany
   */
  export type tb_skripsiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_skripsis.
     */
    data: XOR<tb_skripsiUpdateManyMutationInput, tb_skripsiUncheckedUpdateManyInput>
    /**
     * Filter which tb_skripsis to update
     */
    where?: tb_skripsiWhereInput
  }


  /**
   * tb_skripsi upsert
   */
  export type tb_skripsiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_skripsi
     */
    select?: tb_skripsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_skripsiInclude<ExtArgs> | null
    /**
     * The filter to search for the tb_skripsi to update in case it exists.
     */
    where: tb_skripsiWhereUniqueInput
    /**
     * In case the tb_skripsi found by the `where` argument doesn't exist, create a new tb_skripsi with this data.
     */
    create: XOR<tb_skripsiCreateInput, tb_skripsiUncheckedCreateInput>
    /**
     * In case the tb_skripsi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_skripsiUpdateInput, tb_skripsiUncheckedUpdateInput>
  }


  /**
   * tb_skripsi delete
   */
  export type tb_skripsiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_skripsi
     */
    select?: tb_skripsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_skripsiInclude<ExtArgs> | null
    /**
     * Filter which tb_skripsi to delete.
     */
    where: tb_skripsiWhereUniqueInput
  }


  /**
   * tb_skripsi deleteMany
   */
  export type tb_skripsiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_skripsis to delete
     */
    where?: tb_skripsiWhereInput
  }


  /**
   * tb_skripsi without action
   */
  export type tb_skripsiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_skripsi
     */
    select?: tb_skripsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_skripsiInclude<ExtArgs> | null
  }



  /**
   * Model tb_provinsi
   */

  export type AggregateTb_provinsi = {
    _count: Tb_provinsiCountAggregateOutputType | null
    _min: Tb_provinsiMinAggregateOutputType | null
    _max: Tb_provinsiMaxAggregateOutputType | null
  }

  export type Tb_provinsiMinAggregateOutputType = {
    kodeProv: string | null
    namaProv: string | null
  }

  export type Tb_provinsiMaxAggregateOutputType = {
    kodeProv: string | null
    namaProv: string | null
  }

  export type Tb_provinsiCountAggregateOutputType = {
    kodeProv: number
    namaProv: number
    _all: number
  }


  export type Tb_provinsiMinAggregateInputType = {
    kodeProv?: true
    namaProv?: true
  }

  export type Tb_provinsiMaxAggregateInputType = {
    kodeProv?: true
    namaProv?: true
  }

  export type Tb_provinsiCountAggregateInputType = {
    kodeProv?: true
    namaProv?: true
    _all?: true
  }

  export type Tb_provinsiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_provinsi to aggregate.
     */
    where?: tb_provinsiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_provinsis to fetch.
     */
    orderBy?: tb_provinsiOrderByWithRelationInput | tb_provinsiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_provinsiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_provinsis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_provinsis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_provinsis
    **/
    _count?: true | Tb_provinsiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_provinsiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_provinsiMaxAggregateInputType
  }

  export type GetTb_provinsiAggregateType<T extends Tb_provinsiAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_provinsi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_provinsi[P]>
      : GetScalarType<T[P], AggregateTb_provinsi[P]>
  }




  export type tb_provinsiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_provinsiWhereInput
    orderBy?: tb_provinsiOrderByWithAggregationInput | tb_provinsiOrderByWithAggregationInput[]
    by: Tb_provinsiScalarFieldEnum[] | Tb_provinsiScalarFieldEnum
    having?: tb_provinsiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_provinsiCountAggregateInputType | true
    _min?: Tb_provinsiMinAggregateInputType
    _max?: Tb_provinsiMaxAggregateInputType
  }

  export type Tb_provinsiGroupByOutputType = {
    kodeProv: string
    namaProv: string
    _count: Tb_provinsiCountAggregateOutputType | null
    _min: Tb_provinsiMinAggregateOutputType | null
    _max: Tb_provinsiMaxAggregateOutputType | null
  }

  type GetTb_provinsiGroupByPayload<T extends tb_provinsiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_provinsiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_provinsiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_provinsiGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_provinsiGroupByOutputType[P]>
        }
      >
    >


  export type tb_provinsiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    kodeProv?: boolean
    namaProv?: boolean
    fk_kodeProv_mhs?: boolean | tb_provinsi$fk_kodeProv_mhsArgs<ExtArgs>
    fk_kodeProv_dosen?: boolean | tb_provinsi$fk_kodeProv_dosenArgs<ExtArgs>
    fk_kodeProv_kabupaten?: boolean | tb_provinsi$fk_kodeProv_kabupatenArgs<ExtArgs>
    _count?: boolean | Tb_provinsiCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tb_provinsi"]>

  export type tb_provinsiSelectScalar = {
    kodeProv?: boolean
    namaProv?: boolean
  }

  export type tb_provinsiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fk_kodeProv_mhs?: boolean | tb_provinsi$fk_kodeProv_mhsArgs<ExtArgs>
    fk_kodeProv_dosen?: boolean | tb_provinsi$fk_kodeProv_dosenArgs<ExtArgs>
    fk_kodeProv_kabupaten?: boolean | tb_provinsi$fk_kodeProv_kabupatenArgs<ExtArgs>
    _count?: boolean | Tb_provinsiCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $tb_provinsiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_provinsi"
    objects: {
      fk_kodeProv_mhs: Prisma.$tb_mhsPayload<ExtArgs>[]
      fk_kodeProv_dosen: Prisma.$tb_dosenPayload<ExtArgs>[]
      fk_kodeProv_kabupaten: Prisma.$tb_kabupatenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      kodeProv: string
      namaProv: string
    }, ExtArgs["result"]["tb_provinsi"]>
    composites: {}
  }


  type tb_provinsiGetPayload<S extends boolean | null | undefined | tb_provinsiDefaultArgs> = $Result.GetResult<Prisma.$tb_provinsiPayload, S>

  type tb_provinsiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tb_provinsiFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Tb_provinsiCountAggregateInputType | true
    }

  export interface tb_provinsiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_provinsi'], meta: { name: 'tb_provinsi' } }
    /**
     * Find zero or one Tb_provinsi that matches the filter.
     * @param {tb_provinsiFindUniqueArgs} args - Arguments to find a Tb_provinsi
     * @example
     * // Get one Tb_provinsi
     * const tb_provinsi = await prisma.tb_provinsi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tb_provinsiFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tb_provinsiFindUniqueArgs<ExtArgs>>
    ): Prisma__tb_provinsiClient<$Result.GetResult<Prisma.$tb_provinsiPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tb_provinsi that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tb_provinsiFindUniqueOrThrowArgs} args - Arguments to find a Tb_provinsi
     * @example
     * // Get one Tb_provinsi
     * const tb_provinsi = await prisma.tb_provinsi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tb_provinsiFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_provinsiFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tb_provinsiClient<$Result.GetResult<Prisma.$tb_provinsiPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tb_provinsi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_provinsiFindFirstArgs} args - Arguments to find a Tb_provinsi
     * @example
     * // Get one Tb_provinsi
     * const tb_provinsi = await prisma.tb_provinsi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tb_provinsiFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_provinsiFindFirstArgs<ExtArgs>>
    ): Prisma__tb_provinsiClient<$Result.GetResult<Prisma.$tb_provinsiPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tb_provinsi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_provinsiFindFirstOrThrowArgs} args - Arguments to find a Tb_provinsi
     * @example
     * // Get one Tb_provinsi
     * const tb_provinsi = await prisma.tb_provinsi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tb_provinsiFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_provinsiFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tb_provinsiClient<$Result.GetResult<Prisma.$tb_provinsiPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tb_provinsis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_provinsiFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_provinsis
     * const tb_provinsis = await prisma.tb_provinsi.findMany()
     * 
     * // Get first 10 Tb_provinsis
     * const tb_provinsis = await prisma.tb_provinsi.findMany({ take: 10 })
     * 
     * // Only select the `kodeProv`
     * const tb_provinsiWithKodeProvOnly = await prisma.tb_provinsi.findMany({ select: { kodeProv: true } })
     * 
    **/
    findMany<T extends tb_provinsiFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_provinsiFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_provinsiPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tb_provinsi.
     * @param {tb_provinsiCreateArgs} args - Arguments to create a Tb_provinsi.
     * @example
     * // Create one Tb_provinsi
     * const Tb_provinsi = await prisma.tb_provinsi.create({
     *   data: {
     *     // ... data to create a Tb_provinsi
     *   }
     * })
     * 
    **/
    create<T extends tb_provinsiCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_provinsiCreateArgs<ExtArgs>>
    ): Prisma__tb_provinsiClient<$Result.GetResult<Prisma.$tb_provinsiPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tb_provinsis.
     *     @param {tb_provinsiCreateManyArgs} args - Arguments to create many Tb_provinsis.
     *     @example
     *     // Create many Tb_provinsis
     *     const tb_provinsi = await prisma.tb_provinsi.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tb_provinsiCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_provinsiCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_provinsi.
     * @param {tb_provinsiDeleteArgs} args - Arguments to delete one Tb_provinsi.
     * @example
     * // Delete one Tb_provinsi
     * const Tb_provinsi = await prisma.tb_provinsi.delete({
     *   where: {
     *     // ... filter to delete one Tb_provinsi
     *   }
     * })
     * 
    **/
    delete<T extends tb_provinsiDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tb_provinsiDeleteArgs<ExtArgs>>
    ): Prisma__tb_provinsiClient<$Result.GetResult<Prisma.$tb_provinsiPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tb_provinsi.
     * @param {tb_provinsiUpdateArgs} args - Arguments to update one Tb_provinsi.
     * @example
     * // Update one Tb_provinsi
     * const tb_provinsi = await prisma.tb_provinsi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tb_provinsiUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_provinsiUpdateArgs<ExtArgs>>
    ): Prisma__tb_provinsiClient<$Result.GetResult<Prisma.$tb_provinsiPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tb_provinsis.
     * @param {tb_provinsiDeleteManyArgs} args - Arguments to filter Tb_provinsis to delete.
     * @example
     * // Delete a few Tb_provinsis
     * const { count } = await prisma.tb_provinsi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tb_provinsiDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_provinsiDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_provinsis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_provinsiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_provinsis
     * const tb_provinsi = await prisma.tb_provinsi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tb_provinsiUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tb_provinsiUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_provinsi.
     * @param {tb_provinsiUpsertArgs} args - Arguments to update or create a Tb_provinsi.
     * @example
     * // Update or create a Tb_provinsi
     * const tb_provinsi = await prisma.tb_provinsi.upsert({
     *   create: {
     *     // ... data to create a Tb_provinsi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_provinsi we want to update
     *   }
     * })
    **/
    upsert<T extends tb_provinsiUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tb_provinsiUpsertArgs<ExtArgs>>
    ): Prisma__tb_provinsiClient<$Result.GetResult<Prisma.$tb_provinsiPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tb_provinsis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_provinsiCountArgs} args - Arguments to filter Tb_provinsis to count.
     * @example
     * // Count the number of Tb_provinsis
     * const count = await prisma.tb_provinsi.count({
     *   where: {
     *     // ... the filter for the Tb_provinsis we want to count
     *   }
     * })
    **/
    count<T extends tb_provinsiCountArgs>(
      args?: Subset<T, tb_provinsiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_provinsiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_provinsi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_provinsiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_provinsiAggregateArgs>(args: Subset<T, Tb_provinsiAggregateArgs>): Prisma.PrismaPromise<GetTb_provinsiAggregateType<T>>

    /**
     * Group by Tb_provinsi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_provinsiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_provinsiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_provinsiGroupByArgs['orderBy'] }
        : { orderBy?: tb_provinsiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_provinsiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_provinsiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_provinsi model
   */
  readonly fields: tb_provinsiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_provinsi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_provinsiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    fk_kodeProv_mhs<T extends tb_provinsi$fk_kodeProv_mhsArgs<ExtArgs> = {}>(args?: Subset<T, tb_provinsi$fk_kodeProv_mhsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_mhsPayload<ExtArgs>, T, 'findMany'> | Null>;

    fk_kodeProv_dosen<T extends tb_provinsi$fk_kodeProv_dosenArgs<ExtArgs> = {}>(args?: Subset<T, tb_provinsi$fk_kodeProv_dosenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_dosenPayload<ExtArgs>, T, 'findMany'> | Null>;

    fk_kodeProv_kabupaten<T extends tb_provinsi$fk_kodeProv_kabupatenArgs<ExtArgs> = {}>(args?: Subset<T, tb_provinsi$fk_kodeProv_kabupatenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_kabupatenPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tb_provinsi model
   */ 
  interface tb_provinsiFieldRefs {
    readonly kodeProv: FieldRef<"tb_provinsi", 'String'>
    readonly namaProv: FieldRef<"tb_provinsi", 'String'>
  }
    

  // Custom InputTypes

  /**
   * tb_provinsi findUnique
   */
  export type tb_provinsiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_provinsi
     */
    select?: tb_provinsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_provinsiInclude<ExtArgs> | null
    /**
     * Filter, which tb_provinsi to fetch.
     */
    where: tb_provinsiWhereUniqueInput
  }


  /**
   * tb_provinsi findUniqueOrThrow
   */
  export type tb_provinsiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_provinsi
     */
    select?: tb_provinsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_provinsiInclude<ExtArgs> | null
    /**
     * Filter, which tb_provinsi to fetch.
     */
    where: tb_provinsiWhereUniqueInput
  }


  /**
   * tb_provinsi findFirst
   */
  export type tb_provinsiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_provinsi
     */
    select?: tb_provinsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_provinsiInclude<ExtArgs> | null
    /**
     * Filter, which tb_provinsi to fetch.
     */
    where?: tb_provinsiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_provinsis to fetch.
     */
    orderBy?: tb_provinsiOrderByWithRelationInput | tb_provinsiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_provinsis.
     */
    cursor?: tb_provinsiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_provinsis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_provinsis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_provinsis.
     */
    distinct?: Tb_provinsiScalarFieldEnum | Tb_provinsiScalarFieldEnum[]
  }


  /**
   * tb_provinsi findFirstOrThrow
   */
  export type tb_provinsiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_provinsi
     */
    select?: tb_provinsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_provinsiInclude<ExtArgs> | null
    /**
     * Filter, which tb_provinsi to fetch.
     */
    where?: tb_provinsiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_provinsis to fetch.
     */
    orderBy?: tb_provinsiOrderByWithRelationInput | tb_provinsiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_provinsis.
     */
    cursor?: tb_provinsiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_provinsis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_provinsis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_provinsis.
     */
    distinct?: Tb_provinsiScalarFieldEnum | Tb_provinsiScalarFieldEnum[]
  }


  /**
   * tb_provinsi findMany
   */
  export type tb_provinsiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_provinsi
     */
    select?: tb_provinsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_provinsiInclude<ExtArgs> | null
    /**
     * Filter, which tb_provinsis to fetch.
     */
    where?: tb_provinsiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_provinsis to fetch.
     */
    orderBy?: tb_provinsiOrderByWithRelationInput | tb_provinsiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_provinsis.
     */
    cursor?: tb_provinsiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_provinsis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_provinsis.
     */
    skip?: number
    distinct?: Tb_provinsiScalarFieldEnum | Tb_provinsiScalarFieldEnum[]
  }


  /**
   * tb_provinsi create
   */
  export type tb_provinsiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_provinsi
     */
    select?: tb_provinsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_provinsiInclude<ExtArgs> | null
    /**
     * The data needed to create a tb_provinsi.
     */
    data: XOR<tb_provinsiCreateInput, tb_provinsiUncheckedCreateInput>
  }


  /**
   * tb_provinsi createMany
   */
  export type tb_provinsiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_provinsis.
     */
    data: tb_provinsiCreateManyInput | tb_provinsiCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tb_provinsi update
   */
  export type tb_provinsiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_provinsi
     */
    select?: tb_provinsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_provinsiInclude<ExtArgs> | null
    /**
     * The data needed to update a tb_provinsi.
     */
    data: XOR<tb_provinsiUpdateInput, tb_provinsiUncheckedUpdateInput>
    /**
     * Choose, which tb_provinsi to update.
     */
    where: tb_provinsiWhereUniqueInput
  }


  /**
   * tb_provinsi updateMany
   */
  export type tb_provinsiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_provinsis.
     */
    data: XOR<tb_provinsiUpdateManyMutationInput, tb_provinsiUncheckedUpdateManyInput>
    /**
     * Filter which tb_provinsis to update
     */
    where?: tb_provinsiWhereInput
  }


  /**
   * tb_provinsi upsert
   */
  export type tb_provinsiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_provinsi
     */
    select?: tb_provinsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_provinsiInclude<ExtArgs> | null
    /**
     * The filter to search for the tb_provinsi to update in case it exists.
     */
    where: tb_provinsiWhereUniqueInput
    /**
     * In case the tb_provinsi found by the `where` argument doesn't exist, create a new tb_provinsi with this data.
     */
    create: XOR<tb_provinsiCreateInput, tb_provinsiUncheckedCreateInput>
    /**
     * In case the tb_provinsi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_provinsiUpdateInput, tb_provinsiUncheckedUpdateInput>
  }


  /**
   * tb_provinsi delete
   */
  export type tb_provinsiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_provinsi
     */
    select?: tb_provinsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_provinsiInclude<ExtArgs> | null
    /**
     * Filter which tb_provinsi to delete.
     */
    where: tb_provinsiWhereUniqueInput
  }


  /**
   * tb_provinsi deleteMany
   */
  export type tb_provinsiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_provinsis to delete
     */
    where?: tb_provinsiWhereInput
  }


  /**
   * tb_provinsi.fk_kodeProv_mhs
   */
  export type tb_provinsi$fk_kodeProv_mhsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_mhs
     */
    select?: tb_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_mhsInclude<ExtArgs> | null
    where?: tb_mhsWhereInput
    orderBy?: tb_mhsOrderByWithRelationInput | tb_mhsOrderByWithRelationInput[]
    cursor?: tb_mhsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tb_mhsScalarFieldEnum | Tb_mhsScalarFieldEnum[]
  }


  /**
   * tb_provinsi.fk_kodeProv_dosen
   */
  export type tb_provinsi$fk_kodeProv_dosenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_dosen
     */
    select?: tb_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_dosenInclude<ExtArgs> | null
    where?: tb_dosenWhereInput
    orderBy?: tb_dosenOrderByWithRelationInput | tb_dosenOrderByWithRelationInput[]
    cursor?: tb_dosenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tb_dosenScalarFieldEnum | Tb_dosenScalarFieldEnum[]
  }


  /**
   * tb_provinsi.fk_kodeProv_kabupaten
   */
  export type tb_provinsi$fk_kodeProv_kabupatenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_kabupaten
     */
    select?: tb_kabupatenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_kabupatenInclude<ExtArgs> | null
    where?: tb_kabupatenWhereInput
    orderBy?: tb_kabupatenOrderByWithRelationInput | tb_kabupatenOrderByWithRelationInput[]
    cursor?: tb_kabupatenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tb_kabupatenScalarFieldEnum | Tb_kabupatenScalarFieldEnum[]
  }


  /**
   * tb_provinsi without action
   */
  export type tb_provinsiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_provinsi
     */
    select?: tb_provinsiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_provinsiInclude<ExtArgs> | null
  }



  /**
   * Model tb_kabupaten
   */

  export type AggregateTb_kabupaten = {
    _count: Tb_kabupatenCountAggregateOutputType | null
    _min: Tb_kabupatenMinAggregateOutputType | null
    _max: Tb_kabupatenMaxAggregateOutputType | null
  }

  export type Tb_kabupatenMinAggregateOutputType = {
    kodeKab: string | null
    namaKab: string | null
    kodeProv: string | null
  }

  export type Tb_kabupatenMaxAggregateOutputType = {
    kodeKab: string | null
    namaKab: string | null
    kodeProv: string | null
  }

  export type Tb_kabupatenCountAggregateOutputType = {
    kodeKab: number
    namaKab: number
    kodeProv: number
    _all: number
  }


  export type Tb_kabupatenMinAggregateInputType = {
    kodeKab?: true
    namaKab?: true
    kodeProv?: true
  }

  export type Tb_kabupatenMaxAggregateInputType = {
    kodeKab?: true
    namaKab?: true
    kodeProv?: true
  }

  export type Tb_kabupatenCountAggregateInputType = {
    kodeKab?: true
    namaKab?: true
    kodeProv?: true
    _all?: true
  }

  export type Tb_kabupatenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_kabupaten to aggregate.
     */
    where?: tb_kabupatenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_kabupatens to fetch.
     */
    orderBy?: tb_kabupatenOrderByWithRelationInput | tb_kabupatenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_kabupatenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_kabupatens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_kabupatens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_kabupatens
    **/
    _count?: true | Tb_kabupatenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_kabupatenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_kabupatenMaxAggregateInputType
  }

  export type GetTb_kabupatenAggregateType<T extends Tb_kabupatenAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_kabupaten]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_kabupaten[P]>
      : GetScalarType<T[P], AggregateTb_kabupaten[P]>
  }




  export type tb_kabupatenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_kabupatenWhereInput
    orderBy?: tb_kabupatenOrderByWithAggregationInput | tb_kabupatenOrderByWithAggregationInput[]
    by: Tb_kabupatenScalarFieldEnum[] | Tb_kabupatenScalarFieldEnum
    having?: tb_kabupatenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_kabupatenCountAggregateInputType | true
    _min?: Tb_kabupatenMinAggregateInputType
    _max?: Tb_kabupatenMaxAggregateInputType
  }

  export type Tb_kabupatenGroupByOutputType = {
    kodeKab: string
    namaKab: string
    kodeProv: string
    _count: Tb_kabupatenCountAggregateOutputType | null
    _min: Tb_kabupatenMinAggregateOutputType | null
    _max: Tb_kabupatenMaxAggregateOutputType | null
  }

  type GetTb_kabupatenGroupByPayload<T extends tb_kabupatenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_kabupatenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_kabupatenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_kabupatenGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_kabupatenGroupByOutputType[P]>
        }
      >
    >


  export type tb_kabupatenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    kodeKab?: boolean
    namaKab?: boolean
    kodeProv?: boolean
    fk_kodeProv?: boolean | tb_provinsiDefaultArgs<ExtArgs>
    fk_kodeKab_mhs?: boolean | tb_kabupaten$fk_kodeKab_mhsArgs<ExtArgs>
    fk_kodeKab_dosen?: boolean | tb_kabupaten$fk_kodeKab_dosenArgs<ExtArgs>
    _count?: boolean | Tb_kabupatenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tb_kabupaten"]>

  export type tb_kabupatenSelectScalar = {
    kodeKab?: boolean
    namaKab?: boolean
    kodeProv?: boolean
  }

  export type tb_kabupatenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fk_kodeProv?: boolean | tb_provinsiDefaultArgs<ExtArgs>
    fk_kodeKab_mhs?: boolean | tb_kabupaten$fk_kodeKab_mhsArgs<ExtArgs>
    fk_kodeKab_dosen?: boolean | tb_kabupaten$fk_kodeKab_dosenArgs<ExtArgs>
    _count?: boolean | Tb_kabupatenCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $tb_kabupatenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_kabupaten"
    objects: {
      fk_kodeProv: Prisma.$tb_provinsiPayload<ExtArgs>
      fk_kodeKab_mhs: Prisma.$tb_mhsPayload<ExtArgs>[]
      fk_kodeKab_dosen: Prisma.$tb_dosenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      kodeKab: string
      namaKab: string
      kodeProv: string
    }, ExtArgs["result"]["tb_kabupaten"]>
    composites: {}
  }


  type tb_kabupatenGetPayload<S extends boolean | null | undefined | tb_kabupatenDefaultArgs> = $Result.GetResult<Prisma.$tb_kabupatenPayload, S>

  type tb_kabupatenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tb_kabupatenFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Tb_kabupatenCountAggregateInputType | true
    }

  export interface tb_kabupatenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_kabupaten'], meta: { name: 'tb_kabupaten' } }
    /**
     * Find zero or one Tb_kabupaten that matches the filter.
     * @param {tb_kabupatenFindUniqueArgs} args - Arguments to find a Tb_kabupaten
     * @example
     * // Get one Tb_kabupaten
     * const tb_kabupaten = await prisma.tb_kabupaten.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tb_kabupatenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tb_kabupatenFindUniqueArgs<ExtArgs>>
    ): Prisma__tb_kabupatenClient<$Result.GetResult<Prisma.$tb_kabupatenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tb_kabupaten that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tb_kabupatenFindUniqueOrThrowArgs} args - Arguments to find a Tb_kabupaten
     * @example
     * // Get one Tb_kabupaten
     * const tb_kabupaten = await prisma.tb_kabupaten.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tb_kabupatenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_kabupatenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tb_kabupatenClient<$Result.GetResult<Prisma.$tb_kabupatenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tb_kabupaten that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_kabupatenFindFirstArgs} args - Arguments to find a Tb_kabupaten
     * @example
     * // Get one Tb_kabupaten
     * const tb_kabupaten = await prisma.tb_kabupaten.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tb_kabupatenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_kabupatenFindFirstArgs<ExtArgs>>
    ): Prisma__tb_kabupatenClient<$Result.GetResult<Prisma.$tb_kabupatenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tb_kabupaten that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_kabupatenFindFirstOrThrowArgs} args - Arguments to find a Tb_kabupaten
     * @example
     * // Get one Tb_kabupaten
     * const tb_kabupaten = await prisma.tb_kabupaten.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tb_kabupatenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_kabupatenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tb_kabupatenClient<$Result.GetResult<Prisma.$tb_kabupatenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tb_kabupatens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_kabupatenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_kabupatens
     * const tb_kabupatens = await prisma.tb_kabupaten.findMany()
     * 
     * // Get first 10 Tb_kabupatens
     * const tb_kabupatens = await prisma.tb_kabupaten.findMany({ take: 10 })
     * 
     * // Only select the `kodeKab`
     * const tb_kabupatenWithKodeKabOnly = await prisma.tb_kabupaten.findMany({ select: { kodeKab: true } })
     * 
    **/
    findMany<T extends tb_kabupatenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_kabupatenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_kabupatenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tb_kabupaten.
     * @param {tb_kabupatenCreateArgs} args - Arguments to create a Tb_kabupaten.
     * @example
     * // Create one Tb_kabupaten
     * const Tb_kabupaten = await prisma.tb_kabupaten.create({
     *   data: {
     *     // ... data to create a Tb_kabupaten
     *   }
     * })
     * 
    **/
    create<T extends tb_kabupatenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_kabupatenCreateArgs<ExtArgs>>
    ): Prisma__tb_kabupatenClient<$Result.GetResult<Prisma.$tb_kabupatenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tb_kabupatens.
     *     @param {tb_kabupatenCreateManyArgs} args - Arguments to create many Tb_kabupatens.
     *     @example
     *     // Create many Tb_kabupatens
     *     const tb_kabupaten = await prisma.tb_kabupaten.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tb_kabupatenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_kabupatenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_kabupaten.
     * @param {tb_kabupatenDeleteArgs} args - Arguments to delete one Tb_kabupaten.
     * @example
     * // Delete one Tb_kabupaten
     * const Tb_kabupaten = await prisma.tb_kabupaten.delete({
     *   where: {
     *     // ... filter to delete one Tb_kabupaten
     *   }
     * })
     * 
    **/
    delete<T extends tb_kabupatenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tb_kabupatenDeleteArgs<ExtArgs>>
    ): Prisma__tb_kabupatenClient<$Result.GetResult<Prisma.$tb_kabupatenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tb_kabupaten.
     * @param {tb_kabupatenUpdateArgs} args - Arguments to update one Tb_kabupaten.
     * @example
     * // Update one Tb_kabupaten
     * const tb_kabupaten = await prisma.tb_kabupaten.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tb_kabupatenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_kabupatenUpdateArgs<ExtArgs>>
    ): Prisma__tb_kabupatenClient<$Result.GetResult<Prisma.$tb_kabupatenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tb_kabupatens.
     * @param {tb_kabupatenDeleteManyArgs} args - Arguments to filter Tb_kabupatens to delete.
     * @example
     * // Delete a few Tb_kabupatens
     * const { count } = await prisma.tb_kabupaten.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tb_kabupatenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_kabupatenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_kabupatens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_kabupatenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_kabupatens
     * const tb_kabupaten = await prisma.tb_kabupaten.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tb_kabupatenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tb_kabupatenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_kabupaten.
     * @param {tb_kabupatenUpsertArgs} args - Arguments to update or create a Tb_kabupaten.
     * @example
     * // Update or create a Tb_kabupaten
     * const tb_kabupaten = await prisma.tb_kabupaten.upsert({
     *   create: {
     *     // ... data to create a Tb_kabupaten
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_kabupaten we want to update
     *   }
     * })
    **/
    upsert<T extends tb_kabupatenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tb_kabupatenUpsertArgs<ExtArgs>>
    ): Prisma__tb_kabupatenClient<$Result.GetResult<Prisma.$tb_kabupatenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tb_kabupatens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_kabupatenCountArgs} args - Arguments to filter Tb_kabupatens to count.
     * @example
     * // Count the number of Tb_kabupatens
     * const count = await prisma.tb_kabupaten.count({
     *   where: {
     *     // ... the filter for the Tb_kabupatens we want to count
     *   }
     * })
    **/
    count<T extends tb_kabupatenCountArgs>(
      args?: Subset<T, tb_kabupatenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_kabupatenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_kabupaten.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_kabupatenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_kabupatenAggregateArgs>(args: Subset<T, Tb_kabupatenAggregateArgs>): Prisma.PrismaPromise<GetTb_kabupatenAggregateType<T>>

    /**
     * Group by Tb_kabupaten.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_kabupatenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_kabupatenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_kabupatenGroupByArgs['orderBy'] }
        : { orderBy?: tb_kabupatenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_kabupatenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_kabupatenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_kabupaten model
   */
  readonly fields: tb_kabupatenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_kabupaten.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_kabupatenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    fk_kodeProv<T extends tb_provinsiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tb_provinsiDefaultArgs<ExtArgs>>): Prisma__tb_provinsiClient<$Result.GetResult<Prisma.$tb_provinsiPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    fk_kodeKab_mhs<T extends tb_kabupaten$fk_kodeKab_mhsArgs<ExtArgs> = {}>(args?: Subset<T, tb_kabupaten$fk_kodeKab_mhsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_mhsPayload<ExtArgs>, T, 'findMany'> | Null>;

    fk_kodeKab_dosen<T extends tb_kabupaten$fk_kodeKab_dosenArgs<ExtArgs> = {}>(args?: Subset<T, tb_kabupaten$fk_kodeKab_dosenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_dosenPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tb_kabupaten model
   */ 
  interface tb_kabupatenFieldRefs {
    readonly kodeKab: FieldRef<"tb_kabupaten", 'String'>
    readonly namaKab: FieldRef<"tb_kabupaten", 'String'>
    readonly kodeProv: FieldRef<"tb_kabupaten", 'String'>
  }
    

  // Custom InputTypes

  /**
   * tb_kabupaten findUnique
   */
  export type tb_kabupatenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_kabupaten
     */
    select?: tb_kabupatenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_kabupatenInclude<ExtArgs> | null
    /**
     * Filter, which tb_kabupaten to fetch.
     */
    where: tb_kabupatenWhereUniqueInput
  }


  /**
   * tb_kabupaten findUniqueOrThrow
   */
  export type tb_kabupatenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_kabupaten
     */
    select?: tb_kabupatenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_kabupatenInclude<ExtArgs> | null
    /**
     * Filter, which tb_kabupaten to fetch.
     */
    where: tb_kabupatenWhereUniqueInput
  }


  /**
   * tb_kabupaten findFirst
   */
  export type tb_kabupatenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_kabupaten
     */
    select?: tb_kabupatenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_kabupatenInclude<ExtArgs> | null
    /**
     * Filter, which tb_kabupaten to fetch.
     */
    where?: tb_kabupatenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_kabupatens to fetch.
     */
    orderBy?: tb_kabupatenOrderByWithRelationInput | tb_kabupatenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_kabupatens.
     */
    cursor?: tb_kabupatenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_kabupatens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_kabupatens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_kabupatens.
     */
    distinct?: Tb_kabupatenScalarFieldEnum | Tb_kabupatenScalarFieldEnum[]
  }


  /**
   * tb_kabupaten findFirstOrThrow
   */
  export type tb_kabupatenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_kabupaten
     */
    select?: tb_kabupatenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_kabupatenInclude<ExtArgs> | null
    /**
     * Filter, which tb_kabupaten to fetch.
     */
    where?: tb_kabupatenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_kabupatens to fetch.
     */
    orderBy?: tb_kabupatenOrderByWithRelationInput | tb_kabupatenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_kabupatens.
     */
    cursor?: tb_kabupatenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_kabupatens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_kabupatens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_kabupatens.
     */
    distinct?: Tb_kabupatenScalarFieldEnum | Tb_kabupatenScalarFieldEnum[]
  }


  /**
   * tb_kabupaten findMany
   */
  export type tb_kabupatenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_kabupaten
     */
    select?: tb_kabupatenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_kabupatenInclude<ExtArgs> | null
    /**
     * Filter, which tb_kabupatens to fetch.
     */
    where?: tb_kabupatenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_kabupatens to fetch.
     */
    orderBy?: tb_kabupatenOrderByWithRelationInput | tb_kabupatenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_kabupatens.
     */
    cursor?: tb_kabupatenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_kabupatens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_kabupatens.
     */
    skip?: number
    distinct?: Tb_kabupatenScalarFieldEnum | Tb_kabupatenScalarFieldEnum[]
  }


  /**
   * tb_kabupaten create
   */
  export type tb_kabupatenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_kabupaten
     */
    select?: tb_kabupatenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_kabupatenInclude<ExtArgs> | null
    /**
     * The data needed to create a tb_kabupaten.
     */
    data: XOR<tb_kabupatenCreateInput, tb_kabupatenUncheckedCreateInput>
  }


  /**
   * tb_kabupaten createMany
   */
  export type tb_kabupatenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_kabupatens.
     */
    data: tb_kabupatenCreateManyInput | tb_kabupatenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tb_kabupaten update
   */
  export type tb_kabupatenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_kabupaten
     */
    select?: tb_kabupatenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_kabupatenInclude<ExtArgs> | null
    /**
     * The data needed to update a tb_kabupaten.
     */
    data: XOR<tb_kabupatenUpdateInput, tb_kabupatenUncheckedUpdateInput>
    /**
     * Choose, which tb_kabupaten to update.
     */
    where: tb_kabupatenWhereUniqueInput
  }


  /**
   * tb_kabupaten updateMany
   */
  export type tb_kabupatenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_kabupatens.
     */
    data: XOR<tb_kabupatenUpdateManyMutationInput, tb_kabupatenUncheckedUpdateManyInput>
    /**
     * Filter which tb_kabupatens to update
     */
    where?: tb_kabupatenWhereInput
  }


  /**
   * tb_kabupaten upsert
   */
  export type tb_kabupatenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_kabupaten
     */
    select?: tb_kabupatenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_kabupatenInclude<ExtArgs> | null
    /**
     * The filter to search for the tb_kabupaten to update in case it exists.
     */
    where: tb_kabupatenWhereUniqueInput
    /**
     * In case the tb_kabupaten found by the `where` argument doesn't exist, create a new tb_kabupaten with this data.
     */
    create: XOR<tb_kabupatenCreateInput, tb_kabupatenUncheckedCreateInput>
    /**
     * In case the tb_kabupaten was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_kabupatenUpdateInput, tb_kabupatenUncheckedUpdateInput>
  }


  /**
   * tb_kabupaten delete
   */
  export type tb_kabupatenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_kabupaten
     */
    select?: tb_kabupatenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_kabupatenInclude<ExtArgs> | null
    /**
     * Filter which tb_kabupaten to delete.
     */
    where: tb_kabupatenWhereUniqueInput
  }


  /**
   * tb_kabupaten deleteMany
   */
  export type tb_kabupatenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_kabupatens to delete
     */
    where?: tb_kabupatenWhereInput
  }


  /**
   * tb_kabupaten.fk_kodeKab_mhs
   */
  export type tb_kabupaten$fk_kodeKab_mhsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_mhs
     */
    select?: tb_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_mhsInclude<ExtArgs> | null
    where?: tb_mhsWhereInput
    orderBy?: tb_mhsOrderByWithRelationInput | tb_mhsOrderByWithRelationInput[]
    cursor?: tb_mhsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tb_mhsScalarFieldEnum | Tb_mhsScalarFieldEnum[]
  }


  /**
   * tb_kabupaten.fk_kodeKab_dosen
   */
  export type tb_kabupaten$fk_kodeKab_dosenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_dosen
     */
    select?: tb_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_dosenInclude<ExtArgs> | null
    where?: tb_dosenWhereInput
    orderBy?: tb_dosenOrderByWithRelationInput | tb_dosenOrderByWithRelationInput[]
    cursor?: tb_dosenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tb_dosenScalarFieldEnum | Tb_dosenScalarFieldEnum[]
  }


  /**
   * tb_kabupaten without action
   */
  export type tb_kabupatenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_kabupaten
     */
    select?: tb_kabupatenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_kabupatenInclude<ExtArgs> | null
  }



  /**
   * Model tb_akun_mhs
   */

  export type AggregateTb_akun_mhs = {
    _count: Tb_akun_mhsCountAggregateOutputType | null
    _min: Tb_akun_mhsMinAggregateOutputType | null
    _max: Tb_akun_mhsMaxAggregateOutputType | null
  }

  export type Tb_akun_mhsMinAggregateOutputType = {
    username: string | null
    password: string | null
    status: $Enums.StatusAkun | null
    pemilik: string | null
  }

  export type Tb_akun_mhsMaxAggregateOutputType = {
    username: string | null
    password: string | null
    status: $Enums.StatusAkun | null
    pemilik: string | null
  }

  export type Tb_akun_mhsCountAggregateOutputType = {
    username: number
    password: number
    status: number
    pemilik: number
    _all: number
  }


  export type Tb_akun_mhsMinAggregateInputType = {
    username?: true
    password?: true
    status?: true
    pemilik?: true
  }

  export type Tb_akun_mhsMaxAggregateInputType = {
    username?: true
    password?: true
    status?: true
    pemilik?: true
  }

  export type Tb_akun_mhsCountAggregateInputType = {
    username?: true
    password?: true
    status?: true
    pemilik?: true
    _all?: true
  }

  export type Tb_akun_mhsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_akun_mhs to aggregate.
     */
    where?: tb_akun_mhsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_akun_mhs to fetch.
     */
    orderBy?: tb_akun_mhsOrderByWithRelationInput | tb_akun_mhsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_akun_mhsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_akun_mhs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_akun_mhs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_akun_mhs
    **/
    _count?: true | Tb_akun_mhsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_akun_mhsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_akun_mhsMaxAggregateInputType
  }

  export type GetTb_akun_mhsAggregateType<T extends Tb_akun_mhsAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_akun_mhs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_akun_mhs[P]>
      : GetScalarType<T[P], AggregateTb_akun_mhs[P]>
  }




  export type tb_akun_mhsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_akun_mhsWhereInput
    orderBy?: tb_akun_mhsOrderByWithAggregationInput | tb_akun_mhsOrderByWithAggregationInput[]
    by: Tb_akun_mhsScalarFieldEnum[] | Tb_akun_mhsScalarFieldEnum
    having?: tb_akun_mhsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_akun_mhsCountAggregateInputType | true
    _min?: Tb_akun_mhsMinAggregateInputType
    _max?: Tb_akun_mhsMaxAggregateInputType
  }

  export type Tb_akun_mhsGroupByOutputType = {
    username: string
    password: string
    status: $Enums.StatusAkun
    pemilik: string
    _count: Tb_akun_mhsCountAggregateOutputType | null
    _min: Tb_akun_mhsMinAggregateOutputType | null
    _max: Tb_akun_mhsMaxAggregateOutputType | null
  }

  type GetTb_akun_mhsGroupByPayload<T extends tb_akun_mhsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_akun_mhsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_akun_mhsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_akun_mhsGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_akun_mhsGroupByOutputType[P]>
        }
      >
    >


  export type tb_akun_mhsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    username?: boolean
    password?: boolean
    status?: boolean
    pemilik?: boolean
    fk_pemilik?: boolean | tb_mhsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tb_akun_mhs"]>

  export type tb_akun_mhsSelectScalar = {
    username?: boolean
    password?: boolean
    status?: boolean
    pemilik?: boolean
  }

  export type tb_akun_mhsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fk_pemilik?: boolean | tb_mhsDefaultArgs<ExtArgs>
  }


  export type $tb_akun_mhsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_akun_mhs"
    objects: {
      fk_pemilik: Prisma.$tb_mhsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      username: string
      password: string
      status: $Enums.StatusAkun
      pemilik: string
    }, ExtArgs["result"]["tb_akun_mhs"]>
    composites: {}
  }


  type tb_akun_mhsGetPayload<S extends boolean | null | undefined | tb_akun_mhsDefaultArgs> = $Result.GetResult<Prisma.$tb_akun_mhsPayload, S>

  type tb_akun_mhsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tb_akun_mhsFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Tb_akun_mhsCountAggregateInputType | true
    }

  export interface tb_akun_mhsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_akun_mhs'], meta: { name: 'tb_akun_mhs' } }
    /**
     * Find zero or one Tb_akun_mhs that matches the filter.
     * @param {tb_akun_mhsFindUniqueArgs} args - Arguments to find a Tb_akun_mhs
     * @example
     * // Get one Tb_akun_mhs
     * const tb_akun_mhs = await prisma.tb_akun_mhs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tb_akun_mhsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tb_akun_mhsFindUniqueArgs<ExtArgs>>
    ): Prisma__tb_akun_mhsClient<$Result.GetResult<Prisma.$tb_akun_mhsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tb_akun_mhs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tb_akun_mhsFindUniqueOrThrowArgs} args - Arguments to find a Tb_akun_mhs
     * @example
     * // Get one Tb_akun_mhs
     * const tb_akun_mhs = await prisma.tb_akun_mhs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tb_akun_mhsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_akun_mhsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tb_akun_mhsClient<$Result.GetResult<Prisma.$tb_akun_mhsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tb_akun_mhs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_akun_mhsFindFirstArgs} args - Arguments to find a Tb_akun_mhs
     * @example
     * // Get one Tb_akun_mhs
     * const tb_akun_mhs = await prisma.tb_akun_mhs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tb_akun_mhsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_akun_mhsFindFirstArgs<ExtArgs>>
    ): Prisma__tb_akun_mhsClient<$Result.GetResult<Prisma.$tb_akun_mhsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tb_akun_mhs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_akun_mhsFindFirstOrThrowArgs} args - Arguments to find a Tb_akun_mhs
     * @example
     * // Get one Tb_akun_mhs
     * const tb_akun_mhs = await prisma.tb_akun_mhs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tb_akun_mhsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_akun_mhsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tb_akun_mhsClient<$Result.GetResult<Prisma.$tb_akun_mhsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tb_akun_mhs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_akun_mhsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_akun_mhs
     * const tb_akun_mhs = await prisma.tb_akun_mhs.findMany()
     * 
     * // Get first 10 Tb_akun_mhs
     * const tb_akun_mhs = await prisma.tb_akun_mhs.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const tb_akun_mhsWithUsernameOnly = await prisma.tb_akun_mhs.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends tb_akun_mhsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_akun_mhsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_akun_mhsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tb_akun_mhs.
     * @param {tb_akun_mhsCreateArgs} args - Arguments to create a Tb_akun_mhs.
     * @example
     * // Create one Tb_akun_mhs
     * const Tb_akun_mhs = await prisma.tb_akun_mhs.create({
     *   data: {
     *     // ... data to create a Tb_akun_mhs
     *   }
     * })
     * 
    **/
    create<T extends tb_akun_mhsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_akun_mhsCreateArgs<ExtArgs>>
    ): Prisma__tb_akun_mhsClient<$Result.GetResult<Prisma.$tb_akun_mhsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tb_akun_mhs.
     *     @param {tb_akun_mhsCreateManyArgs} args - Arguments to create many Tb_akun_mhs.
     *     @example
     *     // Create many Tb_akun_mhs
     *     const tb_akun_mhs = await prisma.tb_akun_mhs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tb_akun_mhsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_akun_mhsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_akun_mhs.
     * @param {tb_akun_mhsDeleteArgs} args - Arguments to delete one Tb_akun_mhs.
     * @example
     * // Delete one Tb_akun_mhs
     * const Tb_akun_mhs = await prisma.tb_akun_mhs.delete({
     *   where: {
     *     // ... filter to delete one Tb_akun_mhs
     *   }
     * })
     * 
    **/
    delete<T extends tb_akun_mhsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tb_akun_mhsDeleteArgs<ExtArgs>>
    ): Prisma__tb_akun_mhsClient<$Result.GetResult<Prisma.$tb_akun_mhsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tb_akun_mhs.
     * @param {tb_akun_mhsUpdateArgs} args - Arguments to update one Tb_akun_mhs.
     * @example
     * // Update one Tb_akun_mhs
     * const tb_akun_mhs = await prisma.tb_akun_mhs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tb_akun_mhsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_akun_mhsUpdateArgs<ExtArgs>>
    ): Prisma__tb_akun_mhsClient<$Result.GetResult<Prisma.$tb_akun_mhsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tb_akun_mhs.
     * @param {tb_akun_mhsDeleteManyArgs} args - Arguments to filter Tb_akun_mhs to delete.
     * @example
     * // Delete a few Tb_akun_mhs
     * const { count } = await prisma.tb_akun_mhs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tb_akun_mhsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_akun_mhsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_akun_mhs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_akun_mhsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_akun_mhs
     * const tb_akun_mhs = await prisma.tb_akun_mhs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tb_akun_mhsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tb_akun_mhsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_akun_mhs.
     * @param {tb_akun_mhsUpsertArgs} args - Arguments to update or create a Tb_akun_mhs.
     * @example
     * // Update or create a Tb_akun_mhs
     * const tb_akun_mhs = await prisma.tb_akun_mhs.upsert({
     *   create: {
     *     // ... data to create a Tb_akun_mhs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_akun_mhs we want to update
     *   }
     * })
    **/
    upsert<T extends tb_akun_mhsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tb_akun_mhsUpsertArgs<ExtArgs>>
    ): Prisma__tb_akun_mhsClient<$Result.GetResult<Prisma.$tb_akun_mhsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tb_akun_mhs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_akun_mhsCountArgs} args - Arguments to filter Tb_akun_mhs to count.
     * @example
     * // Count the number of Tb_akun_mhs
     * const count = await prisma.tb_akun_mhs.count({
     *   where: {
     *     // ... the filter for the Tb_akun_mhs we want to count
     *   }
     * })
    **/
    count<T extends tb_akun_mhsCountArgs>(
      args?: Subset<T, tb_akun_mhsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_akun_mhsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_akun_mhs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_akun_mhsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_akun_mhsAggregateArgs>(args: Subset<T, Tb_akun_mhsAggregateArgs>): Prisma.PrismaPromise<GetTb_akun_mhsAggregateType<T>>

    /**
     * Group by Tb_akun_mhs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_akun_mhsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_akun_mhsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_akun_mhsGroupByArgs['orderBy'] }
        : { orderBy?: tb_akun_mhsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_akun_mhsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_akun_mhsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_akun_mhs model
   */
  readonly fields: tb_akun_mhsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_akun_mhs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_akun_mhsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    fk_pemilik<T extends tb_mhsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tb_mhsDefaultArgs<ExtArgs>>): Prisma__tb_mhsClient<$Result.GetResult<Prisma.$tb_mhsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tb_akun_mhs model
   */ 
  interface tb_akun_mhsFieldRefs {
    readonly username: FieldRef<"tb_akun_mhs", 'String'>
    readonly password: FieldRef<"tb_akun_mhs", 'String'>
    readonly status: FieldRef<"tb_akun_mhs", 'StatusAkun'>
    readonly pemilik: FieldRef<"tb_akun_mhs", 'String'>
  }
    

  // Custom InputTypes

  /**
   * tb_akun_mhs findUnique
   */
  export type tb_akun_mhsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_mhs
     */
    select?: tb_akun_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_mhsInclude<ExtArgs> | null
    /**
     * Filter, which tb_akun_mhs to fetch.
     */
    where: tb_akun_mhsWhereUniqueInput
  }


  /**
   * tb_akun_mhs findUniqueOrThrow
   */
  export type tb_akun_mhsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_mhs
     */
    select?: tb_akun_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_mhsInclude<ExtArgs> | null
    /**
     * Filter, which tb_akun_mhs to fetch.
     */
    where: tb_akun_mhsWhereUniqueInput
  }


  /**
   * tb_akun_mhs findFirst
   */
  export type tb_akun_mhsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_mhs
     */
    select?: tb_akun_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_mhsInclude<ExtArgs> | null
    /**
     * Filter, which tb_akun_mhs to fetch.
     */
    where?: tb_akun_mhsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_akun_mhs to fetch.
     */
    orderBy?: tb_akun_mhsOrderByWithRelationInput | tb_akun_mhsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_akun_mhs.
     */
    cursor?: tb_akun_mhsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_akun_mhs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_akun_mhs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_akun_mhs.
     */
    distinct?: Tb_akun_mhsScalarFieldEnum | Tb_akun_mhsScalarFieldEnum[]
  }


  /**
   * tb_akun_mhs findFirstOrThrow
   */
  export type tb_akun_mhsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_mhs
     */
    select?: tb_akun_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_mhsInclude<ExtArgs> | null
    /**
     * Filter, which tb_akun_mhs to fetch.
     */
    where?: tb_akun_mhsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_akun_mhs to fetch.
     */
    orderBy?: tb_akun_mhsOrderByWithRelationInput | tb_akun_mhsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_akun_mhs.
     */
    cursor?: tb_akun_mhsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_akun_mhs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_akun_mhs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_akun_mhs.
     */
    distinct?: Tb_akun_mhsScalarFieldEnum | Tb_akun_mhsScalarFieldEnum[]
  }


  /**
   * tb_akun_mhs findMany
   */
  export type tb_akun_mhsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_mhs
     */
    select?: tb_akun_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_mhsInclude<ExtArgs> | null
    /**
     * Filter, which tb_akun_mhs to fetch.
     */
    where?: tb_akun_mhsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_akun_mhs to fetch.
     */
    orderBy?: tb_akun_mhsOrderByWithRelationInput | tb_akun_mhsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_akun_mhs.
     */
    cursor?: tb_akun_mhsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_akun_mhs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_akun_mhs.
     */
    skip?: number
    distinct?: Tb_akun_mhsScalarFieldEnum | Tb_akun_mhsScalarFieldEnum[]
  }


  /**
   * tb_akun_mhs create
   */
  export type tb_akun_mhsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_mhs
     */
    select?: tb_akun_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_mhsInclude<ExtArgs> | null
    /**
     * The data needed to create a tb_akun_mhs.
     */
    data: XOR<tb_akun_mhsCreateInput, tb_akun_mhsUncheckedCreateInput>
  }


  /**
   * tb_akun_mhs createMany
   */
  export type tb_akun_mhsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_akun_mhs.
     */
    data: tb_akun_mhsCreateManyInput | tb_akun_mhsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tb_akun_mhs update
   */
  export type tb_akun_mhsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_mhs
     */
    select?: tb_akun_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_mhsInclude<ExtArgs> | null
    /**
     * The data needed to update a tb_akun_mhs.
     */
    data: XOR<tb_akun_mhsUpdateInput, tb_akun_mhsUncheckedUpdateInput>
    /**
     * Choose, which tb_akun_mhs to update.
     */
    where: tb_akun_mhsWhereUniqueInput
  }


  /**
   * tb_akun_mhs updateMany
   */
  export type tb_akun_mhsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_akun_mhs.
     */
    data: XOR<tb_akun_mhsUpdateManyMutationInput, tb_akun_mhsUncheckedUpdateManyInput>
    /**
     * Filter which tb_akun_mhs to update
     */
    where?: tb_akun_mhsWhereInput
  }


  /**
   * tb_akun_mhs upsert
   */
  export type tb_akun_mhsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_mhs
     */
    select?: tb_akun_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_mhsInclude<ExtArgs> | null
    /**
     * The filter to search for the tb_akun_mhs to update in case it exists.
     */
    where: tb_akun_mhsWhereUniqueInput
    /**
     * In case the tb_akun_mhs found by the `where` argument doesn't exist, create a new tb_akun_mhs with this data.
     */
    create: XOR<tb_akun_mhsCreateInput, tb_akun_mhsUncheckedCreateInput>
    /**
     * In case the tb_akun_mhs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_akun_mhsUpdateInput, tb_akun_mhsUncheckedUpdateInput>
  }


  /**
   * tb_akun_mhs delete
   */
  export type tb_akun_mhsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_mhs
     */
    select?: tb_akun_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_mhsInclude<ExtArgs> | null
    /**
     * Filter which tb_akun_mhs to delete.
     */
    where: tb_akun_mhsWhereUniqueInput
  }


  /**
   * tb_akun_mhs deleteMany
   */
  export type tb_akun_mhsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_akun_mhs to delete
     */
    where?: tb_akun_mhsWhereInput
  }


  /**
   * tb_akun_mhs without action
   */
  export type tb_akun_mhsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_mhs
     */
    select?: tb_akun_mhsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_mhsInclude<ExtArgs> | null
  }



  /**
   * Model tb_akun_dosen
   */

  export type AggregateTb_akun_dosen = {
    _count: Tb_akun_dosenCountAggregateOutputType | null
    _min: Tb_akun_dosenMinAggregateOutputType | null
    _max: Tb_akun_dosenMaxAggregateOutputType | null
  }

  export type Tb_akun_dosenMinAggregateOutputType = {
    username: string | null
    password: string | null
    status: $Enums.StatusAkun | null
    pemilik: string | null
  }

  export type Tb_akun_dosenMaxAggregateOutputType = {
    username: string | null
    password: string | null
    status: $Enums.StatusAkun | null
    pemilik: string | null
  }

  export type Tb_akun_dosenCountAggregateOutputType = {
    username: number
    password: number
    status: number
    pemilik: number
    _all: number
  }


  export type Tb_akun_dosenMinAggregateInputType = {
    username?: true
    password?: true
    status?: true
    pemilik?: true
  }

  export type Tb_akun_dosenMaxAggregateInputType = {
    username?: true
    password?: true
    status?: true
    pemilik?: true
  }

  export type Tb_akun_dosenCountAggregateInputType = {
    username?: true
    password?: true
    status?: true
    pemilik?: true
    _all?: true
  }

  export type Tb_akun_dosenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_akun_dosen to aggregate.
     */
    where?: tb_akun_dosenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_akun_dosens to fetch.
     */
    orderBy?: tb_akun_dosenOrderByWithRelationInput | tb_akun_dosenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_akun_dosenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_akun_dosens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_akun_dosens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_akun_dosens
    **/
    _count?: true | Tb_akun_dosenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_akun_dosenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_akun_dosenMaxAggregateInputType
  }

  export type GetTb_akun_dosenAggregateType<T extends Tb_akun_dosenAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_akun_dosen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_akun_dosen[P]>
      : GetScalarType<T[P], AggregateTb_akun_dosen[P]>
  }




  export type tb_akun_dosenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_akun_dosenWhereInput
    orderBy?: tb_akun_dosenOrderByWithAggregationInput | tb_akun_dosenOrderByWithAggregationInput[]
    by: Tb_akun_dosenScalarFieldEnum[] | Tb_akun_dosenScalarFieldEnum
    having?: tb_akun_dosenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_akun_dosenCountAggregateInputType | true
    _min?: Tb_akun_dosenMinAggregateInputType
    _max?: Tb_akun_dosenMaxAggregateInputType
  }

  export type Tb_akun_dosenGroupByOutputType = {
    username: string
    password: string
    status: $Enums.StatusAkun
    pemilik: string
    _count: Tb_akun_dosenCountAggregateOutputType | null
    _min: Tb_akun_dosenMinAggregateOutputType | null
    _max: Tb_akun_dosenMaxAggregateOutputType | null
  }

  type GetTb_akun_dosenGroupByPayload<T extends tb_akun_dosenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_akun_dosenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_akun_dosenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_akun_dosenGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_akun_dosenGroupByOutputType[P]>
        }
      >
    >


  export type tb_akun_dosenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    username?: boolean
    password?: boolean
    status?: boolean
    pemilik?: boolean
    fk_pemilik?: boolean | tb_dosenDefaultArgs<ExtArgs>
    fk_username_role?: boolean | tb_akun_dosen$fk_username_roleArgs<ExtArgs>
    _count?: boolean | Tb_akun_dosenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tb_akun_dosen"]>

  export type tb_akun_dosenSelectScalar = {
    username?: boolean
    password?: boolean
    status?: boolean
    pemilik?: boolean
  }

  export type tb_akun_dosenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fk_pemilik?: boolean | tb_dosenDefaultArgs<ExtArgs>
    fk_username_role?: boolean | tb_akun_dosen$fk_username_roleArgs<ExtArgs>
    _count?: boolean | Tb_akun_dosenCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $tb_akun_dosenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_akun_dosen"
    objects: {
      fk_pemilik: Prisma.$tb_dosenPayload<ExtArgs>
      fk_username_role: Prisma.$tb_role_akun_dosenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      username: string
      password: string
      status: $Enums.StatusAkun
      pemilik: string
    }, ExtArgs["result"]["tb_akun_dosen"]>
    composites: {}
  }


  type tb_akun_dosenGetPayload<S extends boolean | null | undefined | tb_akun_dosenDefaultArgs> = $Result.GetResult<Prisma.$tb_akun_dosenPayload, S>

  type tb_akun_dosenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tb_akun_dosenFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Tb_akun_dosenCountAggregateInputType | true
    }

  export interface tb_akun_dosenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_akun_dosen'], meta: { name: 'tb_akun_dosen' } }
    /**
     * Find zero or one Tb_akun_dosen that matches the filter.
     * @param {tb_akun_dosenFindUniqueArgs} args - Arguments to find a Tb_akun_dosen
     * @example
     * // Get one Tb_akun_dosen
     * const tb_akun_dosen = await prisma.tb_akun_dosen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tb_akun_dosenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tb_akun_dosenFindUniqueArgs<ExtArgs>>
    ): Prisma__tb_akun_dosenClient<$Result.GetResult<Prisma.$tb_akun_dosenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tb_akun_dosen that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tb_akun_dosenFindUniqueOrThrowArgs} args - Arguments to find a Tb_akun_dosen
     * @example
     * // Get one Tb_akun_dosen
     * const tb_akun_dosen = await prisma.tb_akun_dosen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tb_akun_dosenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_akun_dosenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tb_akun_dosenClient<$Result.GetResult<Prisma.$tb_akun_dosenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tb_akun_dosen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_akun_dosenFindFirstArgs} args - Arguments to find a Tb_akun_dosen
     * @example
     * // Get one Tb_akun_dosen
     * const tb_akun_dosen = await prisma.tb_akun_dosen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tb_akun_dosenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_akun_dosenFindFirstArgs<ExtArgs>>
    ): Prisma__tb_akun_dosenClient<$Result.GetResult<Prisma.$tb_akun_dosenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tb_akun_dosen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_akun_dosenFindFirstOrThrowArgs} args - Arguments to find a Tb_akun_dosen
     * @example
     * // Get one Tb_akun_dosen
     * const tb_akun_dosen = await prisma.tb_akun_dosen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tb_akun_dosenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_akun_dosenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tb_akun_dosenClient<$Result.GetResult<Prisma.$tb_akun_dosenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tb_akun_dosens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_akun_dosenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_akun_dosens
     * const tb_akun_dosens = await prisma.tb_akun_dosen.findMany()
     * 
     * // Get first 10 Tb_akun_dosens
     * const tb_akun_dosens = await prisma.tb_akun_dosen.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const tb_akun_dosenWithUsernameOnly = await prisma.tb_akun_dosen.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends tb_akun_dosenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_akun_dosenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_akun_dosenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tb_akun_dosen.
     * @param {tb_akun_dosenCreateArgs} args - Arguments to create a Tb_akun_dosen.
     * @example
     * // Create one Tb_akun_dosen
     * const Tb_akun_dosen = await prisma.tb_akun_dosen.create({
     *   data: {
     *     // ... data to create a Tb_akun_dosen
     *   }
     * })
     * 
    **/
    create<T extends tb_akun_dosenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_akun_dosenCreateArgs<ExtArgs>>
    ): Prisma__tb_akun_dosenClient<$Result.GetResult<Prisma.$tb_akun_dosenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tb_akun_dosens.
     *     @param {tb_akun_dosenCreateManyArgs} args - Arguments to create many Tb_akun_dosens.
     *     @example
     *     // Create many Tb_akun_dosens
     *     const tb_akun_dosen = await prisma.tb_akun_dosen.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tb_akun_dosenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_akun_dosenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_akun_dosen.
     * @param {tb_akun_dosenDeleteArgs} args - Arguments to delete one Tb_akun_dosen.
     * @example
     * // Delete one Tb_akun_dosen
     * const Tb_akun_dosen = await prisma.tb_akun_dosen.delete({
     *   where: {
     *     // ... filter to delete one Tb_akun_dosen
     *   }
     * })
     * 
    **/
    delete<T extends tb_akun_dosenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tb_akun_dosenDeleteArgs<ExtArgs>>
    ): Prisma__tb_akun_dosenClient<$Result.GetResult<Prisma.$tb_akun_dosenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tb_akun_dosen.
     * @param {tb_akun_dosenUpdateArgs} args - Arguments to update one Tb_akun_dosen.
     * @example
     * // Update one Tb_akun_dosen
     * const tb_akun_dosen = await prisma.tb_akun_dosen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tb_akun_dosenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_akun_dosenUpdateArgs<ExtArgs>>
    ): Prisma__tb_akun_dosenClient<$Result.GetResult<Prisma.$tb_akun_dosenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tb_akun_dosens.
     * @param {tb_akun_dosenDeleteManyArgs} args - Arguments to filter Tb_akun_dosens to delete.
     * @example
     * // Delete a few Tb_akun_dosens
     * const { count } = await prisma.tb_akun_dosen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tb_akun_dosenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_akun_dosenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_akun_dosens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_akun_dosenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_akun_dosens
     * const tb_akun_dosen = await prisma.tb_akun_dosen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tb_akun_dosenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tb_akun_dosenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_akun_dosen.
     * @param {tb_akun_dosenUpsertArgs} args - Arguments to update or create a Tb_akun_dosen.
     * @example
     * // Update or create a Tb_akun_dosen
     * const tb_akun_dosen = await prisma.tb_akun_dosen.upsert({
     *   create: {
     *     // ... data to create a Tb_akun_dosen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_akun_dosen we want to update
     *   }
     * })
    **/
    upsert<T extends tb_akun_dosenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tb_akun_dosenUpsertArgs<ExtArgs>>
    ): Prisma__tb_akun_dosenClient<$Result.GetResult<Prisma.$tb_akun_dosenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tb_akun_dosens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_akun_dosenCountArgs} args - Arguments to filter Tb_akun_dosens to count.
     * @example
     * // Count the number of Tb_akun_dosens
     * const count = await prisma.tb_akun_dosen.count({
     *   where: {
     *     // ... the filter for the Tb_akun_dosens we want to count
     *   }
     * })
    **/
    count<T extends tb_akun_dosenCountArgs>(
      args?: Subset<T, tb_akun_dosenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_akun_dosenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_akun_dosen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_akun_dosenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_akun_dosenAggregateArgs>(args: Subset<T, Tb_akun_dosenAggregateArgs>): Prisma.PrismaPromise<GetTb_akun_dosenAggregateType<T>>

    /**
     * Group by Tb_akun_dosen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_akun_dosenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_akun_dosenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_akun_dosenGroupByArgs['orderBy'] }
        : { orderBy?: tb_akun_dosenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_akun_dosenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_akun_dosenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_akun_dosen model
   */
  readonly fields: tb_akun_dosenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_akun_dosen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_akun_dosenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    fk_pemilik<T extends tb_dosenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tb_dosenDefaultArgs<ExtArgs>>): Prisma__tb_dosenClient<$Result.GetResult<Prisma.$tb_dosenPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    fk_username_role<T extends tb_akun_dosen$fk_username_roleArgs<ExtArgs> = {}>(args?: Subset<T, tb_akun_dosen$fk_username_roleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_role_akun_dosenPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tb_akun_dosen model
   */ 
  interface tb_akun_dosenFieldRefs {
    readonly username: FieldRef<"tb_akun_dosen", 'String'>
    readonly password: FieldRef<"tb_akun_dosen", 'String'>
    readonly status: FieldRef<"tb_akun_dosen", 'StatusAkun'>
    readonly pemilik: FieldRef<"tb_akun_dosen", 'String'>
  }
    

  // Custom InputTypes

  /**
   * tb_akun_dosen findUnique
   */
  export type tb_akun_dosenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_dosen
     */
    select?: tb_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_dosenInclude<ExtArgs> | null
    /**
     * Filter, which tb_akun_dosen to fetch.
     */
    where: tb_akun_dosenWhereUniqueInput
  }


  /**
   * tb_akun_dosen findUniqueOrThrow
   */
  export type tb_akun_dosenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_dosen
     */
    select?: tb_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_dosenInclude<ExtArgs> | null
    /**
     * Filter, which tb_akun_dosen to fetch.
     */
    where: tb_akun_dosenWhereUniqueInput
  }


  /**
   * tb_akun_dosen findFirst
   */
  export type tb_akun_dosenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_dosen
     */
    select?: tb_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_dosenInclude<ExtArgs> | null
    /**
     * Filter, which tb_akun_dosen to fetch.
     */
    where?: tb_akun_dosenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_akun_dosens to fetch.
     */
    orderBy?: tb_akun_dosenOrderByWithRelationInput | tb_akun_dosenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_akun_dosens.
     */
    cursor?: tb_akun_dosenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_akun_dosens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_akun_dosens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_akun_dosens.
     */
    distinct?: Tb_akun_dosenScalarFieldEnum | Tb_akun_dosenScalarFieldEnum[]
  }


  /**
   * tb_akun_dosen findFirstOrThrow
   */
  export type tb_akun_dosenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_dosen
     */
    select?: tb_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_dosenInclude<ExtArgs> | null
    /**
     * Filter, which tb_akun_dosen to fetch.
     */
    where?: tb_akun_dosenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_akun_dosens to fetch.
     */
    orderBy?: tb_akun_dosenOrderByWithRelationInput | tb_akun_dosenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_akun_dosens.
     */
    cursor?: tb_akun_dosenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_akun_dosens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_akun_dosens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_akun_dosens.
     */
    distinct?: Tb_akun_dosenScalarFieldEnum | Tb_akun_dosenScalarFieldEnum[]
  }


  /**
   * tb_akun_dosen findMany
   */
  export type tb_akun_dosenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_dosen
     */
    select?: tb_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_dosenInclude<ExtArgs> | null
    /**
     * Filter, which tb_akun_dosens to fetch.
     */
    where?: tb_akun_dosenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_akun_dosens to fetch.
     */
    orderBy?: tb_akun_dosenOrderByWithRelationInput | tb_akun_dosenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_akun_dosens.
     */
    cursor?: tb_akun_dosenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_akun_dosens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_akun_dosens.
     */
    skip?: number
    distinct?: Tb_akun_dosenScalarFieldEnum | Tb_akun_dosenScalarFieldEnum[]
  }


  /**
   * tb_akun_dosen create
   */
  export type tb_akun_dosenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_dosen
     */
    select?: tb_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_dosenInclude<ExtArgs> | null
    /**
     * The data needed to create a tb_akun_dosen.
     */
    data: XOR<tb_akun_dosenCreateInput, tb_akun_dosenUncheckedCreateInput>
  }


  /**
   * tb_akun_dosen createMany
   */
  export type tb_akun_dosenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_akun_dosens.
     */
    data: tb_akun_dosenCreateManyInput | tb_akun_dosenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tb_akun_dosen update
   */
  export type tb_akun_dosenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_dosen
     */
    select?: tb_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_dosenInclude<ExtArgs> | null
    /**
     * The data needed to update a tb_akun_dosen.
     */
    data: XOR<tb_akun_dosenUpdateInput, tb_akun_dosenUncheckedUpdateInput>
    /**
     * Choose, which tb_akun_dosen to update.
     */
    where: tb_akun_dosenWhereUniqueInput
  }


  /**
   * tb_akun_dosen updateMany
   */
  export type tb_akun_dosenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_akun_dosens.
     */
    data: XOR<tb_akun_dosenUpdateManyMutationInput, tb_akun_dosenUncheckedUpdateManyInput>
    /**
     * Filter which tb_akun_dosens to update
     */
    where?: tb_akun_dosenWhereInput
  }


  /**
   * tb_akun_dosen upsert
   */
  export type tb_akun_dosenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_dosen
     */
    select?: tb_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_dosenInclude<ExtArgs> | null
    /**
     * The filter to search for the tb_akun_dosen to update in case it exists.
     */
    where: tb_akun_dosenWhereUniqueInput
    /**
     * In case the tb_akun_dosen found by the `where` argument doesn't exist, create a new tb_akun_dosen with this data.
     */
    create: XOR<tb_akun_dosenCreateInput, tb_akun_dosenUncheckedCreateInput>
    /**
     * In case the tb_akun_dosen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_akun_dosenUpdateInput, tb_akun_dosenUncheckedUpdateInput>
  }


  /**
   * tb_akun_dosen delete
   */
  export type tb_akun_dosenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_dosen
     */
    select?: tb_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_dosenInclude<ExtArgs> | null
    /**
     * Filter which tb_akun_dosen to delete.
     */
    where: tb_akun_dosenWhereUniqueInput
  }


  /**
   * tb_akun_dosen deleteMany
   */
  export type tb_akun_dosenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_akun_dosens to delete
     */
    where?: tb_akun_dosenWhereInput
  }


  /**
   * tb_akun_dosen.fk_username_role
   */
  export type tb_akun_dosen$fk_username_roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role_akun_dosen
     */
    select?: tb_role_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_role_akun_dosenInclude<ExtArgs> | null
    where?: tb_role_akun_dosenWhereInput
    orderBy?: tb_role_akun_dosenOrderByWithRelationInput | tb_role_akun_dosenOrderByWithRelationInput[]
    cursor?: tb_role_akun_dosenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tb_role_akun_dosenScalarFieldEnum | Tb_role_akun_dosenScalarFieldEnum[]
  }


  /**
   * tb_akun_dosen without action
   */
  export type tb_akun_dosenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_akun_dosen
     */
    select?: tb_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_akun_dosenInclude<ExtArgs> | null
  }



  /**
   * Model tb_role_akun_dosen
   */

  export type AggregateTb_role_akun_dosen = {
    _count: Tb_role_akun_dosenCountAggregateOutputType | null
    _min: Tb_role_akun_dosenMinAggregateOutputType | null
    _max: Tb_role_akun_dosenMaxAggregateOutputType | null
  }

  export type Tb_role_akun_dosenMinAggregateOutputType = {
    username: string | null
    role: $Enums.Role | null
  }

  export type Tb_role_akun_dosenMaxAggregateOutputType = {
    username: string | null
    role: $Enums.Role | null
  }

  export type Tb_role_akun_dosenCountAggregateOutputType = {
    username: number
    role: number
    _all: number
  }


  export type Tb_role_akun_dosenMinAggregateInputType = {
    username?: true
    role?: true
  }

  export type Tb_role_akun_dosenMaxAggregateInputType = {
    username?: true
    role?: true
  }

  export type Tb_role_akun_dosenCountAggregateInputType = {
    username?: true
    role?: true
    _all?: true
  }

  export type Tb_role_akun_dosenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_role_akun_dosen to aggregate.
     */
    where?: tb_role_akun_dosenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_role_akun_dosens to fetch.
     */
    orderBy?: tb_role_akun_dosenOrderByWithRelationInput | tb_role_akun_dosenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_role_akun_dosenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_role_akun_dosens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_role_akun_dosens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_role_akun_dosens
    **/
    _count?: true | Tb_role_akun_dosenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_role_akun_dosenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_role_akun_dosenMaxAggregateInputType
  }

  export type GetTb_role_akun_dosenAggregateType<T extends Tb_role_akun_dosenAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_role_akun_dosen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_role_akun_dosen[P]>
      : GetScalarType<T[P], AggregateTb_role_akun_dosen[P]>
  }




  export type tb_role_akun_dosenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_role_akun_dosenWhereInput
    orderBy?: tb_role_akun_dosenOrderByWithAggregationInput | tb_role_akun_dosenOrderByWithAggregationInput[]
    by: Tb_role_akun_dosenScalarFieldEnum[] | Tb_role_akun_dosenScalarFieldEnum
    having?: tb_role_akun_dosenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_role_akun_dosenCountAggregateInputType | true
    _min?: Tb_role_akun_dosenMinAggregateInputType
    _max?: Tb_role_akun_dosenMaxAggregateInputType
  }

  export type Tb_role_akun_dosenGroupByOutputType = {
    username: string
    role: $Enums.Role
    _count: Tb_role_akun_dosenCountAggregateOutputType | null
    _min: Tb_role_akun_dosenMinAggregateOutputType | null
    _max: Tb_role_akun_dosenMaxAggregateOutputType | null
  }

  type GetTb_role_akun_dosenGroupByPayload<T extends tb_role_akun_dosenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_role_akun_dosenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_role_akun_dosenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_role_akun_dosenGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_role_akun_dosenGroupByOutputType[P]>
        }
      >
    >


  export type tb_role_akun_dosenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    username?: boolean
    role?: boolean
    fk_username?: boolean | tb_akun_dosenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tb_role_akun_dosen"]>

  export type tb_role_akun_dosenSelectScalar = {
    username?: boolean
    role?: boolean
  }

  export type tb_role_akun_dosenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fk_username?: boolean | tb_akun_dosenDefaultArgs<ExtArgs>
  }


  export type $tb_role_akun_dosenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_role_akun_dosen"
    objects: {
      fk_username: Prisma.$tb_akun_dosenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      username: string
      role: $Enums.Role
    }, ExtArgs["result"]["tb_role_akun_dosen"]>
    composites: {}
  }


  type tb_role_akun_dosenGetPayload<S extends boolean | null | undefined | tb_role_akun_dosenDefaultArgs> = $Result.GetResult<Prisma.$tb_role_akun_dosenPayload, S>

  type tb_role_akun_dosenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tb_role_akun_dosenFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Tb_role_akun_dosenCountAggregateInputType | true
    }

  export interface tb_role_akun_dosenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_role_akun_dosen'], meta: { name: 'tb_role_akun_dosen' } }
    /**
     * Find zero or one Tb_role_akun_dosen that matches the filter.
     * @param {tb_role_akun_dosenFindUniqueArgs} args - Arguments to find a Tb_role_akun_dosen
     * @example
     * // Get one Tb_role_akun_dosen
     * const tb_role_akun_dosen = await prisma.tb_role_akun_dosen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tb_role_akun_dosenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tb_role_akun_dosenFindUniqueArgs<ExtArgs>>
    ): Prisma__tb_role_akun_dosenClient<$Result.GetResult<Prisma.$tb_role_akun_dosenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tb_role_akun_dosen that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tb_role_akun_dosenFindUniqueOrThrowArgs} args - Arguments to find a Tb_role_akun_dosen
     * @example
     * // Get one Tb_role_akun_dosen
     * const tb_role_akun_dosen = await prisma.tb_role_akun_dosen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tb_role_akun_dosenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_role_akun_dosenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tb_role_akun_dosenClient<$Result.GetResult<Prisma.$tb_role_akun_dosenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tb_role_akun_dosen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_role_akun_dosenFindFirstArgs} args - Arguments to find a Tb_role_akun_dosen
     * @example
     * // Get one Tb_role_akun_dosen
     * const tb_role_akun_dosen = await prisma.tb_role_akun_dosen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tb_role_akun_dosenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_role_akun_dosenFindFirstArgs<ExtArgs>>
    ): Prisma__tb_role_akun_dosenClient<$Result.GetResult<Prisma.$tb_role_akun_dosenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tb_role_akun_dosen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_role_akun_dosenFindFirstOrThrowArgs} args - Arguments to find a Tb_role_akun_dosen
     * @example
     * // Get one Tb_role_akun_dosen
     * const tb_role_akun_dosen = await prisma.tb_role_akun_dosen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tb_role_akun_dosenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_role_akun_dosenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tb_role_akun_dosenClient<$Result.GetResult<Prisma.$tb_role_akun_dosenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tb_role_akun_dosens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_role_akun_dosenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_role_akun_dosens
     * const tb_role_akun_dosens = await prisma.tb_role_akun_dosen.findMany()
     * 
     * // Get first 10 Tb_role_akun_dosens
     * const tb_role_akun_dosens = await prisma.tb_role_akun_dosen.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const tb_role_akun_dosenWithUsernameOnly = await prisma.tb_role_akun_dosen.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends tb_role_akun_dosenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_role_akun_dosenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_role_akun_dosenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tb_role_akun_dosen.
     * @param {tb_role_akun_dosenCreateArgs} args - Arguments to create a Tb_role_akun_dosen.
     * @example
     * // Create one Tb_role_akun_dosen
     * const Tb_role_akun_dosen = await prisma.tb_role_akun_dosen.create({
     *   data: {
     *     // ... data to create a Tb_role_akun_dosen
     *   }
     * })
     * 
    **/
    create<T extends tb_role_akun_dosenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_role_akun_dosenCreateArgs<ExtArgs>>
    ): Prisma__tb_role_akun_dosenClient<$Result.GetResult<Prisma.$tb_role_akun_dosenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tb_role_akun_dosens.
     *     @param {tb_role_akun_dosenCreateManyArgs} args - Arguments to create many Tb_role_akun_dosens.
     *     @example
     *     // Create many Tb_role_akun_dosens
     *     const tb_role_akun_dosen = await prisma.tb_role_akun_dosen.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tb_role_akun_dosenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_role_akun_dosenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_role_akun_dosen.
     * @param {tb_role_akun_dosenDeleteArgs} args - Arguments to delete one Tb_role_akun_dosen.
     * @example
     * // Delete one Tb_role_akun_dosen
     * const Tb_role_akun_dosen = await prisma.tb_role_akun_dosen.delete({
     *   where: {
     *     // ... filter to delete one Tb_role_akun_dosen
     *   }
     * })
     * 
    **/
    delete<T extends tb_role_akun_dosenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tb_role_akun_dosenDeleteArgs<ExtArgs>>
    ): Prisma__tb_role_akun_dosenClient<$Result.GetResult<Prisma.$tb_role_akun_dosenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tb_role_akun_dosen.
     * @param {tb_role_akun_dosenUpdateArgs} args - Arguments to update one Tb_role_akun_dosen.
     * @example
     * // Update one Tb_role_akun_dosen
     * const tb_role_akun_dosen = await prisma.tb_role_akun_dosen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tb_role_akun_dosenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tb_role_akun_dosenUpdateArgs<ExtArgs>>
    ): Prisma__tb_role_akun_dosenClient<$Result.GetResult<Prisma.$tb_role_akun_dosenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tb_role_akun_dosens.
     * @param {tb_role_akun_dosenDeleteManyArgs} args - Arguments to filter Tb_role_akun_dosens to delete.
     * @example
     * // Delete a few Tb_role_akun_dosens
     * const { count } = await prisma.tb_role_akun_dosen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tb_role_akun_dosenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tb_role_akun_dosenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_role_akun_dosens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_role_akun_dosenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_role_akun_dosens
     * const tb_role_akun_dosen = await prisma.tb_role_akun_dosen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tb_role_akun_dosenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tb_role_akun_dosenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_role_akun_dosen.
     * @param {tb_role_akun_dosenUpsertArgs} args - Arguments to update or create a Tb_role_akun_dosen.
     * @example
     * // Update or create a Tb_role_akun_dosen
     * const tb_role_akun_dosen = await prisma.tb_role_akun_dosen.upsert({
     *   create: {
     *     // ... data to create a Tb_role_akun_dosen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_role_akun_dosen we want to update
     *   }
     * })
    **/
    upsert<T extends tb_role_akun_dosenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tb_role_akun_dosenUpsertArgs<ExtArgs>>
    ): Prisma__tb_role_akun_dosenClient<$Result.GetResult<Prisma.$tb_role_akun_dosenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tb_role_akun_dosens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_role_akun_dosenCountArgs} args - Arguments to filter Tb_role_akun_dosens to count.
     * @example
     * // Count the number of Tb_role_akun_dosens
     * const count = await prisma.tb_role_akun_dosen.count({
     *   where: {
     *     // ... the filter for the Tb_role_akun_dosens we want to count
     *   }
     * })
    **/
    count<T extends tb_role_akun_dosenCountArgs>(
      args?: Subset<T, tb_role_akun_dosenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_role_akun_dosenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_role_akun_dosen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_role_akun_dosenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_role_akun_dosenAggregateArgs>(args: Subset<T, Tb_role_akun_dosenAggregateArgs>): Prisma.PrismaPromise<GetTb_role_akun_dosenAggregateType<T>>

    /**
     * Group by Tb_role_akun_dosen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_role_akun_dosenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_role_akun_dosenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_role_akun_dosenGroupByArgs['orderBy'] }
        : { orderBy?: tb_role_akun_dosenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_role_akun_dosenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_role_akun_dosenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_role_akun_dosen model
   */
  readonly fields: tb_role_akun_dosenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_role_akun_dosen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_role_akun_dosenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    fk_username<T extends tb_akun_dosenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tb_akun_dosenDefaultArgs<ExtArgs>>): Prisma__tb_akun_dosenClient<$Result.GetResult<Prisma.$tb_akun_dosenPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tb_role_akun_dosen model
   */ 
  interface tb_role_akun_dosenFieldRefs {
    readonly username: FieldRef<"tb_role_akun_dosen", 'String'>
    readonly role: FieldRef<"tb_role_akun_dosen", 'Role'>
  }
    

  // Custom InputTypes

  /**
   * tb_role_akun_dosen findUnique
   */
  export type tb_role_akun_dosenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role_akun_dosen
     */
    select?: tb_role_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_role_akun_dosenInclude<ExtArgs> | null
    /**
     * Filter, which tb_role_akun_dosen to fetch.
     */
    where: tb_role_akun_dosenWhereUniqueInput
  }


  /**
   * tb_role_akun_dosen findUniqueOrThrow
   */
  export type tb_role_akun_dosenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role_akun_dosen
     */
    select?: tb_role_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_role_akun_dosenInclude<ExtArgs> | null
    /**
     * Filter, which tb_role_akun_dosen to fetch.
     */
    where: tb_role_akun_dosenWhereUniqueInput
  }


  /**
   * tb_role_akun_dosen findFirst
   */
  export type tb_role_akun_dosenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role_akun_dosen
     */
    select?: tb_role_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_role_akun_dosenInclude<ExtArgs> | null
    /**
     * Filter, which tb_role_akun_dosen to fetch.
     */
    where?: tb_role_akun_dosenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_role_akun_dosens to fetch.
     */
    orderBy?: tb_role_akun_dosenOrderByWithRelationInput | tb_role_akun_dosenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_role_akun_dosens.
     */
    cursor?: tb_role_akun_dosenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_role_akun_dosens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_role_akun_dosens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_role_akun_dosens.
     */
    distinct?: Tb_role_akun_dosenScalarFieldEnum | Tb_role_akun_dosenScalarFieldEnum[]
  }


  /**
   * tb_role_akun_dosen findFirstOrThrow
   */
  export type tb_role_akun_dosenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role_akun_dosen
     */
    select?: tb_role_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_role_akun_dosenInclude<ExtArgs> | null
    /**
     * Filter, which tb_role_akun_dosen to fetch.
     */
    where?: tb_role_akun_dosenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_role_akun_dosens to fetch.
     */
    orderBy?: tb_role_akun_dosenOrderByWithRelationInput | tb_role_akun_dosenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_role_akun_dosens.
     */
    cursor?: tb_role_akun_dosenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_role_akun_dosens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_role_akun_dosens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_role_akun_dosens.
     */
    distinct?: Tb_role_akun_dosenScalarFieldEnum | Tb_role_akun_dosenScalarFieldEnum[]
  }


  /**
   * tb_role_akun_dosen findMany
   */
  export type tb_role_akun_dosenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role_akun_dosen
     */
    select?: tb_role_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_role_akun_dosenInclude<ExtArgs> | null
    /**
     * Filter, which tb_role_akun_dosens to fetch.
     */
    where?: tb_role_akun_dosenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_role_akun_dosens to fetch.
     */
    orderBy?: tb_role_akun_dosenOrderByWithRelationInput | tb_role_akun_dosenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_role_akun_dosens.
     */
    cursor?: tb_role_akun_dosenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_role_akun_dosens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_role_akun_dosens.
     */
    skip?: number
    distinct?: Tb_role_akun_dosenScalarFieldEnum | Tb_role_akun_dosenScalarFieldEnum[]
  }


  /**
   * tb_role_akun_dosen create
   */
  export type tb_role_akun_dosenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role_akun_dosen
     */
    select?: tb_role_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_role_akun_dosenInclude<ExtArgs> | null
    /**
     * The data needed to create a tb_role_akun_dosen.
     */
    data: XOR<tb_role_akun_dosenCreateInput, tb_role_akun_dosenUncheckedCreateInput>
  }


  /**
   * tb_role_akun_dosen createMany
   */
  export type tb_role_akun_dosenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_role_akun_dosens.
     */
    data: tb_role_akun_dosenCreateManyInput | tb_role_akun_dosenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tb_role_akun_dosen update
   */
  export type tb_role_akun_dosenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role_akun_dosen
     */
    select?: tb_role_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_role_akun_dosenInclude<ExtArgs> | null
    /**
     * The data needed to update a tb_role_akun_dosen.
     */
    data: XOR<tb_role_akun_dosenUpdateInput, tb_role_akun_dosenUncheckedUpdateInput>
    /**
     * Choose, which tb_role_akun_dosen to update.
     */
    where: tb_role_akun_dosenWhereUniqueInput
  }


  /**
   * tb_role_akun_dosen updateMany
   */
  export type tb_role_akun_dosenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_role_akun_dosens.
     */
    data: XOR<tb_role_akun_dosenUpdateManyMutationInput, tb_role_akun_dosenUncheckedUpdateManyInput>
    /**
     * Filter which tb_role_akun_dosens to update
     */
    where?: tb_role_akun_dosenWhereInput
  }


  /**
   * tb_role_akun_dosen upsert
   */
  export type tb_role_akun_dosenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role_akun_dosen
     */
    select?: tb_role_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_role_akun_dosenInclude<ExtArgs> | null
    /**
     * The filter to search for the tb_role_akun_dosen to update in case it exists.
     */
    where: tb_role_akun_dosenWhereUniqueInput
    /**
     * In case the tb_role_akun_dosen found by the `where` argument doesn't exist, create a new tb_role_akun_dosen with this data.
     */
    create: XOR<tb_role_akun_dosenCreateInput, tb_role_akun_dosenUncheckedCreateInput>
    /**
     * In case the tb_role_akun_dosen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_role_akun_dosenUpdateInput, tb_role_akun_dosenUncheckedUpdateInput>
  }


  /**
   * tb_role_akun_dosen delete
   */
  export type tb_role_akun_dosenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role_akun_dosen
     */
    select?: tb_role_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_role_akun_dosenInclude<ExtArgs> | null
    /**
     * Filter which tb_role_akun_dosen to delete.
     */
    where: tb_role_akun_dosenWhereUniqueInput
  }


  /**
   * tb_role_akun_dosen deleteMany
   */
  export type tb_role_akun_dosenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_role_akun_dosens to delete
     */
    where?: tb_role_akun_dosenWhereInput
  }


  /**
   * tb_role_akun_dosen without action
   */
  export type tb_role_akun_dosenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role_akun_dosen
     */
    select?: tb_role_akun_dosenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tb_role_akun_dosenInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Tb_mhsScalarFieldEnum: {
    nim: 'nim',
    nama: 'nama',
    statusAktif: 'statusAktif',
    alamat: 'alamat',
    email: 'email',
    kodeKab: 'kodeKab',
    kodeProv: 'kodeProv',
    jalurMasuk: 'jalurMasuk',
    angkatan: 'angkatan',
    noHP: 'noHP',
    kodeWali: 'kodeWali',
    foto: 'foto'
  };

  export type Tb_mhsScalarFieldEnum = (typeof Tb_mhsScalarFieldEnum)[keyof typeof Tb_mhsScalarFieldEnum]


  export const Tb_dosenScalarFieldEnum: {
    nip: 'nip',
    nama: 'nama',
    alamat: 'alamat',
    email: 'email',
    kodeKab: 'kodeKab',
    kodeProv: 'kodeProv',
    noHP: 'noHP',
    foto: 'foto'
  };

  export type Tb_dosenScalarFieldEnum = (typeof Tb_dosenScalarFieldEnum)[keyof typeof Tb_dosenScalarFieldEnum]


  export const Tb_irsScalarFieldEnum: {
    nim: 'nim',
    semester: 'semester',
    status: 'status',
    jumlahSks: 'jumlahSks',
    fileIrs: 'fileIrs',
    statusValidasi: 'statusValidasi'
  };

  export type Tb_irsScalarFieldEnum = (typeof Tb_irsScalarFieldEnum)[keyof typeof Tb_irsScalarFieldEnum]


  export const Tb_khsScalarFieldEnum: {
    nim: 'nim',
    semester: 'semester',
    status: 'status',
    jumlahSksSemester: 'jumlahSksSemester',
    ips: 'ips',
    jumlahSksKumulatif: 'jumlahSksKumulatif',
    ipk: 'ipk',
    fileKhs: 'fileKhs',
    statusValidasi: 'statusValidasi'
  };

  export type Tb_khsScalarFieldEnum = (typeof Tb_khsScalarFieldEnum)[keyof typeof Tb_khsScalarFieldEnum]


  export const Tb_pklScalarFieldEnum: {
    nim: 'nim',
    semester: 'semester',
    nilai: 'nilai',
    filePkl: 'filePkl',
    statusValidasi: 'statusValidasi'
  };

  export type Tb_pklScalarFieldEnum = (typeof Tb_pklScalarFieldEnum)[keyof typeof Tb_pklScalarFieldEnum]


  export const Tb_skripsiScalarFieldEnum: {
    nim: 'nim',
    semester: 'semester',
    nilai: 'nilai',
    tanggalLulusSidang: 'tanggalLulusSidang',
    lamaStudi: 'lamaStudi',
    fileSkripsi: 'fileSkripsi',
    statusValidasi: 'statusValidasi'
  };

  export type Tb_skripsiScalarFieldEnum = (typeof Tb_skripsiScalarFieldEnum)[keyof typeof Tb_skripsiScalarFieldEnum]


  export const Tb_provinsiScalarFieldEnum: {
    kodeProv: 'kodeProv',
    namaProv: 'namaProv'
  };

  export type Tb_provinsiScalarFieldEnum = (typeof Tb_provinsiScalarFieldEnum)[keyof typeof Tb_provinsiScalarFieldEnum]


  export const Tb_kabupatenScalarFieldEnum: {
    kodeKab: 'kodeKab',
    namaKab: 'namaKab',
    kodeProv: 'kodeProv'
  };

  export type Tb_kabupatenScalarFieldEnum = (typeof Tb_kabupatenScalarFieldEnum)[keyof typeof Tb_kabupatenScalarFieldEnum]


  export const Tb_akun_mhsScalarFieldEnum: {
    username: 'username',
    password: 'password',
    status: 'status',
    pemilik: 'pemilik'
  };

  export type Tb_akun_mhsScalarFieldEnum = (typeof Tb_akun_mhsScalarFieldEnum)[keyof typeof Tb_akun_mhsScalarFieldEnum]


  export const Tb_akun_dosenScalarFieldEnum: {
    username: 'username',
    password: 'password',
    status: 'status',
    pemilik: 'pemilik'
  };

  export type Tb_akun_dosenScalarFieldEnum = (typeof Tb_akun_dosenScalarFieldEnum)[keyof typeof Tb_akun_dosenScalarFieldEnum]


  export const Tb_role_akun_dosenScalarFieldEnum: {
    username: 'username',
    role: 'role'
  };

  export type Tb_role_akun_dosenScalarFieldEnum = (typeof Tb_role_akun_dosenScalarFieldEnum)[keyof typeof Tb_role_akun_dosenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'StatusMhs'
   */
  export type EnumStatusMhsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusMhs'>
    


  /**
   * Reference to a field of type 'StatusMhs[]'
   */
  export type ListEnumStatusMhsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusMhs[]'>
    


  /**
   * Reference to a field of type 'JalurMasuk'
   */
  export type EnumJalurMasukFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JalurMasuk'>
    


  /**
   * Reference to a field of type 'JalurMasuk[]'
   */
  export type ListEnumJalurMasukFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JalurMasuk[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'StatusAktif'
   */
  export type EnumStatusAktifFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusAktif'>
    


  /**
   * Reference to a field of type 'StatusAktif[]'
   */
  export type ListEnumStatusAktifFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusAktif[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'StatusAkun'
   */
  export type EnumStatusAkunFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusAkun'>
    


  /**
   * Reference to a field of type 'StatusAkun[]'
   */
  export type ListEnumStatusAkunFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusAkun[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type tb_mhsWhereInput = {
    AND?: tb_mhsWhereInput | tb_mhsWhereInput[]
    OR?: tb_mhsWhereInput[]
    NOT?: tb_mhsWhereInput | tb_mhsWhereInput[]
    nim?: StringFilter<"tb_mhs"> | string
    nama?: StringFilter<"tb_mhs"> | string
    statusAktif?: EnumStatusMhsFilter<"tb_mhs"> | $Enums.StatusMhs
    alamat?: StringNullableFilter<"tb_mhs"> | string | null
    email?: StringNullableFilter<"tb_mhs"> | string | null
    kodeKab?: StringNullableFilter<"tb_mhs"> | string | null
    kodeProv?: StringNullableFilter<"tb_mhs"> | string | null
    jalurMasuk?: EnumJalurMasukFilter<"tb_mhs"> | $Enums.JalurMasuk
    angkatan?: IntFilter<"tb_mhs"> | number
    noHP?: StringNullableFilter<"tb_mhs"> | string | null
    kodeWali?: StringFilter<"tb_mhs"> | string
    foto?: StringNullableFilter<"tb_mhs"> | string | null
    fk_kodeKab?: XOR<Tb_kabupatenNullableRelationFilter, tb_kabupatenWhereInput> | null
    fk_kodeProv?: XOR<Tb_provinsiNullableRelationFilter, tb_provinsiWhereInput> | null
    fk_kodeWali?: XOR<Tb_dosenRelationFilter, tb_dosenWhereInput>
    fk_nim_irs?: Tb_irsListRelationFilter
    fk_nim_khs?: Tb_khsListRelationFilter
    fk_nim_pkl?: Tb_pklListRelationFilter
    fk_nim_skripsi?: Tb_skripsiListRelationFilter
    fk_pemilik_akun_mhs?: XOR<Tb_akun_mhsNullableRelationFilter, tb_akun_mhsWhereInput> | null
  }

  export type tb_mhsOrderByWithRelationInput = {
    nim?: SortOrder
    nama?: SortOrder
    statusAktif?: SortOrder
    alamat?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    kodeKab?: SortOrderInput | SortOrder
    kodeProv?: SortOrderInput | SortOrder
    jalurMasuk?: SortOrder
    angkatan?: SortOrder
    noHP?: SortOrderInput | SortOrder
    kodeWali?: SortOrder
    foto?: SortOrderInput | SortOrder
    fk_kodeKab?: tb_kabupatenOrderByWithRelationInput
    fk_kodeProv?: tb_provinsiOrderByWithRelationInput
    fk_kodeWali?: tb_dosenOrderByWithRelationInput
    fk_nim_irs?: tb_irsOrderByRelationAggregateInput
    fk_nim_khs?: tb_khsOrderByRelationAggregateInput
    fk_nim_pkl?: tb_pklOrderByRelationAggregateInput
    fk_nim_skripsi?: tb_skripsiOrderByRelationAggregateInput
    fk_pemilik_akun_mhs?: tb_akun_mhsOrderByWithRelationInput
  }

  export type tb_mhsWhereUniqueInput = Prisma.AtLeast<{
    nim?: string
    AND?: tb_mhsWhereInput | tb_mhsWhereInput[]
    OR?: tb_mhsWhereInput[]
    NOT?: tb_mhsWhereInput | tb_mhsWhereInput[]
    nama?: StringFilter<"tb_mhs"> | string
    statusAktif?: EnumStatusMhsFilter<"tb_mhs"> | $Enums.StatusMhs
    alamat?: StringNullableFilter<"tb_mhs"> | string | null
    email?: StringNullableFilter<"tb_mhs"> | string | null
    kodeKab?: StringNullableFilter<"tb_mhs"> | string | null
    kodeProv?: StringNullableFilter<"tb_mhs"> | string | null
    jalurMasuk?: EnumJalurMasukFilter<"tb_mhs"> | $Enums.JalurMasuk
    angkatan?: IntFilter<"tb_mhs"> | number
    noHP?: StringNullableFilter<"tb_mhs"> | string | null
    kodeWali?: StringFilter<"tb_mhs"> | string
    foto?: StringNullableFilter<"tb_mhs"> | string | null
    fk_kodeKab?: XOR<Tb_kabupatenNullableRelationFilter, tb_kabupatenWhereInput> | null
    fk_kodeProv?: XOR<Tb_provinsiNullableRelationFilter, tb_provinsiWhereInput> | null
    fk_kodeWali?: XOR<Tb_dosenRelationFilter, tb_dosenWhereInput>
    fk_nim_irs?: Tb_irsListRelationFilter
    fk_nim_khs?: Tb_khsListRelationFilter
    fk_nim_pkl?: Tb_pklListRelationFilter
    fk_nim_skripsi?: Tb_skripsiListRelationFilter
    fk_pemilik_akun_mhs?: XOR<Tb_akun_mhsNullableRelationFilter, tb_akun_mhsWhereInput> | null
  }, "nim" | "nim">

  export type tb_mhsOrderByWithAggregationInput = {
    nim?: SortOrder
    nama?: SortOrder
    statusAktif?: SortOrder
    alamat?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    kodeKab?: SortOrderInput | SortOrder
    kodeProv?: SortOrderInput | SortOrder
    jalurMasuk?: SortOrder
    angkatan?: SortOrder
    noHP?: SortOrderInput | SortOrder
    kodeWali?: SortOrder
    foto?: SortOrderInput | SortOrder
    _count?: tb_mhsCountOrderByAggregateInput
    _avg?: tb_mhsAvgOrderByAggregateInput
    _max?: tb_mhsMaxOrderByAggregateInput
    _min?: tb_mhsMinOrderByAggregateInput
    _sum?: tb_mhsSumOrderByAggregateInput
  }

  export type tb_mhsScalarWhereWithAggregatesInput = {
    AND?: tb_mhsScalarWhereWithAggregatesInput | tb_mhsScalarWhereWithAggregatesInput[]
    OR?: tb_mhsScalarWhereWithAggregatesInput[]
    NOT?: tb_mhsScalarWhereWithAggregatesInput | tb_mhsScalarWhereWithAggregatesInput[]
    nim?: StringWithAggregatesFilter<"tb_mhs"> | string
    nama?: StringWithAggregatesFilter<"tb_mhs"> | string
    statusAktif?: EnumStatusMhsWithAggregatesFilter<"tb_mhs"> | $Enums.StatusMhs
    alamat?: StringNullableWithAggregatesFilter<"tb_mhs"> | string | null
    email?: StringNullableWithAggregatesFilter<"tb_mhs"> | string | null
    kodeKab?: StringNullableWithAggregatesFilter<"tb_mhs"> | string | null
    kodeProv?: StringNullableWithAggregatesFilter<"tb_mhs"> | string | null
    jalurMasuk?: EnumJalurMasukWithAggregatesFilter<"tb_mhs"> | $Enums.JalurMasuk
    angkatan?: IntWithAggregatesFilter<"tb_mhs"> | number
    noHP?: StringNullableWithAggregatesFilter<"tb_mhs"> | string | null
    kodeWali?: StringWithAggregatesFilter<"tb_mhs"> | string
    foto?: StringNullableWithAggregatesFilter<"tb_mhs"> | string | null
  }

  export type tb_dosenWhereInput = {
    AND?: tb_dosenWhereInput | tb_dosenWhereInput[]
    OR?: tb_dosenWhereInput[]
    NOT?: tb_dosenWhereInput | tb_dosenWhereInput[]
    nip?: StringFilter<"tb_dosen"> | string
    nama?: StringFilter<"tb_dosen"> | string
    alamat?: StringNullableFilter<"tb_dosen"> | string | null
    email?: StringNullableFilter<"tb_dosen"> | string | null
    kodeKab?: StringNullableFilter<"tb_dosen"> | string | null
    kodeProv?: StringNullableFilter<"tb_dosen"> | string | null
    noHP?: StringNullableFilter<"tb_dosen"> | string | null
    foto?: StringNullableFilter<"tb_dosen"> | string | null
    fk_kodeKab?: XOR<Tb_kabupatenNullableRelationFilter, tb_kabupatenWhereInput> | null
    fk_kodeProv?: XOR<Tb_provinsiNullableRelationFilter, tb_provinsiWhereInput> | null
    fk_kodeWali_mhs?: Tb_mhsListRelationFilter
    fk_pemilik_akun_dosen?: XOR<Tb_akun_dosenNullableRelationFilter, tb_akun_dosenWhereInput> | null
  }

  export type tb_dosenOrderByWithRelationInput = {
    nip?: SortOrder
    nama?: SortOrder
    alamat?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    kodeKab?: SortOrderInput | SortOrder
    kodeProv?: SortOrderInput | SortOrder
    noHP?: SortOrderInput | SortOrder
    foto?: SortOrderInput | SortOrder
    fk_kodeKab?: tb_kabupatenOrderByWithRelationInput
    fk_kodeProv?: tb_provinsiOrderByWithRelationInput
    fk_kodeWali_mhs?: tb_mhsOrderByRelationAggregateInput
    fk_pemilik_akun_dosen?: tb_akun_dosenOrderByWithRelationInput
  }

  export type tb_dosenWhereUniqueInput = Prisma.AtLeast<{
    nip?: string
    AND?: tb_dosenWhereInput | tb_dosenWhereInput[]
    OR?: tb_dosenWhereInput[]
    NOT?: tb_dosenWhereInput | tb_dosenWhereInput[]
    nama?: StringFilter<"tb_dosen"> | string
    alamat?: StringNullableFilter<"tb_dosen"> | string | null
    email?: StringNullableFilter<"tb_dosen"> | string | null
    kodeKab?: StringNullableFilter<"tb_dosen"> | string | null
    kodeProv?: StringNullableFilter<"tb_dosen"> | string | null
    noHP?: StringNullableFilter<"tb_dosen"> | string | null
    foto?: StringNullableFilter<"tb_dosen"> | string | null
    fk_kodeKab?: XOR<Tb_kabupatenNullableRelationFilter, tb_kabupatenWhereInput> | null
    fk_kodeProv?: XOR<Tb_provinsiNullableRelationFilter, tb_provinsiWhereInput> | null
    fk_kodeWali_mhs?: Tb_mhsListRelationFilter
    fk_pemilik_akun_dosen?: XOR<Tb_akun_dosenNullableRelationFilter, tb_akun_dosenWhereInput> | null
  }, "nip" | "nip">

  export type tb_dosenOrderByWithAggregationInput = {
    nip?: SortOrder
    nama?: SortOrder
    alamat?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    kodeKab?: SortOrderInput | SortOrder
    kodeProv?: SortOrderInput | SortOrder
    noHP?: SortOrderInput | SortOrder
    foto?: SortOrderInput | SortOrder
    _count?: tb_dosenCountOrderByAggregateInput
    _max?: tb_dosenMaxOrderByAggregateInput
    _min?: tb_dosenMinOrderByAggregateInput
  }

  export type tb_dosenScalarWhereWithAggregatesInput = {
    AND?: tb_dosenScalarWhereWithAggregatesInput | tb_dosenScalarWhereWithAggregatesInput[]
    OR?: tb_dosenScalarWhereWithAggregatesInput[]
    NOT?: tb_dosenScalarWhereWithAggregatesInput | tb_dosenScalarWhereWithAggregatesInput[]
    nip?: StringWithAggregatesFilter<"tb_dosen"> | string
    nama?: StringWithAggregatesFilter<"tb_dosen"> | string
    alamat?: StringNullableWithAggregatesFilter<"tb_dosen"> | string | null
    email?: StringNullableWithAggregatesFilter<"tb_dosen"> | string | null
    kodeKab?: StringNullableWithAggregatesFilter<"tb_dosen"> | string | null
    kodeProv?: StringNullableWithAggregatesFilter<"tb_dosen"> | string | null
    noHP?: StringNullableWithAggregatesFilter<"tb_dosen"> | string | null
    foto?: StringNullableWithAggregatesFilter<"tb_dosen"> | string | null
  }

  export type tb_irsWhereInput = {
    AND?: tb_irsWhereInput | tb_irsWhereInput[]
    OR?: tb_irsWhereInput[]
    NOT?: tb_irsWhereInput | tb_irsWhereInput[]
    nim?: StringFilter<"tb_irs"> | string
    semester?: StringFilter<"tb_irs"> | string
    status?: EnumStatusAktifFilter<"tb_irs"> | $Enums.StatusAktif
    jumlahSks?: StringNullableFilter<"tb_irs"> | string | null
    fileIrs?: StringNullableFilter<"tb_irs"> | string | null
    statusValidasi?: BoolFilter<"tb_irs"> | boolean
    fk_nim?: XOR<Tb_mhsRelationFilter, tb_mhsWhereInput>
  }

  export type tb_irsOrderByWithRelationInput = {
    nim?: SortOrder
    semester?: SortOrder
    status?: SortOrder
    jumlahSks?: SortOrderInput | SortOrder
    fileIrs?: SortOrderInput | SortOrder
    statusValidasi?: SortOrder
    fk_nim?: tb_mhsOrderByWithRelationInput
  }

  export type tb_irsWhereUniqueInput = Prisma.AtLeast<{
    nim_semester?: tb_irsNimSemesterCompoundUniqueInput
    AND?: tb_irsWhereInput | tb_irsWhereInput[]
    OR?: tb_irsWhereInput[]
    NOT?: tb_irsWhereInput | tb_irsWhereInput[]
    nim?: StringFilter<"tb_irs"> | string
    semester?: StringFilter<"tb_irs"> | string
    status?: EnumStatusAktifFilter<"tb_irs"> | $Enums.StatusAktif
    jumlahSks?: StringNullableFilter<"tb_irs"> | string | null
    fileIrs?: StringNullableFilter<"tb_irs"> | string | null
    statusValidasi?: BoolFilter<"tb_irs"> | boolean
    fk_nim?: XOR<Tb_mhsRelationFilter, tb_mhsWhereInput>
  }, "nim_semester">

  export type tb_irsOrderByWithAggregationInput = {
    nim?: SortOrder
    semester?: SortOrder
    status?: SortOrder
    jumlahSks?: SortOrderInput | SortOrder
    fileIrs?: SortOrderInput | SortOrder
    statusValidasi?: SortOrder
    _count?: tb_irsCountOrderByAggregateInput
    _max?: tb_irsMaxOrderByAggregateInput
    _min?: tb_irsMinOrderByAggregateInput
  }

  export type tb_irsScalarWhereWithAggregatesInput = {
    AND?: tb_irsScalarWhereWithAggregatesInput | tb_irsScalarWhereWithAggregatesInput[]
    OR?: tb_irsScalarWhereWithAggregatesInput[]
    NOT?: tb_irsScalarWhereWithAggregatesInput | tb_irsScalarWhereWithAggregatesInput[]
    nim?: StringWithAggregatesFilter<"tb_irs"> | string
    semester?: StringWithAggregatesFilter<"tb_irs"> | string
    status?: EnumStatusAktifWithAggregatesFilter<"tb_irs"> | $Enums.StatusAktif
    jumlahSks?: StringNullableWithAggregatesFilter<"tb_irs"> | string | null
    fileIrs?: StringNullableWithAggregatesFilter<"tb_irs"> | string | null
    statusValidasi?: BoolWithAggregatesFilter<"tb_irs"> | boolean
  }

  export type tb_khsWhereInput = {
    AND?: tb_khsWhereInput | tb_khsWhereInput[]
    OR?: tb_khsWhereInput[]
    NOT?: tb_khsWhereInput | tb_khsWhereInput[]
    nim?: StringFilter<"tb_khs"> | string
    semester?: StringFilter<"tb_khs"> | string
    status?: EnumStatusAktifFilter<"tb_khs"> | $Enums.StatusAktif
    jumlahSksSemester?: StringNullableFilter<"tb_khs"> | string | null
    ips?: StringNullableFilter<"tb_khs"> | string | null
    jumlahSksKumulatif?: StringNullableFilter<"tb_khs"> | string | null
    ipk?: StringNullableFilter<"tb_khs"> | string | null
    fileKhs?: StringNullableFilter<"tb_khs"> | string | null
    statusValidasi?: BoolFilter<"tb_khs"> | boolean
    fk_nim?: XOR<Tb_mhsRelationFilter, tb_mhsWhereInput>
  }

  export type tb_khsOrderByWithRelationInput = {
    nim?: SortOrder
    semester?: SortOrder
    status?: SortOrder
    jumlahSksSemester?: SortOrderInput | SortOrder
    ips?: SortOrderInput | SortOrder
    jumlahSksKumulatif?: SortOrderInput | SortOrder
    ipk?: SortOrderInput | SortOrder
    fileKhs?: SortOrderInput | SortOrder
    statusValidasi?: SortOrder
    fk_nim?: tb_mhsOrderByWithRelationInput
  }

  export type tb_khsWhereUniqueInput = Prisma.AtLeast<{
    nim_semester?: tb_khsNimSemesterCompoundUniqueInput
    AND?: tb_khsWhereInput | tb_khsWhereInput[]
    OR?: tb_khsWhereInput[]
    NOT?: tb_khsWhereInput | tb_khsWhereInput[]
    nim?: StringFilter<"tb_khs"> | string
    semester?: StringFilter<"tb_khs"> | string
    status?: EnumStatusAktifFilter<"tb_khs"> | $Enums.StatusAktif
    jumlahSksSemester?: StringNullableFilter<"tb_khs"> | string | null
    ips?: StringNullableFilter<"tb_khs"> | string | null
    jumlahSksKumulatif?: StringNullableFilter<"tb_khs"> | string | null
    ipk?: StringNullableFilter<"tb_khs"> | string | null
    fileKhs?: StringNullableFilter<"tb_khs"> | string | null
    statusValidasi?: BoolFilter<"tb_khs"> | boolean
    fk_nim?: XOR<Tb_mhsRelationFilter, tb_mhsWhereInput>
  }, "nim_semester">

  export type tb_khsOrderByWithAggregationInput = {
    nim?: SortOrder
    semester?: SortOrder
    status?: SortOrder
    jumlahSksSemester?: SortOrderInput | SortOrder
    ips?: SortOrderInput | SortOrder
    jumlahSksKumulatif?: SortOrderInput | SortOrder
    ipk?: SortOrderInput | SortOrder
    fileKhs?: SortOrderInput | SortOrder
    statusValidasi?: SortOrder
    _count?: tb_khsCountOrderByAggregateInput
    _max?: tb_khsMaxOrderByAggregateInput
    _min?: tb_khsMinOrderByAggregateInput
  }

  export type tb_khsScalarWhereWithAggregatesInput = {
    AND?: tb_khsScalarWhereWithAggregatesInput | tb_khsScalarWhereWithAggregatesInput[]
    OR?: tb_khsScalarWhereWithAggregatesInput[]
    NOT?: tb_khsScalarWhereWithAggregatesInput | tb_khsScalarWhereWithAggregatesInput[]
    nim?: StringWithAggregatesFilter<"tb_khs"> | string
    semester?: StringWithAggregatesFilter<"tb_khs"> | string
    status?: EnumStatusAktifWithAggregatesFilter<"tb_khs"> | $Enums.StatusAktif
    jumlahSksSemester?: StringNullableWithAggregatesFilter<"tb_khs"> | string | null
    ips?: StringNullableWithAggregatesFilter<"tb_khs"> | string | null
    jumlahSksKumulatif?: StringNullableWithAggregatesFilter<"tb_khs"> | string | null
    ipk?: StringNullableWithAggregatesFilter<"tb_khs"> | string | null
    fileKhs?: StringNullableWithAggregatesFilter<"tb_khs"> | string | null
    statusValidasi?: BoolWithAggregatesFilter<"tb_khs"> | boolean
  }

  export type tb_pklWhereInput = {
    AND?: tb_pklWhereInput | tb_pklWhereInput[]
    OR?: tb_pklWhereInput[]
    NOT?: tb_pklWhereInput | tb_pklWhereInput[]
    nim?: StringFilter<"tb_pkl"> | string
    semester?: StringFilter<"tb_pkl"> | string
    nilai?: StringFilter<"tb_pkl"> | string
    filePkl?: StringFilter<"tb_pkl"> | string
    statusValidasi?: BoolFilter<"tb_pkl"> | boolean
    fk_nim?: XOR<Tb_mhsRelationFilter, tb_mhsWhereInput>
  }

  export type tb_pklOrderByWithRelationInput = {
    nim?: SortOrder
    semester?: SortOrder
    nilai?: SortOrder
    filePkl?: SortOrder
    statusValidasi?: SortOrder
    fk_nim?: tb_mhsOrderByWithRelationInput
  }

  export type tb_pklWhereUniqueInput = Prisma.AtLeast<{
    nim_semester?: tb_pklNimSemesterCompoundUniqueInput
    AND?: tb_pklWhereInput | tb_pklWhereInput[]
    OR?: tb_pklWhereInput[]
    NOT?: tb_pklWhereInput | tb_pklWhereInput[]
    nim?: StringFilter<"tb_pkl"> | string
    semester?: StringFilter<"tb_pkl"> | string
    nilai?: StringFilter<"tb_pkl"> | string
    filePkl?: StringFilter<"tb_pkl"> | string
    statusValidasi?: BoolFilter<"tb_pkl"> | boolean
    fk_nim?: XOR<Tb_mhsRelationFilter, tb_mhsWhereInput>
  }, "nim_semester">

  export type tb_pklOrderByWithAggregationInput = {
    nim?: SortOrder
    semester?: SortOrder
    nilai?: SortOrder
    filePkl?: SortOrder
    statusValidasi?: SortOrder
    _count?: tb_pklCountOrderByAggregateInput
    _max?: tb_pklMaxOrderByAggregateInput
    _min?: tb_pklMinOrderByAggregateInput
  }

  export type tb_pklScalarWhereWithAggregatesInput = {
    AND?: tb_pklScalarWhereWithAggregatesInput | tb_pklScalarWhereWithAggregatesInput[]
    OR?: tb_pklScalarWhereWithAggregatesInput[]
    NOT?: tb_pklScalarWhereWithAggregatesInput | tb_pklScalarWhereWithAggregatesInput[]
    nim?: StringWithAggregatesFilter<"tb_pkl"> | string
    semester?: StringWithAggregatesFilter<"tb_pkl"> | string
    nilai?: StringWithAggregatesFilter<"tb_pkl"> | string
    filePkl?: StringWithAggregatesFilter<"tb_pkl"> | string
    statusValidasi?: BoolWithAggregatesFilter<"tb_pkl"> | boolean
  }

  export type tb_skripsiWhereInput = {
    AND?: tb_skripsiWhereInput | tb_skripsiWhereInput[]
    OR?: tb_skripsiWhereInput[]
    NOT?: tb_skripsiWhereInput | tb_skripsiWhereInput[]
    nim?: StringFilter<"tb_skripsi"> | string
    semester?: StringFilter<"tb_skripsi"> | string
    nilai?: StringFilter<"tb_skripsi"> | string
    tanggalLulusSidang?: DateTimeFilter<"tb_skripsi"> | Date | string
    lamaStudi?: IntFilter<"tb_skripsi"> | number
    fileSkripsi?: StringFilter<"tb_skripsi"> | string
    statusValidasi?: BoolFilter<"tb_skripsi"> | boolean
    fk_nim?: XOR<Tb_mhsRelationFilter, tb_mhsWhereInput>
  }

  export type tb_skripsiOrderByWithRelationInput = {
    nim?: SortOrder
    semester?: SortOrder
    nilai?: SortOrder
    tanggalLulusSidang?: SortOrder
    lamaStudi?: SortOrder
    fileSkripsi?: SortOrder
    statusValidasi?: SortOrder
    fk_nim?: tb_mhsOrderByWithRelationInput
  }

  export type tb_skripsiWhereUniqueInput = Prisma.AtLeast<{
    nim_semester?: tb_skripsiNimSemesterCompoundUniqueInput
    AND?: tb_skripsiWhereInput | tb_skripsiWhereInput[]
    OR?: tb_skripsiWhereInput[]
    NOT?: tb_skripsiWhereInput | tb_skripsiWhereInput[]
    nim?: StringFilter<"tb_skripsi"> | string
    semester?: StringFilter<"tb_skripsi"> | string
    nilai?: StringFilter<"tb_skripsi"> | string
    tanggalLulusSidang?: DateTimeFilter<"tb_skripsi"> | Date | string
    lamaStudi?: IntFilter<"tb_skripsi"> | number
    fileSkripsi?: StringFilter<"tb_skripsi"> | string
    statusValidasi?: BoolFilter<"tb_skripsi"> | boolean
    fk_nim?: XOR<Tb_mhsRelationFilter, tb_mhsWhereInput>
  }, "nim_semester">

  export type tb_skripsiOrderByWithAggregationInput = {
    nim?: SortOrder
    semester?: SortOrder
    nilai?: SortOrder
    tanggalLulusSidang?: SortOrder
    lamaStudi?: SortOrder
    fileSkripsi?: SortOrder
    statusValidasi?: SortOrder
    _count?: tb_skripsiCountOrderByAggregateInput
    _avg?: tb_skripsiAvgOrderByAggregateInput
    _max?: tb_skripsiMaxOrderByAggregateInput
    _min?: tb_skripsiMinOrderByAggregateInput
    _sum?: tb_skripsiSumOrderByAggregateInput
  }

  export type tb_skripsiScalarWhereWithAggregatesInput = {
    AND?: tb_skripsiScalarWhereWithAggregatesInput | tb_skripsiScalarWhereWithAggregatesInput[]
    OR?: tb_skripsiScalarWhereWithAggregatesInput[]
    NOT?: tb_skripsiScalarWhereWithAggregatesInput | tb_skripsiScalarWhereWithAggregatesInput[]
    nim?: StringWithAggregatesFilter<"tb_skripsi"> | string
    semester?: StringWithAggregatesFilter<"tb_skripsi"> | string
    nilai?: StringWithAggregatesFilter<"tb_skripsi"> | string
    tanggalLulusSidang?: DateTimeWithAggregatesFilter<"tb_skripsi"> | Date | string
    lamaStudi?: IntWithAggregatesFilter<"tb_skripsi"> | number
    fileSkripsi?: StringWithAggregatesFilter<"tb_skripsi"> | string
    statusValidasi?: BoolWithAggregatesFilter<"tb_skripsi"> | boolean
  }

  export type tb_provinsiWhereInput = {
    AND?: tb_provinsiWhereInput | tb_provinsiWhereInput[]
    OR?: tb_provinsiWhereInput[]
    NOT?: tb_provinsiWhereInput | tb_provinsiWhereInput[]
    kodeProv?: StringFilter<"tb_provinsi"> | string
    namaProv?: StringFilter<"tb_provinsi"> | string
    fk_kodeProv_mhs?: Tb_mhsListRelationFilter
    fk_kodeProv_dosen?: Tb_dosenListRelationFilter
    fk_kodeProv_kabupaten?: Tb_kabupatenListRelationFilter
  }

  export type tb_provinsiOrderByWithRelationInput = {
    kodeProv?: SortOrder
    namaProv?: SortOrder
    fk_kodeProv_mhs?: tb_mhsOrderByRelationAggregateInput
    fk_kodeProv_dosen?: tb_dosenOrderByRelationAggregateInput
    fk_kodeProv_kabupaten?: tb_kabupatenOrderByRelationAggregateInput
  }

  export type tb_provinsiWhereUniqueInput = Prisma.AtLeast<{
    kodeProv?: string
    AND?: tb_provinsiWhereInput | tb_provinsiWhereInput[]
    OR?: tb_provinsiWhereInput[]
    NOT?: tb_provinsiWhereInput | tb_provinsiWhereInput[]
    namaProv?: StringFilter<"tb_provinsi"> | string
    fk_kodeProv_mhs?: Tb_mhsListRelationFilter
    fk_kodeProv_dosen?: Tb_dosenListRelationFilter
    fk_kodeProv_kabupaten?: Tb_kabupatenListRelationFilter
  }, "kodeProv" | "kodeProv">

  export type tb_provinsiOrderByWithAggregationInput = {
    kodeProv?: SortOrder
    namaProv?: SortOrder
    _count?: tb_provinsiCountOrderByAggregateInput
    _max?: tb_provinsiMaxOrderByAggregateInput
    _min?: tb_provinsiMinOrderByAggregateInput
  }

  export type tb_provinsiScalarWhereWithAggregatesInput = {
    AND?: tb_provinsiScalarWhereWithAggregatesInput | tb_provinsiScalarWhereWithAggregatesInput[]
    OR?: tb_provinsiScalarWhereWithAggregatesInput[]
    NOT?: tb_provinsiScalarWhereWithAggregatesInput | tb_provinsiScalarWhereWithAggregatesInput[]
    kodeProv?: StringWithAggregatesFilter<"tb_provinsi"> | string
    namaProv?: StringWithAggregatesFilter<"tb_provinsi"> | string
  }

  export type tb_kabupatenWhereInput = {
    AND?: tb_kabupatenWhereInput | tb_kabupatenWhereInput[]
    OR?: tb_kabupatenWhereInput[]
    NOT?: tb_kabupatenWhereInput | tb_kabupatenWhereInput[]
    kodeKab?: StringFilter<"tb_kabupaten"> | string
    namaKab?: StringFilter<"tb_kabupaten"> | string
    kodeProv?: StringFilter<"tb_kabupaten"> | string
    fk_kodeProv?: XOR<Tb_provinsiRelationFilter, tb_provinsiWhereInput>
    fk_kodeKab_mhs?: Tb_mhsListRelationFilter
    fk_kodeKab_dosen?: Tb_dosenListRelationFilter
  }

  export type tb_kabupatenOrderByWithRelationInput = {
    kodeKab?: SortOrder
    namaKab?: SortOrder
    kodeProv?: SortOrder
    fk_kodeProv?: tb_provinsiOrderByWithRelationInput
    fk_kodeKab_mhs?: tb_mhsOrderByRelationAggregateInput
    fk_kodeKab_dosen?: tb_dosenOrderByRelationAggregateInput
  }

  export type tb_kabupatenWhereUniqueInput = Prisma.AtLeast<{
    kodeKab?: string
    AND?: tb_kabupatenWhereInput | tb_kabupatenWhereInput[]
    OR?: tb_kabupatenWhereInput[]
    NOT?: tb_kabupatenWhereInput | tb_kabupatenWhereInput[]
    namaKab?: StringFilter<"tb_kabupaten"> | string
    kodeProv?: StringFilter<"tb_kabupaten"> | string
    fk_kodeProv?: XOR<Tb_provinsiRelationFilter, tb_provinsiWhereInput>
    fk_kodeKab_mhs?: Tb_mhsListRelationFilter
    fk_kodeKab_dosen?: Tb_dosenListRelationFilter
  }, "kodeKab" | "kodeKab">

  export type tb_kabupatenOrderByWithAggregationInput = {
    kodeKab?: SortOrder
    namaKab?: SortOrder
    kodeProv?: SortOrder
    _count?: tb_kabupatenCountOrderByAggregateInput
    _max?: tb_kabupatenMaxOrderByAggregateInput
    _min?: tb_kabupatenMinOrderByAggregateInput
  }

  export type tb_kabupatenScalarWhereWithAggregatesInput = {
    AND?: tb_kabupatenScalarWhereWithAggregatesInput | tb_kabupatenScalarWhereWithAggregatesInput[]
    OR?: tb_kabupatenScalarWhereWithAggregatesInput[]
    NOT?: tb_kabupatenScalarWhereWithAggregatesInput | tb_kabupatenScalarWhereWithAggregatesInput[]
    kodeKab?: StringWithAggregatesFilter<"tb_kabupaten"> | string
    namaKab?: StringWithAggregatesFilter<"tb_kabupaten"> | string
    kodeProv?: StringWithAggregatesFilter<"tb_kabupaten"> | string
  }

  export type tb_akun_mhsWhereInput = {
    AND?: tb_akun_mhsWhereInput | tb_akun_mhsWhereInput[]
    OR?: tb_akun_mhsWhereInput[]
    NOT?: tb_akun_mhsWhereInput | tb_akun_mhsWhereInput[]
    username?: StringFilter<"tb_akun_mhs"> | string
    password?: StringFilter<"tb_akun_mhs"> | string
    status?: EnumStatusAkunFilter<"tb_akun_mhs"> | $Enums.StatusAkun
    pemilik?: StringFilter<"tb_akun_mhs"> | string
    fk_pemilik?: XOR<Tb_mhsRelationFilter, tb_mhsWhereInput>
  }

  export type tb_akun_mhsOrderByWithRelationInput = {
    username?: SortOrder
    password?: SortOrder
    status?: SortOrder
    pemilik?: SortOrder
    fk_pemilik?: tb_mhsOrderByWithRelationInput
  }

  export type tb_akun_mhsWhereUniqueInput = Prisma.AtLeast<{
    username?: string
    pemilik?: string
    AND?: tb_akun_mhsWhereInput | tb_akun_mhsWhereInput[]
    OR?: tb_akun_mhsWhereInput[]
    NOT?: tb_akun_mhsWhereInput | tb_akun_mhsWhereInput[]
    password?: StringFilter<"tb_akun_mhs"> | string
    status?: EnumStatusAkunFilter<"tb_akun_mhs"> | $Enums.StatusAkun
    fk_pemilik?: XOR<Tb_mhsRelationFilter, tb_mhsWhereInput>
  }, "username" | "username" | "pemilik">

  export type tb_akun_mhsOrderByWithAggregationInput = {
    username?: SortOrder
    password?: SortOrder
    status?: SortOrder
    pemilik?: SortOrder
    _count?: tb_akun_mhsCountOrderByAggregateInput
    _max?: tb_akun_mhsMaxOrderByAggregateInput
    _min?: tb_akun_mhsMinOrderByAggregateInput
  }

  export type tb_akun_mhsScalarWhereWithAggregatesInput = {
    AND?: tb_akun_mhsScalarWhereWithAggregatesInput | tb_akun_mhsScalarWhereWithAggregatesInput[]
    OR?: tb_akun_mhsScalarWhereWithAggregatesInput[]
    NOT?: tb_akun_mhsScalarWhereWithAggregatesInput | tb_akun_mhsScalarWhereWithAggregatesInput[]
    username?: StringWithAggregatesFilter<"tb_akun_mhs"> | string
    password?: StringWithAggregatesFilter<"tb_akun_mhs"> | string
    status?: EnumStatusAkunWithAggregatesFilter<"tb_akun_mhs"> | $Enums.StatusAkun
    pemilik?: StringWithAggregatesFilter<"tb_akun_mhs"> | string
  }

  export type tb_akun_dosenWhereInput = {
    AND?: tb_akun_dosenWhereInput | tb_akun_dosenWhereInput[]
    OR?: tb_akun_dosenWhereInput[]
    NOT?: tb_akun_dosenWhereInput | tb_akun_dosenWhereInput[]
    username?: StringFilter<"tb_akun_dosen"> | string
    password?: StringFilter<"tb_akun_dosen"> | string
    status?: EnumStatusAkunFilter<"tb_akun_dosen"> | $Enums.StatusAkun
    pemilik?: StringFilter<"tb_akun_dosen"> | string
    fk_pemilik?: XOR<Tb_dosenRelationFilter, tb_dosenWhereInput>
    fk_username_role?: Tb_role_akun_dosenListRelationFilter
  }

  export type tb_akun_dosenOrderByWithRelationInput = {
    username?: SortOrder
    password?: SortOrder
    status?: SortOrder
    pemilik?: SortOrder
    fk_pemilik?: tb_dosenOrderByWithRelationInput
    fk_username_role?: tb_role_akun_dosenOrderByRelationAggregateInput
  }

  export type tb_akun_dosenWhereUniqueInput = Prisma.AtLeast<{
    username?: string
    pemilik?: string
    AND?: tb_akun_dosenWhereInput | tb_akun_dosenWhereInput[]
    OR?: tb_akun_dosenWhereInput[]
    NOT?: tb_akun_dosenWhereInput | tb_akun_dosenWhereInput[]
    password?: StringFilter<"tb_akun_dosen"> | string
    status?: EnumStatusAkunFilter<"tb_akun_dosen"> | $Enums.StatusAkun
    fk_pemilik?: XOR<Tb_dosenRelationFilter, tb_dosenWhereInput>
    fk_username_role?: Tb_role_akun_dosenListRelationFilter
  }, "username" | "username" | "pemilik">

  export type tb_akun_dosenOrderByWithAggregationInput = {
    username?: SortOrder
    password?: SortOrder
    status?: SortOrder
    pemilik?: SortOrder
    _count?: tb_akun_dosenCountOrderByAggregateInput
    _max?: tb_akun_dosenMaxOrderByAggregateInput
    _min?: tb_akun_dosenMinOrderByAggregateInput
  }

  export type tb_akun_dosenScalarWhereWithAggregatesInput = {
    AND?: tb_akun_dosenScalarWhereWithAggregatesInput | tb_akun_dosenScalarWhereWithAggregatesInput[]
    OR?: tb_akun_dosenScalarWhereWithAggregatesInput[]
    NOT?: tb_akun_dosenScalarWhereWithAggregatesInput | tb_akun_dosenScalarWhereWithAggregatesInput[]
    username?: StringWithAggregatesFilter<"tb_akun_dosen"> | string
    password?: StringWithAggregatesFilter<"tb_akun_dosen"> | string
    status?: EnumStatusAkunWithAggregatesFilter<"tb_akun_dosen"> | $Enums.StatusAkun
    pemilik?: StringWithAggregatesFilter<"tb_akun_dosen"> | string
  }

  export type tb_role_akun_dosenWhereInput = {
    AND?: tb_role_akun_dosenWhereInput | tb_role_akun_dosenWhereInput[]
    OR?: tb_role_akun_dosenWhereInput[]
    NOT?: tb_role_akun_dosenWhereInput | tb_role_akun_dosenWhereInput[]
    username?: StringFilter<"tb_role_akun_dosen"> | string
    role?: EnumRoleFilter<"tb_role_akun_dosen"> | $Enums.Role
    fk_username?: XOR<Tb_akun_dosenRelationFilter, tb_akun_dosenWhereInput>
  }

  export type tb_role_akun_dosenOrderByWithRelationInput = {
    username?: SortOrder
    role?: SortOrder
    fk_username?: tb_akun_dosenOrderByWithRelationInput
  }

  export type tb_role_akun_dosenWhereUniqueInput = Prisma.AtLeast<{
    username_role?: tb_role_akun_dosenUsernameRoleCompoundUniqueInput
    AND?: tb_role_akun_dosenWhereInput | tb_role_akun_dosenWhereInput[]
    OR?: tb_role_akun_dosenWhereInput[]
    NOT?: tb_role_akun_dosenWhereInput | tb_role_akun_dosenWhereInput[]
    username?: StringFilter<"tb_role_akun_dosen"> | string
    role?: EnumRoleFilter<"tb_role_akun_dosen"> | $Enums.Role
    fk_username?: XOR<Tb_akun_dosenRelationFilter, tb_akun_dosenWhereInput>
  }, "username_role">

  export type tb_role_akun_dosenOrderByWithAggregationInput = {
    username?: SortOrder
    role?: SortOrder
    _count?: tb_role_akun_dosenCountOrderByAggregateInput
    _max?: tb_role_akun_dosenMaxOrderByAggregateInput
    _min?: tb_role_akun_dosenMinOrderByAggregateInput
  }

  export type tb_role_akun_dosenScalarWhereWithAggregatesInput = {
    AND?: tb_role_akun_dosenScalarWhereWithAggregatesInput | tb_role_akun_dosenScalarWhereWithAggregatesInput[]
    OR?: tb_role_akun_dosenScalarWhereWithAggregatesInput[]
    NOT?: tb_role_akun_dosenScalarWhereWithAggregatesInput | tb_role_akun_dosenScalarWhereWithAggregatesInput[]
    username?: StringWithAggregatesFilter<"tb_role_akun_dosen"> | string
    role?: EnumRoleWithAggregatesFilter<"tb_role_akun_dosen"> | $Enums.Role
  }

  export type tb_mhsCreateInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    foto?: string | null
    fk_kodeKab?: tb_kabupatenCreateNestedOneWithoutFk_kodeKab_mhsInput
    fk_kodeProv?: tb_provinsiCreateNestedOneWithoutFk_kodeProv_mhsInput
    fk_kodeWali: tb_dosenCreateNestedOneWithoutFk_kodeWali_mhsInput
    fk_nim_irs?: tb_irsCreateNestedManyWithoutFk_nimInput
    fk_nim_khs?: tb_khsCreateNestedManyWithoutFk_nimInput
    fk_nim_pkl?: tb_pklCreateNestedManyWithoutFk_nimInput
    fk_nim_skripsi?: tb_skripsiCreateNestedManyWithoutFk_nimInput
    fk_pemilik_akun_mhs?: tb_akun_mhsCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_mhsUncheckedCreateInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    kodeKab?: string | null
    kodeProv?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    kodeWali: string
    foto?: string | null
    fk_nim_irs?: tb_irsUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_khs?: tb_khsUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_pkl?: tb_pklUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_skripsi?: tb_skripsiUncheckedCreateNestedManyWithoutFk_nimInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUncheckedCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_mhsUpdateInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_kodeKab?: tb_kabupatenUpdateOneWithoutFk_kodeKab_mhsNestedInput
    fk_kodeProv?: tb_provinsiUpdateOneWithoutFk_kodeProv_mhsNestedInput
    fk_kodeWali?: tb_dosenUpdateOneRequiredWithoutFk_kodeWali_mhsNestedInput
    fk_nim_irs?: tb_irsUpdateManyWithoutFk_nimNestedInput
    fk_nim_khs?: tb_khsUpdateManyWithoutFk_nimNestedInput
    fk_nim_pkl?: tb_pklUpdateManyWithoutFk_nimNestedInput
    fk_nim_skripsi?: tb_skripsiUpdateManyWithoutFk_nimNestedInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_mhsUncheckedUpdateInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeKab?: NullableStringFieldUpdateOperationsInput | string | null
    kodeProv?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    kodeWali?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_nim_irs?: tb_irsUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_khs?: tb_khsUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_pkl?: tb_pklUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_skripsi?: tb_skripsiUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUncheckedUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_mhsCreateManyInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    kodeKab?: string | null
    kodeProv?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    kodeWali: string
    foto?: string | null
  }

  export type tb_mhsUpdateManyMutationInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_mhsUncheckedUpdateManyInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeKab?: NullableStringFieldUpdateOperationsInput | string | null
    kodeProv?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    kodeWali?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_dosenCreateInput = {
    nip: string
    nama: string
    alamat?: string | null
    email?: string | null
    noHP?: string | null
    foto?: string | null
    fk_kodeKab?: tb_kabupatenCreateNestedOneWithoutFk_kodeKab_dosenInput
    fk_kodeProv?: tb_provinsiCreateNestedOneWithoutFk_kodeProv_dosenInput
    fk_kodeWali_mhs?: tb_mhsCreateNestedManyWithoutFk_kodeWaliInput
    fk_pemilik_akun_dosen?: tb_akun_dosenCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_dosenUncheckedCreateInput = {
    nip: string
    nama: string
    alamat?: string | null
    email?: string | null
    kodeKab?: string | null
    kodeProv?: string | null
    noHP?: string | null
    foto?: string | null
    fk_kodeWali_mhs?: tb_mhsUncheckedCreateNestedManyWithoutFk_kodeWaliInput
    fk_pemilik_akun_dosen?: tb_akun_dosenUncheckedCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_dosenUpdateInput = {
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_kodeKab?: tb_kabupatenUpdateOneWithoutFk_kodeKab_dosenNestedInput
    fk_kodeProv?: tb_provinsiUpdateOneWithoutFk_kodeProv_dosenNestedInput
    fk_kodeWali_mhs?: tb_mhsUpdateManyWithoutFk_kodeWaliNestedInput
    fk_pemilik_akun_dosen?: tb_akun_dosenUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_dosenUncheckedUpdateInput = {
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeKab?: NullableStringFieldUpdateOperationsInput | string | null
    kodeProv?: NullableStringFieldUpdateOperationsInput | string | null
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_kodeWali_mhs?: tb_mhsUncheckedUpdateManyWithoutFk_kodeWaliNestedInput
    fk_pemilik_akun_dosen?: tb_akun_dosenUncheckedUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_dosenCreateManyInput = {
    nip: string
    nama: string
    alamat?: string | null
    email?: string | null
    kodeKab?: string | null
    kodeProv?: string | null
    noHP?: string | null
    foto?: string | null
  }

  export type tb_dosenUpdateManyMutationInput = {
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_dosenUncheckedUpdateManyInput = {
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeKab?: NullableStringFieldUpdateOperationsInput | string | null
    kodeProv?: NullableStringFieldUpdateOperationsInput | string | null
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_irsCreateInput = {
    semester: string
    status: $Enums.StatusAktif
    jumlahSks?: string | null
    fileIrs?: string | null
    statusValidasi?: boolean
    fk_nim: tb_mhsCreateNestedOneWithoutFk_nim_irsInput
  }

  export type tb_irsUncheckedCreateInput = {
    nim: string
    semester: string
    status: $Enums.StatusAktif
    jumlahSks?: string | null
    fileIrs?: string | null
    statusValidasi?: boolean
  }

  export type tb_irsUpdateInput = {
    semester?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    jumlahSks?: NullableStringFieldUpdateOperationsInput | string | null
    fileIrs?: NullableStringFieldUpdateOperationsInput | string | null
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
    fk_nim?: tb_mhsUpdateOneRequiredWithoutFk_nim_irsNestedInput
  }

  export type tb_irsUncheckedUpdateInput = {
    nim?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    jumlahSks?: NullableStringFieldUpdateOperationsInput | string | null
    fileIrs?: NullableStringFieldUpdateOperationsInput | string | null
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_irsCreateManyInput = {
    nim: string
    semester: string
    status: $Enums.StatusAktif
    jumlahSks?: string | null
    fileIrs?: string | null
    statusValidasi?: boolean
  }

  export type tb_irsUpdateManyMutationInput = {
    semester?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    jumlahSks?: NullableStringFieldUpdateOperationsInput | string | null
    fileIrs?: NullableStringFieldUpdateOperationsInput | string | null
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_irsUncheckedUpdateManyInput = {
    nim?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    jumlahSks?: NullableStringFieldUpdateOperationsInput | string | null
    fileIrs?: NullableStringFieldUpdateOperationsInput | string | null
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_khsCreateInput = {
    semester: string
    status: $Enums.StatusAktif
    jumlahSksSemester?: string | null
    ips?: string | null
    jumlahSksKumulatif?: string | null
    ipk?: string | null
    fileKhs?: string | null
    statusValidasi?: boolean
    fk_nim: tb_mhsCreateNestedOneWithoutFk_nim_khsInput
  }

  export type tb_khsUncheckedCreateInput = {
    nim: string
    semester: string
    status: $Enums.StatusAktif
    jumlahSksSemester?: string | null
    ips?: string | null
    jumlahSksKumulatif?: string | null
    ipk?: string | null
    fileKhs?: string | null
    statusValidasi?: boolean
  }

  export type tb_khsUpdateInput = {
    semester?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    jumlahSksSemester?: NullableStringFieldUpdateOperationsInput | string | null
    ips?: NullableStringFieldUpdateOperationsInput | string | null
    jumlahSksKumulatif?: NullableStringFieldUpdateOperationsInput | string | null
    ipk?: NullableStringFieldUpdateOperationsInput | string | null
    fileKhs?: NullableStringFieldUpdateOperationsInput | string | null
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
    fk_nim?: tb_mhsUpdateOneRequiredWithoutFk_nim_khsNestedInput
  }

  export type tb_khsUncheckedUpdateInput = {
    nim?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    jumlahSksSemester?: NullableStringFieldUpdateOperationsInput | string | null
    ips?: NullableStringFieldUpdateOperationsInput | string | null
    jumlahSksKumulatif?: NullableStringFieldUpdateOperationsInput | string | null
    ipk?: NullableStringFieldUpdateOperationsInput | string | null
    fileKhs?: NullableStringFieldUpdateOperationsInput | string | null
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_khsCreateManyInput = {
    nim: string
    semester: string
    status: $Enums.StatusAktif
    jumlahSksSemester?: string | null
    ips?: string | null
    jumlahSksKumulatif?: string | null
    ipk?: string | null
    fileKhs?: string | null
    statusValidasi?: boolean
  }

  export type tb_khsUpdateManyMutationInput = {
    semester?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    jumlahSksSemester?: NullableStringFieldUpdateOperationsInput | string | null
    ips?: NullableStringFieldUpdateOperationsInput | string | null
    jumlahSksKumulatif?: NullableStringFieldUpdateOperationsInput | string | null
    ipk?: NullableStringFieldUpdateOperationsInput | string | null
    fileKhs?: NullableStringFieldUpdateOperationsInput | string | null
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_khsUncheckedUpdateManyInput = {
    nim?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    jumlahSksSemester?: NullableStringFieldUpdateOperationsInput | string | null
    ips?: NullableStringFieldUpdateOperationsInput | string | null
    jumlahSksKumulatif?: NullableStringFieldUpdateOperationsInput | string | null
    ipk?: NullableStringFieldUpdateOperationsInput | string | null
    fileKhs?: NullableStringFieldUpdateOperationsInput | string | null
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_pklCreateInput = {
    semester: string
    nilai: string
    filePkl: string
    statusValidasi?: boolean
    fk_nim: tb_mhsCreateNestedOneWithoutFk_nim_pklInput
  }

  export type tb_pklUncheckedCreateInput = {
    nim: string
    semester: string
    nilai: string
    filePkl: string
    statusValidasi?: boolean
  }

  export type tb_pklUpdateInput = {
    semester?: StringFieldUpdateOperationsInput | string
    nilai?: StringFieldUpdateOperationsInput | string
    filePkl?: StringFieldUpdateOperationsInput | string
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
    fk_nim?: tb_mhsUpdateOneRequiredWithoutFk_nim_pklNestedInput
  }

  export type tb_pklUncheckedUpdateInput = {
    nim?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    nilai?: StringFieldUpdateOperationsInput | string
    filePkl?: StringFieldUpdateOperationsInput | string
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_pklCreateManyInput = {
    nim: string
    semester: string
    nilai: string
    filePkl: string
    statusValidasi?: boolean
  }

  export type tb_pklUpdateManyMutationInput = {
    semester?: StringFieldUpdateOperationsInput | string
    nilai?: StringFieldUpdateOperationsInput | string
    filePkl?: StringFieldUpdateOperationsInput | string
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_pklUncheckedUpdateManyInput = {
    nim?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    nilai?: StringFieldUpdateOperationsInput | string
    filePkl?: StringFieldUpdateOperationsInput | string
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_skripsiCreateInput = {
    semester: string
    nilai: string
    tanggalLulusSidang: Date | string
    lamaStudi: number
    fileSkripsi: string
    statusValidasi?: boolean
    fk_nim: tb_mhsCreateNestedOneWithoutFk_nim_skripsiInput
  }

  export type tb_skripsiUncheckedCreateInput = {
    nim: string
    semester: string
    nilai: string
    tanggalLulusSidang: Date | string
    lamaStudi: number
    fileSkripsi: string
    statusValidasi?: boolean
  }

  export type tb_skripsiUpdateInput = {
    semester?: StringFieldUpdateOperationsInput | string
    nilai?: StringFieldUpdateOperationsInput | string
    tanggalLulusSidang?: DateTimeFieldUpdateOperationsInput | Date | string
    lamaStudi?: IntFieldUpdateOperationsInput | number
    fileSkripsi?: StringFieldUpdateOperationsInput | string
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
    fk_nim?: tb_mhsUpdateOneRequiredWithoutFk_nim_skripsiNestedInput
  }

  export type tb_skripsiUncheckedUpdateInput = {
    nim?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    nilai?: StringFieldUpdateOperationsInput | string
    tanggalLulusSidang?: DateTimeFieldUpdateOperationsInput | Date | string
    lamaStudi?: IntFieldUpdateOperationsInput | number
    fileSkripsi?: StringFieldUpdateOperationsInput | string
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_skripsiCreateManyInput = {
    nim: string
    semester: string
    nilai: string
    tanggalLulusSidang: Date | string
    lamaStudi: number
    fileSkripsi: string
    statusValidasi?: boolean
  }

  export type tb_skripsiUpdateManyMutationInput = {
    semester?: StringFieldUpdateOperationsInput | string
    nilai?: StringFieldUpdateOperationsInput | string
    tanggalLulusSidang?: DateTimeFieldUpdateOperationsInput | Date | string
    lamaStudi?: IntFieldUpdateOperationsInput | number
    fileSkripsi?: StringFieldUpdateOperationsInput | string
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_skripsiUncheckedUpdateManyInput = {
    nim?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    nilai?: StringFieldUpdateOperationsInput | string
    tanggalLulusSidang?: DateTimeFieldUpdateOperationsInput | Date | string
    lamaStudi?: IntFieldUpdateOperationsInput | number
    fileSkripsi?: StringFieldUpdateOperationsInput | string
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_provinsiCreateInput = {
    kodeProv: string
    namaProv: string
    fk_kodeProv_mhs?: tb_mhsCreateNestedManyWithoutFk_kodeProvInput
    fk_kodeProv_dosen?: tb_dosenCreateNestedManyWithoutFk_kodeProvInput
    fk_kodeProv_kabupaten?: tb_kabupatenCreateNestedManyWithoutFk_kodeProvInput
  }

  export type tb_provinsiUncheckedCreateInput = {
    kodeProv: string
    namaProv: string
    fk_kodeProv_mhs?: tb_mhsUncheckedCreateNestedManyWithoutFk_kodeProvInput
    fk_kodeProv_dosen?: tb_dosenUncheckedCreateNestedManyWithoutFk_kodeProvInput
    fk_kodeProv_kabupaten?: tb_kabupatenUncheckedCreateNestedManyWithoutFk_kodeProvInput
  }

  export type tb_provinsiUpdateInput = {
    kodeProv?: StringFieldUpdateOperationsInput | string
    namaProv?: StringFieldUpdateOperationsInput | string
    fk_kodeProv_mhs?: tb_mhsUpdateManyWithoutFk_kodeProvNestedInput
    fk_kodeProv_dosen?: tb_dosenUpdateManyWithoutFk_kodeProvNestedInput
    fk_kodeProv_kabupaten?: tb_kabupatenUpdateManyWithoutFk_kodeProvNestedInput
  }

  export type tb_provinsiUncheckedUpdateInput = {
    kodeProv?: StringFieldUpdateOperationsInput | string
    namaProv?: StringFieldUpdateOperationsInput | string
    fk_kodeProv_mhs?: tb_mhsUncheckedUpdateManyWithoutFk_kodeProvNestedInput
    fk_kodeProv_dosen?: tb_dosenUncheckedUpdateManyWithoutFk_kodeProvNestedInput
    fk_kodeProv_kabupaten?: tb_kabupatenUncheckedUpdateManyWithoutFk_kodeProvNestedInput
  }

  export type tb_provinsiCreateManyInput = {
    kodeProv: string
    namaProv: string
  }

  export type tb_provinsiUpdateManyMutationInput = {
    kodeProv?: StringFieldUpdateOperationsInput | string
    namaProv?: StringFieldUpdateOperationsInput | string
  }

  export type tb_provinsiUncheckedUpdateManyInput = {
    kodeProv?: StringFieldUpdateOperationsInput | string
    namaProv?: StringFieldUpdateOperationsInput | string
  }

  export type tb_kabupatenCreateInput = {
    kodeKab: string
    namaKab: string
    fk_kodeProv: tb_provinsiCreateNestedOneWithoutFk_kodeProv_kabupatenInput
    fk_kodeKab_mhs?: tb_mhsCreateNestedManyWithoutFk_kodeKabInput
    fk_kodeKab_dosen?: tb_dosenCreateNestedManyWithoutFk_kodeKabInput
  }

  export type tb_kabupatenUncheckedCreateInput = {
    kodeKab: string
    namaKab: string
    kodeProv: string
    fk_kodeKab_mhs?: tb_mhsUncheckedCreateNestedManyWithoutFk_kodeKabInput
    fk_kodeKab_dosen?: tb_dosenUncheckedCreateNestedManyWithoutFk_kodeKabInput
  }

  export type tb_kabupatenUpdateInput = {
    kodeKab?: StringFieldUpdateOperationsInput | string
    namaKab?: StringFieldUpdateOperationsInput | string
    fk_kodeProv?: tb_provinsiUpdateOneRequiredWithoutFk_kodeProv_kabupatenNestedInput
    fk_kodeKab_mhs?: tb_mhsUpdateManyWithoutFk_kodeKabNestedInput
    fk_kodeKab_dosen?: tb_dosenUpdateManyWithoutFk_kodeKabNestedInput
  }

  export type tb_kabupatenUncheckedUpdateInput = {
    kodeKab?: StringFieldUpdateOperationsInput | string
    namaKab?: StringFieldUpdateOperationsInput | string
    kodeProv?: StringFieldUpdateOperationsInput | string
    fk_kodeKab_mhs?: tb_mhsUncheckedUpdateManyWithoutFk_kodeKabNestedInput
    fk_kodeKab_dosen?: tb_dosenUncheckedUpdateManyWithoutFk_kodeKabNestedInput
  }

  export type tb_kabupatenCreateManyInput = {
    kodeKab: string
    namaKab: string
    kodeProv: string
  }

  export type tb_kabupatenUpdateManyMutationInput = {
    kodeKab?: StringFieldUpdateOperationsInput | string
    namaKab?: StringFieldUpdateOperationsInput | string
  }

  export type tb_kabupatenUncheckedUpdateManyInput = {
    kodeKab?: StringFieldUpdateOperationsInput | string
    namaKab?: StringFieldUpdateOperationsInput | string
    kodeProv?: StringFieldUpdateOperationsInput | string
  }

  export type tb_akun_mhsCreateInput = {
    username: string
    password: string
    status: $Enums.StatusAkun
    fk_pemilik: tb_mhsCreateNestedOneWithoutFk_pemilik_akun_mhsInput
  }

  export type tb_akun_mhsUncheckedCreateInput = {
    username: string
    password: string
    status: $Enums.StatusAkun
    pemilik: string
  }

  export type tb_akun_mhsUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAkunFieldUpdateOperationsInput | $Enums.StatusAkun
    fk_pemilik?: tb_mhsUpdateOneRequiredWithoutFk_pemilik_akun_mhsNestedInput
  }

  export type tb_akun_mhsUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAkunFieldUpdateOperationsInput | $Enums.StatusAkun
    pemilik?: StringFieldUpdateOperationsInput | string
  }

  export type tb_akun_mhsCreateManyInput = {
    username: string
    password: string
    status: $Enums.StatusAkun
    pemilik: string
  }

  export type tb_akun_mhsUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAkunFieldUpdateOperationsInput | $Enums.StatusAkun
  }

  export type tb_akun_mhsUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAkunFieldUpdateOperationsInput | $Enums.StatusAkun
    pemilik?: StringFieldUpdateOperationsInput | string
  }

  export type tb_akun_dosenCreateInput = {
    username: string
    password: string
    status: $Enums.StatusAkun
    fk_pemilik: tb_dosenCreateNestedOneWithoutFk_pemilik_akun_dosenInput
    fk_username_role?: tb_role_akun_dosenCreateNestedManyWithoutFk_usernameInput
  }

  export type tb_akun_dosenUncheckedCreateInput = {
    username: string
    password: string
    status: $Enums.StatusAkun
    pemilik: string
    fk_username_role?: tb_role_akun_dosenUncheckedCreateNestedManyWithoutFk_usernameInput
  }

  export type tb_akun_dosenUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAkunFieldUpdateOperationsInput | $Enums.StatusAkun
    fk_pemilik?: tb_dosenUpdateOneRequiredWithoutFk_pemilik_akun_dosenNestedInput
    fk_username_role?: tb_role_akun_dosenUpdateManyWithoutFk_usernameNestedInput
  }

  export type tb_akun_dosenUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAkunFieldUpdateOperationsInput | $Enums.StatusAkun
    pemilik?: StringFieldUpdateOperationsInput | string
    fk_username_role?: tb_role_akun_dosenUncheckedUpdateManyWithoutFk_usernameNestedInput
  }

  export type tb_akun_dosenCreateManyInput = {
    username: string
    password: string
    status: $Enums.StatusAkun
    pemilik: string
  }

  export type tb_akun_dosenUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAkunFieldUpdateOperationsInput | $Enums.StatusAkun
  }

  export type tb_akun_dosenUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAkunFieldUpdateOperationsInput | $Enums.StatusAkun
    pemilik?: StringFieldUpdateOperationsInput | string
  }

  export type tb_role_akun_dosenCreateInput = {
    role: $Enums.Role
    fk_username: tb_akun_dosenCreateNestedOneWithoutFk_username_roleInput
  }

  export type tb_role_akun_dosenUncheckedCreateInput = {
    username: string
    role: $Enums.Role
  }

  export type tb_role_akun_dosenUpdateInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    fk_username?: tb_akun_dosenUpdateOneRequiredWithoutFk_username_roleNestedInput
  }

  export type tb_role_akun_dosenUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type tb_role_akun_dosenCreateManyInput = {
    username: string
    role: $Enums.Role
  }

  export type tb_role_akun_dosenUpdateManyMutationInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type tb_role_akun_dosenUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumStatusMhsFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusMhs | EnumStatusMhsFieldRefInput<$PrismaModel>
    in?: $Enums.StatusMhs[] | ListEnumStatusMhsFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusMhs[] | ListEnumStatusMhsFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusMhsFilter<$PrismaModel> | $Enums.StatusMhs
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumJalurMasukFilter<$PrismaModel = never> = {
    equals?: $Enums.JalurMasuk | EnumJalurMasukFieldRefInput<$PrismaModel>
    in?: $Enums.JalurMasuk[] | ListEnumJalurMasukFieldRefInput<$PrismaModel>
    notIn?: $Enums.JalurMasuk[] | ListEnumJalurMasukFieldRefInput<$PrismaModel>
    not?: NestedEnumJalurMasukFilter<$PrismaModel> | $Enums.JalurMasuk
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type Tb_kabupatenNullableRelationFilter = {
    is?: tb_kabupatenWhereInput | null
    isNot?: tb_kabupatenWhereInput | null
  }

  export type Tb_provinsiNullableRelationFilter = {
    is?: tb_provinsiWhereInput | null
    isNot?: tb_provinsiWhereInput | null
  }

  export type Tb_dosenRelationFilter = {
    is?: tb_dosenWhereInput
    isNot?: tb_dosenWhereInput
  }

  export type Tb_irsListRelationFilter = {
    every?: tb_irsWhereInput
    some?: tb_irsWhereInput
    none?: tb_irsWhereInput
  }

  export type Tb_khsListRelationFilter = {
    every?: tb_khsWhereInput
    some?: tb_khsWhereInput
    none?: tb_khsWhereInput
  }

  export type Tb_pklListRelationFilter = {
    every?: tb_pklWhereInput
    some?: tb_pklWhereInput
    none?: tb_pklWhereInput
  }

  export type Tb_skripsiListRelationFilter = {
    every?: tb_skripsiWhereInput
    some?: tb_skripsiWhereInput
    none?: tb_skripsiWhereInput
  }

  export type Tb_akun_mhsNullableRelationFilter = {
    is?: tb_akun_mhsWhereInput | null
    isNot?: tb_akun_mhsWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type tb_irsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tb_khsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tb_pklOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tb_skripsiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tb_mhsCountOrderByAggregateInput = {
    nim?: SortOrder
    nama?: SortOrder
    statusAktif?: SortOrder
    alamat?: SortOrder
    email?: SortOrder
    kodeKab?: SortOrder
    kodeProv?: SortOrder
    jalurMasuk?: SortOrder
    angkatan?: SortOrder
    noHP?: SortOrder
    kodeWali?: SortOrder
    foto?: SortOrder
  }

  export type tb_mhsAvgOrderByAggregateInput = {
    angkatan?: SortOrder
  }

  export type tb_mhsMaxOrderByAggregateInput = {
    nim?: SortOrder
    nama?: SortOrder
    statusAktif?: SortOrder
    alamat?: SortOrder
    email?: SortOrder
    kodeKab?: SortOrder
    kodeProv?: SortOrder
    jalurMasuk?: SortOrder
    angkatan?: SortOrder
    noHP?: SortOrder
    kodeWali?: SortOrder
    foto?: SortOrder
  }

  export type tb_mhsMinOrderByAggregateInput = {
    nim?: SortOrder
    nama?: SortOrder
    statusAktif?: SortOrder
    alamat?: SortOrder
    email?: SortOrder
    kodeKab?: SortOrder
    kodeProv?: SortOrder
    jalurMasuk?: SortOrder
    angkatan?: SortOrder
    noHP?: SortOrder
    kodeWali?: SortOrder
    foto?: SortOrder
  }

  export type tb_mhsSumOrderByAggregateInput = {
    angkatan?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumStatusMhsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusMhs | EnumStatusMhsFieldRefInput<$PrismaModel>
    in?: $Enums.StatusMhs[] | ListEnumStatusMhsFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusMhs[] | ListEnumStatusMhsFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusMhsWithAggregatesFilter<$PrismaModel> | $Enums.StatusMhs
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusMhsFilter<$PrismaModel>
    _max?: NestedEnumStatusMhsFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumJalurMasukWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JalurMasuk | EnumJalurMasukFieldRefInput<$PrismaModel>
    in?: $Enums.JalurMasuk[] | ListEnumJalurMasukFieldRefInput<$PrismaModel>
    notIn?: $Enums.JalurMasuk[] | ListEnumJalurMasukFieldRefInput<$PrismaModel>
    not?: NestedEnumJalurMasukWithAggregatesFilter<$PrismaModel> | $Enums.JalurMasuk
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJalurMasukFilter<$PrismaModel>
    _max?: NestedEnumJalurMasukFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type Tb_mhsListRelationFilter = {
    every?: tb_mhsWhereInput
    some?: tb_mhsWhereInput
    none?: tb_mhsWhereInput
  }

  export type Tb_akun_dosenNullableRelationFilter = {
    is?: tb_akun_dosenWhereInput | null
    isNot?: tb_akun_dosenWhereInput | null
  }

  export type tb_mhsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tb_dosenCountOrderByAggregateInput = {
    nip?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    email?: SortOrder
    kodeKab?: SortOrder
    kodeProv?: SortOrder
    noHP?: SortOrder
    foto?: SortOrder
  }

  export type tb_dosenMaxOrderByAggregateInput = {
    nip?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    email?: SortOrder
    kodeKab?: SortOrder
    kodeProv?: SortOrder
    noHP?: SortOrder
    foto?: SortOrder
  }

  export type tb_dosenMinOrderByAggregateInput = {
    nip?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    email?: SortOrder
    kodeKab?: SortOrder
    kodeProv?: SortOrder
    noHP?: SortOrder
    foto?: SortOrder
  }

  export type EnumStatusAktifFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusAktif | EnumStatusAktifFieldRefInput<$PrismaModel>
    in?: $Enums.StatusAktif[] | ListEnumStatusAktifFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusAktif[] | ListEnumStatusAktifFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusAktifFilter<$PrismaModel> | $Enums.StatusAktif
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Tb_mhsRelationFilter = {
    is?: tb_mhsWhereInput
    isNot?: tb_mhsWhereInput
  }

  export type tb_irsNimSemesterCompoundUniqueInput = {
    nim: string
    semester: string
  }

  export type tb_irsCountOrderByAggregateInput = {
    nim?: SortOrder
    semester?: SortOrder
    status?: SortOrder
    jumlahSks?: SortOrder
    fileIrs?: SortOrder
    statusValidasi?: SortOrder
  }

  export type tb_irsMaxOrderByAggregateInput = {
    nim?: SortOrder
    semester?: SortOrder
    status?: SortOrder
    jumlahSks?: SortOrder
    fileIrs?: SortOrder
    statusValidasi?: SortOrder
  }

  export type tb_irsMinOrderByAggregateInput = {
    nim?: SortOrder
    semester?: SortOrder
    status?: SortOrder
    jumlahSks?: SortOrder
    fileIrs?: SortOrder
    statusValidasi?: SortOrder
  }

  export type EnumStatusAktifWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusAktif | EnumStatusAktifFieldRefInput<$PrismaModel>
    in?: $Enums.StatusAktif[] | ListEnumStatusAktifFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusAktif[] | ListEnumStatusAktifFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusAktifWithAggregatesFilter<$PrismaModel> | $Enums.StatusAktif
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusAktifFilter<$PrismaModel>
    _max?: NestedEnumStatusAktifFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type tb_khsNimSemesterCompoundUniqueInput = {
    nim: string
    semester: string
  }

  export type tb_khsCountOrderByAggregateInput = {
    nim?: SortOrder
    semester?: SortOrder
    status?: SortOrder
    jumlahSksSemester?: SortOrder
    ips?: SortOrder
    jumlahSksKumulatif?: SortOrder
    ipk?: SortOrder
    fileKhs?: SortOrder
    statusValidasi?: SortOrder
  }

  export type tb_khsMaxOrderByAggregateInput = {
    nim?: SortOrder
    semester?: SortOrder
    status?: SortOrder
    jumlahSksSemester?: SortOrder
    ips?: SortOrder
    jumlahSksKumulatif?: SortOrder
    ipk?: SortOrder
    fileKhs?: SortOrder
    statusValidasi?: SortOrder
  }

  export type tb_khsMinOrderByAggregateInput = {
    nim?: SortOrder
    semester?: SortOrder
    status?: SortOrder
    jumlahSksSemester?: SortOrder
    ips?: SortOrder
    jumlahSksKumulatif?: SortOrder
    ipk?: SortOrder
    fileKhs?: SortOrder
    statusValidasi?: SortOrder
  }

  export type tb_pklNimSemesterCompoundUniqueInput = {
    nim: string
    semester: string
  }

  export type tb_pklCountOrderByAggregateInput = {
    nim?: SortOrder
    semester?: SortOrder
    nilai?: SortOrder
    filePkl?: SortOrder
    statusValidasi?: SortOrder
  }

  export type tb_pklMaxOrderByAggregateInput = {
    nim?: SortOrder
    semester?: SortOrder
    nilai?: SortOrder
    filePkl?: SortOrder
    statusValidasi?: SortOrder
  }

  export type tb_pklMinOrderByAggregateInput = {
    nim?: SortOrder
    semester?: SortOrder
    nilai?: SortOrder
    filePkl?: SortOrder
    statusValidasi?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type tb_skripsiNimSemesterCompoundUniqueInput = {
    nim: string
    semester: string
  }

  export type tb_skripsiCountOrderByAggregateInput = {
    nim?: SortOrder
    semester?: SortOrder
    nilai?: SortOrder
    tanggalLulusSidang?: SortOrder
    lamaStudi?: SortOrder
    fileSkripsi?: SortOrder
    statusValidasi?: SortOrder
  }

  export type tb_skripsiAvgOrderByAggregateInput = {
    lamaStudi?: SortOrder
  }

  export type tb_skripsiMaxOrderByAggregateInput = {
    nim?: SortOrder
    semester?: SortOrder
    nilai?: SortOrder
    tanggalLulusSidang?: SortOrder
    lamaStudi?: SortOrder
    fileSkripsi?: SortOrder
    statusValidasi?: SortOrder
  }

  export type tb_skripsiMinOrderByAggregateInput = {
    nim?: SortOrder
    semester?: SortOrder
    nilai?: SortOrder
    tanggalLulusSidang?: SortOrder
    lamaStudi?: SortOrder
    fileSkripsi?: SortOrder
    statusValidasi?: SortOrder
  }

  export type tb_skripsiSumOrderByAggregateInput = {
    lamaStudi?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type Tb_dosenListRelationFilter = {
    every?: tb_dosenWhereInput
    some?: tb_dosenWhereInput
    none?: tb_dosenWhereInput
  }

  export type Tb_kabupatenListRelationFilter = {
    every?: tb_kabupatenWhereInput
    some?: tb_kabupatenWhereInput
    none?: tb_kabupatenWhereInput
  }

  export type tb_dosenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tb_kabupatenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tb_provinsiCountOrderByAggregateInput = {
    kodeProv?: SortOrder
    namaProv?: SortOrder
  }

  export type tb_provinsiMaxOrderByAggregateInput = {
    kodeProv?: SortOrder
    namaProv?: SortOrder
  }

  export type tb_provinsiMinOrderByAggregateInput = {
    kodeProv?: SortOrder
    namaProv?: SortOrder
  }

  export type Tb_provinsiRelationFilter = {
    is?: tb_provinsiWhereInput
    isNot?: tb_provinsiWhereInput
  }

  export type tb_kabupatenCountOrderByAggregateInput = {
    kodeKab?: SortOrder
    namaKab?: SortOrder
    kodeProv?: SortOrder
  }

  export type tb_kabupatenMaxOrderByAggregateInput = {
    kodeKab?: SortOrder
    namaKab?: SortOrder
    kodeProv?: SortOrder
  }

  export type tb_kabupatenMinOrderByAggregateInput = {
    kodeKab?: SortOrder
    namaKab?: SortOrder
    kodeProv?: SortOrder
  }

  export type EnumStatusAkunFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusAkun | EnumStatusAkunFieldRefInput<$PrismaModel>
    in?: $Enums.StatusAkun[] | ListEnumStatusAkunFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusAkun[] | ListEnumStatusAkunFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusAkunFilter<$PrismaModel> | $Enums.StatusAkun
  }

  export type tb_akun_mhsCountOrderByAggregateInput = {
    username?: SortOrder
    password?: SortOrder
    status?: SortOrder
    pemilik?: SortOrder
  }

  export type tb_akun_mhsMaxOrderByAggregateInput = {
    username?: SortOrder
    password?: SortOrder
    status?: SortOrder
    pemilik?: SortOrder
  }

  export type tb_akun_mhsMinOrderByAggregateInput = {
    username?: SortOrder
    password?: SortOrder
    status?: SortOrder
    pemilik?: SortOrder
  }

  export type EnumStatusAkunWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusAkun | EnumStatusAkunFieldRefInput<$PrismaModel>
    in?: $Enums.StatusAkun[] | ListEnumStatusAkunFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusAkun[] | ListEnumStatusAkunFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusAkunWithAggregatesFilter<$PrismaModel> | $Enums.StatusAkun
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusAkunFilter<$PrismaModel>
    _max?: NestedEnumStatusAkunFilter<$PrismaModel>
  }

  export type Tb_role_akun_dosenListRelationFilter = {
    every?: tb_role_akun_dosenWhereInput
    some?: tb_role_akun_dosenWhereInput
    none?: tb_role_akun_dosenWhereInput
  }

  export type tb_role_akun_dosenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tb_akun_dosenCountOrderByAggregateInput = {
    username?: SortOrder
    password?: SortOrder
    status?: SortOrder
    pemilik?: SortOrder
  }

  export type tb_akun_dosenMaxOrderByAggregateInput = {
    username?: SortOrder
    password?: SortOrder
    status?: SortOrder
    pemilik?: SortOrder
  }

  export type tb_akun_dosenMinOrderByAggregateInput = {
    username?: SortOrder
    password?: SortOrder
    status?: SortOrder
    pemilik?: SortOrder
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type Tb_akun_dosenRelationFilter = {
    is?: tb_akun_dosenWhereInput
    isNot?: tb_akun_dosenWhereInput
  }

  export type tb_role_akun_dosenUsernameRoleCompoundUniqueInput = {
    username: string
    role: $Enums.Role
  }

  export type tb_role_akun_dosenCountOrderByAggregateInput = {
    username?: SortOrder
    role?: SortOrder
  }

  export type tb_role_akun_dosenMaxOrderByAggregateInput = {
    username?: SortOrder
    role?: SortOrder
  }

  export type tb_role_akun_dosenMinOrderByAggregateInput = {
    username?: SortOrder
    role?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type tb_kabupatenCreateNestedOneWithoutFk_kodeKab_mhsInput = {
    create?: XOR<tb_kabupatenCreateWithoutFk_kodeKab_mhsInput, tb_kabupatenUncheckedCreateWithoutFk_kodeKab_mhsInput>
    connectOrCreate?: tb_kabupatenCreateOrConnectWithoutFk_kodeKab_mhsInput
    connect?: tb_kabupatenWhereUniqueInput
  }

  export type tb_provinsiCreateNestedOneWithoutFk_kodeProv_mhsInput = {
    create?: XOR<tb_provinsiCreateWithoutFk_kodeProv_mhsInput, tb_provinsiUncheckedCreateWithoutFk_kodeProv_mhsInput>
    connectOrCreate?: tb_provinsiCreateOrConnectWithoutFk_kodeProv_mhsInput
    connect?: tb_provinsiWhereUniqueInput
  }

  export type tb_dosenCreateNestedOneWithoutFk_kodeWali_mhsInput = {
    create?: XOR<tb_dosenCreateWithoutFk_kodeWali_mhsInput, tb_dosenUncheckedCreateWithoutFk_kodeWali_mhsInput>
    connectOrCreate?: tb_dosenCreateOrConnectWithoutFk_kodeWali_mhsInput
    connect?: tb_dosenWhereUniqueInput
  }

  export type tb_irsCreateNestedManyWithoutFk_nimInput = {
    create?: XOR<tb_irsCreateWithoutFk_nimInput, tb_irsUncheckedCreateWithoutFk_nimInput> | tb_irsCreateWithoutFk_nimInput[] | tb_irsUncheckedCreateWithoutFk_nimInput[]
    connectOrCreate?: tb_irsCreateOrConnectWithoutFk_nimInput | tb_irsCreateOrConnectWithoutFk_nimInput[]
    createMany?: tb_irsCreateManyFk_nimInputEnvelope
    connect?: tb_irsWhereUniqueInput | tb_irsWhereUniqueInput[]
  }

  export type tb_khsCreateNestedManyWithoutFk_nimInput = {
    create?: XOR<tb_khsCreateWithoutFk_nimInput, tb_khsUncheckedCreateWithoutFk_nimInput> | tb_khsCreateWithoutFk_nimInput[] | tb_khsUncheckedCreateWithoutFk_nimInput[]
    connectOrCreate?: tb_khsCreateOrConnectWithoutFk_nimInput | tb_khsCreateOrConnectWithoutFk_nimInput[]
    createMany?: tb_khsCreateManyFk_nimInputEnvelope
    connect?: tb_khsWhereUniqueInput | tb_khsWhereUniqueInput[]
  }

  export type tb_pklCreateNestedManyWithoutFk_nimInput = {
    create?: XOR<tb_pklCreateWithoutFk_nimInput, tb_pklUncheckedCreateWithoutFk_nimInput> | tb_pklCreateWithoutFk_nimInput[] | tb_pklUncheckedCreateWithoutFk_nimInput[]
    connectOrCreate?: tb_pklCreateOrConnectWithoutFk_nimInput | tb_pklCreateOrConnectWithoutFk_nimInput[]
    createMany?: tb_pklCreateManyFk_nimInputEnvelope
    connect?: tb_pklWhereUniqueInput | tb_pklWhereUniqueInput[]
  }

  export type tb_skripsiCreateNestedManyWithoutFk_nimInput = {
    create?: XOR<tb_skripsiCreateWithoutFk_nimInput, tb_skripsiUncheckedCreateWithoutFk_nimInput> | tb_skripsiCreateWithoutFk_nimInput[] | tb_skripsiUncheckedCreateWithoutFk_nimInput[]
    connectOrCreate?: tb_skripsiCreateOrConnectWithoutFk_nimInput | tb_skripsiCreateOrConnectWithoutFk_nimInput[]
    createMany?: tb_skripsiCreateManyFk_nimInputEnvelope
    connect?: tb_skripsiWhereUniqueInput | tb_skripsiWhereUniqueInput[]
  }

  export type tb_akun_mhsCreateNestedOneWithoutFk_pemilikInput = {
    create?: XOR<tb_akun_mhsCreateWithoutFk_pemilikInput, tb_akun_mhsUncheckedCreateWithoutFk_pemilikInput>
    connectOrCreate?: tb_akun_mhsCreateOrConnectWithoutFk_pemilikInput
    connect?: tb_akun_mhsWhereUniqueInput
  }

  export type tb_irsUncheckedCreateNestedManyWithoutFk_nimInput = {
    create?: XOR<tb_irsCreateWithoutFk_nimInput, tb_irsUncheckedCreateWithoutFk_nimInput> | tb_irsCreateWithoutFk_nimInput[] | tb_irsUncheckedCreateWithoutFk_nimInput[]
    connectOrCreate?: tb_irsCreateOrConnectWithoutFk_nimInput | tb_irsCreateOrConnectWithoutFk_nimInput[]
    createMany?: tb_irsCreateManyFk_nimInputEnvelope
    connect?: tb_irsWhereUniqueInput | tb_irsWhereUniqueInput[]
  }

  export type tb_khsUncheckedCreateNestedManyWithoutFk_nimInput = {
    create?: XOR<tb_khsCreateWithoutFk_nimInput, tb_khsUncheckedCreateWithoutFk_nimInput> | tb_khsCreateWithoutFk_nimInput[] | tb_khsUncheckedCreateWithoutFk_nimInput[]
    connectOrCreate?: tb_khsCreateOrConnectWithoutFk_nimInput | tb_khsCreateOrConnectWithoutFk_nimInput[]
    createMany?: tb_khsCreateManyFk_nimInputEnvelope
    connect?: tb_khsWhereUniqueInput | tb_khsWhereUniqueInput[]
  }

  export type tb_pklUncheckedCreateNestedManyWithoutFk_nimInput = {
    create?: XOR<tb_pklCreateWithoutFk_nimInput, tb_pklUncheckedCreateWithoutFk_nimInput> | tb_pklCreateWithoutFk_nimInput[] | tb_pklUncheckedCreateWithoutFk_nimInput[]
    connectOrCreate?: tb_pklCreateOrConnectWithoutFk_nimInput | tb_pklCreateOrConnectWithoutFk_nimInput[]
    createMany?: tb_pklCreateManyFk_nimInputEnvelope
    connect?: tb_pklWhereUniqueInput | tb_pklWhereUniqueInput[]
  }

  export type tb_skripsiUncheckedCreateNestedManyWithoutFk_nimInput = {
    create?: XOR<tb_skripsiCreateWithoutFk_nimInput, tb_skripsiUncheckedCreateWithoutFk_nimInput> | tb_skripsiCreateWithoutFk_nimInput[] | tb_skripsiUncheckedCreateWithoutFk_nimInput[]
    connectOrCreate?: tb_skripsiCreateOrConnectWithoutFk_nimInput | tb_skripsiCreateOrConnectWithoutFk_nimInput[]
    createMany?: tb_skripsiCreateManyFk_nimInputEnvelope
    connect?: tb_skripsiWhereUniqueInput | tb_skripsiWhereUniqueInput[]
  }

  export type tb_akun_mhsUncheckedCreateNestedOneWithoutFk_pemilikInput = {
    create?: XOR<tb_akun_mhsCreateWithoutFk_pemilikInput, tb_akun_mhsUncheckedCreateWithoutFk_pemilikInput>
    connectOrCreate?: tb_akun_mhsCreateOrConnectWithoutFk_pemilikInput
    connect?: tb_akun_mhsWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumStatusMhsFieldUpdateOperationsInput = {
    set?: $Enums.StatusMhs
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumJalurMasukFieldUpdateOperationsInput = {
    set?: $Enums.JalurMasuk
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type tb_kabupatenUpdateOneWithoutFk_kodeKab_mhsNestedInput = {
    create?: XOR<tb_kabupatenCreateWithoutFk_kodeKab_mhsInput, tb_kabupatenUncheckedCreateWithoutFk_kodeKab_mhsInput>
    connectOrCreate?: tb_kabupatenCreateOrConnectWithoutFk_kodeKab_mhsInput
    upsert?: tb_kabupatenUpsertWithoutFk_kodeKab_mhsInput
    disconnect?: tb_kabupatenWhereInput | boolean
    delete?: tb_kabupatenWhereInput | boolean
    connect?: tb_kabupatenWhereUniqueInput
    update?: XOR<XOR<tb_kabupatenUpdateToOneWithWhereWithoutFk_kodeKab_mhsInput, tb_kabupatenUpdateWithoutFk_kodeKab_mhsInput>, tb_kabupatenUncheckedUpdateWithoutFk_kodeKab_mhsInput>
  }

  export type tb_provinsiUpdateOneWithoutFk_kodeProv_mhsNestedInput = {
    create?: XOR<tb_provinsiCreateWithoutFk_kodeProv_mhsInput, tb_provinsiUncheckedCreateWithoutFk_kodeProv_mhsInput>
    connectOrCreate?: tb_provinsiCreateOrConnectWithoutFk_kodeProv_mhsInput
    upsert?: tb_provinsiUpsertWithoutFk_kodeProv_mhsInput
    disconnect?: tb_provinsiWhereInput | boolean
    delete?: tb_provinsiWhereInput | boolean
    connect?: tb_provinsiWhereUniqueInput
    update?: XOR<XOR<tb_provinsiUpdateToOneWithWhereWithoutFk_kodeProv_mhsInput, tb_provinsiUpdateWithoutFk_kodeProv_mhsInput>, tb_provinsiUncheckedUpdateWithoutFk_kodeProv_mhsInput>
  }

  export type tb_dosenUpdateOneRequiredWithoutFk_kodeWali_mhsNestedInput = {
    create?: XOR<tb_dosenCreateWithoutFk_kodeWali_mhsInput, tb_dosenUncheckedCreateWithoutFk_kodeWali_mhsInput>
    connectOrCreate?: tb_dosenCreateOrConnectWithoutFk_kodeWali_mhsInput
    upsert?: tb_dosenUpsertWithoutFk_kodeWali_mhsInput
    connect?: tb_dosenWhereUniqueInput
    update?: XOR<XOR<tb_dosenUpdateToOneWithWhereWithoutFk_kodeWali_mhsInput, tb_dosenUpdateWithoutFk_kodeWali_mhsInput>, tb_dosenUncheckedUpdateWithoutFk_kodeWali_mhsInput>
  }

  export type tb_irsUpdateManyWithoutFk_nimNestedInput = {
    create?: XOR<tb_irsCreateWithoutFk_nimInput, tb_irsUncheckedCreateWithoutFk_nimInput> | tb_irsCreateWithoutFk_nimInput[] | tb_irsUncheckedCreateWithoutFk_nimInput[]
    connectOrCreate?: tb_irsCreateOrConnectWithoutFk_nimInput | tb_irsCreateOrConnectWithoutFk_nimInput[]
    upsert?: tb_irsUpsertWithWhereUniqueWithoutFk_nimInput | tb_irsUpsertWithWhereUniqueWithoutFk_nimInput[]
    createMany?: tb_irsCreateManyFk_nimInputEnvelope
    set?: tb_irsWhereUniqueInput | tb_irsWhereUniqueInput[]
    disconnect?: tb_irsWhereUniqueInput | tb_irsWhereUniqueInput[]
    delete?: tb_irsWhereUniqueInput | tb_irsWhereUniqueInput[]
    connect?: tb_irsWhereUniqueInput | tb_irsWhereUniqueInput[]
    update?: tb_irsUpdateWithWhereUniqueWithoutFk_nimInput | tb_irsUpdateWithWhereUniqueWithoutFk_nimInput[]
    updateMany?: tb_irsUpdateManyWithWhereWithoutFk_nimInput | tb_irsUpdateManyWithWhereWithoutFk_nimInput[]
    deleteMany?: tb_irsScalarWhereInput | tb_irsScalarWhereInput[]
  }

  export type tb_khsUpdateManyWithoutFk_nimNestedInput = {
    create?: XOR<tb_khsCreateWithoutFk_nimInput, tb_khsUncheckedCreateWithoutFk_nimInput> | tb_khsCreateWithoutFk_nimInput[] | tb_khsUncheckedCreateWithoutFk_nimInput[]
    connectOrCreate?: tb_khsCreateOrConnectWithoutFk_nimInput | tb_khsCreateOrConnectWithoutFk_nimInput[]
    upsert?: tb_khsUpsertWithWhereUniqueWithoutFk_nimInput | tb_khsUpsertWithWhereUniqueWithoutFk_nimInput[]
    createMany?: tb_khsCreateManyFk_nimInputEnvelope
    set?: tb_khsWhereUniqueInput | tb_khsWhereUniqueInput[]
    disconnect?: tb_khsWhereUniqueInput | tb_khsWhereUniqueInput[]
    delete?: tb_khsWhereUniqueInput | tb_khsWhereUniqueInput[]
    connect?: tb_khsWhereUniqueInput | tb_khsWhereUniqueInput[]
    update?: tb_khsUpdateWithWhereUniqueWithoutFk_nimInput | tb_khsUpdateWithWhereUniqueWithoutFk_nimInput[]
    updateMany?: tb_khsUpdateManyWithWhereWithoutFk_nimInput | tb_khsUpdateManyWithWhereWithoutFk_nimInput[]
    deleteMany?: tb_khsScalarWhereInput | tb_khsScalarWhereInput[]
  }

  export type tb_pklUpdateManyWithoutFk_nimNestedInput = {
    create?: XOR<tb_pklCreateWithoutFk_nimInput, tb_pklUncheckedCreateWithoutFk_nimInput> | tb_pklCreateWithoutFk_nimInput[] | tb_pklUncheckedCreateWithoutFk_nimInput[]
    connectOrCreate?: tb_pklCreateOrConnectWithoutFk_nimInput | tb_pklCreateOrConnectWithoutFk_nimInput[]
    upsert?: tb_pklUpsertWithWhereUniqueWithoutFk_nimInput | tb_pklUpsertWithWhereUniqueWithoutFk_nimInput[]
    createMany?: tb_pklCreateManyFk_nimInputEnvelope
    set?: tb_pklWhereUniqueInput | tb_pklWhereUniqueInput[]
    disconnect?: tb_pklWhereUniqueInput | tb_pklWhereUniqueInput[]
    delete?: tb_pklWhereUniqueInput | tb_pklWhereUniqueInput[]
    connect?: tb_pklWhereUniqueInput | tb_pklWhereUniqueInput[]
    update?: tb_pklUpdateWithWhereUniqueWithoutFk_nimInput | tb_pklUpdateWithWhereUniqueWithoutFk_nimInput[]
    updateMany?: tb_pklUpdateManyWithWhereWithoutFk_nimInput | tb_pklUpdateManyWithWhereWithoutFk_nimInput[]
    deleteMany?: tb_pklScalarWhereInput | tb_pklScalarWhereInput[]
  }

  export type tb_skripsiUpdateManyWithoutFk_nimNestedInput = {
    create?: XOR<tb_skripsiCreateWithoutFk_nimInput, tb_skripsiUncheckedCreateWithoutFk_nimInput> | tb_skripsiCreateWithoutFk_nimInput[] | tb_skripsiUncheckedCreateWithoutFk_nimInput[]
    connectOrCreate?: tb_skripsiCreateOrConnectWithoutFk_nimInput | tb_skripsiCreateOrConnectWithoutFk_nimInput[]
    upsert?: tb_skripsiUpsertWithWhereUniqueWithoutFk_nimInput | tb_skripsiUpsertWithWhereUniqueWithoutFk_nimInput[]
    createMany?: tb_skripsiCreateManyFk_nimInputEnvelope
    set?: tb_skripsiWhereUniqueInput | tb_skripsiWhereUniqueInput[]
    disconnect?: tb_skripsiWhereUniqueInput | tb_skripsiWhereUniqueInput[]
    delete?: tb_skripsiWhereUniqueInput | tb_skripsiWhereUniqueInput[]
    connect?: tb_skripsiWhereUniqueInput | tb_skripsiWhereUniqueInput[]
    update?: tb_skripsiUpdateWithWhereUniqueWithoutFk_nimInput | tb_skripsiUpdateWithWhereUniqueWithoutFk_nimInput[]
    updateMany?: tb_skripsiUpdateManyWithWhereWithoutFk_nimInput | tb_skripsiUpdateManyWithWhereWithoutFk_nimInput[]
    deleteMany?: tb_skripsiScalarWhereInput | tb_skripsiScalarWhereInput[]
  }

  export type tb_akun_mhsUpdateOneWithoutFk_pemilikNestedInput = {
    create?: XOR<tb_akun_mhsCreateWithoutFk_pemilikInput, tb_akun_mhsUncheckedCreateWithoutFk_pemilikInput>
    connectOrCreate?: tb_akun_mhsCreateOrConnectWithoutFk_pemilikInput
    upsert?: tb_akun_mhsUpsertWithoutFk_pemilikInput
    disconnect?: tb_akun_mhsWhereInput | boolean
    delete?: tb_akun_mhsWhereInput | boolean
    connect?: tb_akun_mhsWhereUniqueInput
    update?: XOR<XOR<tb_akun_mhsUpdateToOneWithWhereWithoutFk_pemilikInput, tb_akun_mhsUpdateWithoutFk_pemilikInput>, tb_akun_mhsUncheckedUpdateWithoutFk_pemilikInput>
  }

  export type tb_irsUncheckedUpdateManyWithoutFk_nimNestedInput = {
    create?: XOR<tb_irsCreateWithoutFk_nimInput, tb_irsUncheckedCreateWithoutFk_nimInput> | tb_irsCreateWithoutFk_nimInput[] | tb_irsUncheckedCreateWithoutFk_nimInput[]
    connectOrCreate?: tb_irsCreateOrConnectWithoutFk_nimInput | tb_irsCreateOrConnectWithoutFk_nimInput[]
    upsert?: tb_irsUpsertWithWhereUniqueWithoutFk_nimInput | tb_irsUpsertWithWhereUniqueWithoutFk_nimInput[]
    createMany?: tb_irsCreateManyFk_nimInputEnvelope
    set?: tb_irsWhereUniqueInput | tb_irsWhereUniqueInput[]
    disconnect?: tb_irsWhereUniqueInput | tb_irsWhereUniqueInput[]
    delete?: tb_irsWhereUniqueInput | tb_irsWhereUniqueInput[]
    connect?: tb_irsWhereUniqueInput | tb_irsWhereUniqueInput[]
    update?: tb_irsUpdateWithWhereUniqueWithoutFk_nimInput | tb_irsUpdateWithWhereUniqueWithoutFk_nimInput[]
    updateMany?: tb_irsUpdateManyWithWhereWithoutFk_nimInput | tb_irsUpdateManyWithWhereWithoutFk_nimInput[]
    deleteMany?: tb_irsScalarWhereInput | tb_irsScalarWhereInput[]
  }

  export type tb_khsUncheckedUpdateManyWithoutFk_nimNestedInput = {
    create?: XOR<tb_khsCreateWithoutFk_nimInput, tb_khsUncheckedCreateWithoutFk_nimInput> | tb_khsCreateWithoutFk_nimInput[] | tb_khsUncheckedCreateWithoutFk_nimInput[]
    connectOrCreate?: tb_khsCreateOrConnectWithoutFk_nimInput | tb_khsCreateOrConnectWithoutFk_nimInput[]
    upsert?: tb_khsUpsertWithWhereUniqueWithoutFk_nimInput | tb_khsUpsertWithWhereUniqueWithoutFk_nimInput[]
    createMany?: tb_khsCreateManyFk_nimInputEnvelope
    set?: tb_khsWhereUniqueInput | tb_khsWhereUniqueInput[]
    disconnect?: tb_khsWhereUniqueInput | tb_khsWhereUniqueInput[]
    delete?: tb_khsWhereUniqueInput | tb_khsWhereUniqueInput[]
    connect?: tb_khsWhereUniqueInput | tb_khsWhereUniqueInput[]
    update?: tb_khsUpdateWithWhereUniqueWithoutFk_nimInput | tb_khsUpdateWithWhereUniqueWithoutFk_nimInput[]
    updateMany?: tb_khsUpdateManyWithWhereWithoutFk_nimInput | tb_khsUpdateManyWithWhereWithoutFk_nimInput[]
    deleteMany?: tb_khsScalarWhereInput | tb_khsScalarWhereInput[]
  }

  export type tb_pklUncheckedUpdateManyWithoutFk_nimNestedInput = {
    create?: XOR<tb_pklCreateWithoutFk_nimInput, tb_pklUncheckedCreateWithoutFk_nimInput> | tb_pklCreateWithoutFk_nimInput[] | tb_pklUncheckedCreateWithoutFk_nimInput[]
    connectOrCreate?: tb_pklCreateOrConnectWithoutFk_nimInput | tb_pklCreateOrConnectWithoutFk_nimInput[]
    upsert?: tb_pklUpsertWithWhereUniqueWithoutFk_nimInput | tb_pklUpsertWithWhereUniqueWithoutFk_nimInput[]
    createMany?: tb_pklCreateManyFk_nimInputEnvelope
    set?: tb_pklWhereUniqueInput | tb_pklWhereUniqueInput[]
    disconnect?: tb_pklWhereUniqueInput | tb_pklWhereUniqueInput[]
    delete?: tb_pklWhereUniqueInput | tb_pklWhereUniqueInput[]
    connect?: tb_pklWhereUniqueInput | tb_pklWhereUniqueInput[]
    update?: tb_pklUpdateWithWhereUniqueWithoutFk_nimInput | tb_pklUpdateWithWhereUniqueWithoutFk_nimInput[]
    updateMany?: tb_pklUpdateManyWithWhereWithoutFk_nimInput | tb_pklUpdateManyWithWhereWithoutFk_nimInput[]
    deleteMany?: tb_pklScalarWhereInput | tb_pklScalarWhereInput[]
  }

  export type tb_skripsiUncheckedUpdateManyWithoutFk_nimNestedInput = {
    create?: XOR<tb_skripsiCreateWithoutFk_nimInput, tb_skripsiUncheckedCreateWithoutFk_nimInput> | tb_skripsiCreateWithoutFk_nimInput[] | tb_skripsiUncheckedCreateWithoutFk_nimInput[]
    connectOrCreate?: tb_skripsiCreateOrConnectWithoutFk_nimInput | tb_skripsiCreateOrConnectWithoutFk_nimInput[]
    upsert?: tb_skripsiUpsertWithWhereUniqueWithoutFk_nimInput | tb_skripsiUpsertWithWhereUniqueWithoutFk_nimInput[]
    createMany?: tb_skripsiCreateManyFk_nimInputEnvelope
    set?: tb_skripsiWhereUniqueInput | tb_skripsiWhereUniqueInput[]
    disconnect?: tb_skripsiWhereUniqueInput | tb_skripsiWhereUniqueInput[]
    delete?: tb_skripsiWhereUniqueInput | tb_skripsiWhereUniqueInput[]
    connect?: tb_skripsiWhereUniqueInput | tb_skripsiWhereUniqueInput[]
    update?: tb_skripsiUpdateWithWhereUniqueWithoutFk_nimInput | tb_skripsiUpdateWithWhereUniqueWithoutFk_nimInput[]
    updateMany?: tb_skripsiUpdateManyWithWhereWithoutFk_nimInput | tb_skripsiUpdateManyWithWhereWithoutFk_nimInput[]
    deleteMany?: tb_skripsiScalarWhereInput | tb_skripsiScalarWhereInput[]
  }

  export type tb_akun_mhsUncheckedUpdateOneWithoutFk_pemilikNestedInput = {
    create?: XOR<tb_akun_mhsCreateWithoutFk_pemilikInput, tb_akun_mhsUncheckedCreateWithoutFk_pemilikInput>
    connectOrCreate?: tb_akun_mhsCreateOrConnectWithoutFk_pemilikInput
    upsert?: tb_akun_mhsUpsertWithoutFk_pemilikInput
    disconnect?: tb_akun_mhsWhereInput | boolean
    delete?: tb_akun_mhsWhereInput | boolean
    connect?: tb_akun_mhsWhereUniqueInput
    update?: XOR<XOR<tb_akun_mhsUpdateToOneWithWhereWithoutFk_pemilikInput, tb_akun_mhsUpdateWithoutFk_pemilikInput>, tb_akun_mhsUncheckedUpdateWithoutFk_pemilikInput>
  }

  export type tb_kabupatenCreateNestedOneWithoutFk_kodeKab_dosenInput = {
    create?: XOR<tb_kabupatenCreateWithoutFk_kodeKab_dosenInput, tb_kabupatenUncheckedCreateWithoutFk_kodeKab_dosenInput>
    connectOrCreate?: tb_kabupatenCreateOrConnectWithoutFk_kodeKab_dosenInput
    connect?: tb_kabupatenWhereUniqueInput
  }

  export type tb_provinsiCreateNestedOneWithoutFk_kodeProv_dosenInput = {
    create?: XOR<tb_provinsiCreateWithoutFk_kodeProv_dosenInput, tb_provinsiUncheckedCreateWithoutFk_kodeProv_dosenInput>
    connectOrCreate?: tb_provinsiCreateOrConnectWithoutFk_kodeProv_dosenInput
    connect?: tb_provinsiWhereUniqueInput
  }

  export type tb_mhsCreateNestedManyWithoutFk_kodeWaliInput = {
    create?: XOR<tb_mhsCreateWithoutFk_kodeWaliInput, tb_mhsUncheckedCreateWithoutFk_kodeWaliInput> | tb_mhsCreateWithoutFk_kodeWaliInput[] | tb_mhsUncheckedCreateWithoutFk_kodeWaliInput[]
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_kodeWaliInput | tb_mhsCreateOrConnectWithoutFk_kodeWaliInput[]
    createMany?: tb_mhsCreateManyFk_kodeWaliInputEnvelope
    connect?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
  }

  export type tb_akun_dosenCreateNestedOneWithoutFk_pemilikInput = {
    create?: XOR<tb_akun_dosenCreateWithoutFk_pemilikInput, tb_akun_dosenUncheckedCreateWithoutFk_pemilikInput>
    connectOrCreate?: tb_akun_dosenCreateOrConnectWithoutFk_pemilikInput
    connect?: tb_akun_dosenWhereUniqueInput
  }

  export type tb_mhsUncheckedCreateNestedManyWithoutFk_kodeWaliInput = {
    create?: XOR<tb_mhsCreateWithoutFk_kodeWaliInput, tb_mhsUncheckedCreateWithoutFk_kodeWaliInput> | tb_mhsCreateWithoutFk_kodeWaliInput[] | tb_mhsUncheckedCreateWithoutFk_kodeWaliInput[]
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_kodeWaliInput | tb_mhsCreateOrConnectWithoutFk_kodeWaliInput[]
    createMany?: tb_mhsCreateManyFk_kodeWaliInputEnvelope
    connect?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
  }

  export type tb_akun_dosenUncheckedCreateNestedOneWithoutFk_pemilikInput = {
    create?: XOR<tb_akun_dosenCreateWithoutFk_pemilikInput, tb_akun_dosenUncheckedCreateWithoutFk_pemilikInput>
    connectOrCreate?: tb_akun_dosenCreateOrConnectWithoutFk_pemilikInput
    connect?: tb_akun_dosenWhereUniqueInput
  }

  export type tb_kabupatenUpdateOneWithoutFk_kodeKab_dosenNestedInput = {
    create?: XOR<tb_kabupatenCreateWithoutFk_kodeKab_dosenInput, tb_kabupatenUncheckedCreateWithoutFk_kodeKab_dosenInput>
    connectOrCreate?: tb_kabupatenCreateOrConnectWithoutFk_kodeKab_dosenInput
    upsert?: tb_kabupatenUpsertWithoutFk_kodeKab_dosenInput
    disconnect?: tb_kabupatenWhereInput | boolean
    delete?: tb_kabupatenWhereInput | boolean
    connect?: tb_kabupatenWhereUniqueInput
    update?: XOR<XOR<tb_kabupatenUpdateToOneWithWhereWithoutFk_kodeKab_dosenInput, tb_kabupatenUpdateWithoutFk_kodeKab_dosenInput>, tb_kabupatenUncheckedUpdateWithoutFk_kodeKab_dosenInput>
  }

  export type tb_provinsiUpdateOneWithoutFk_kodeProv_dosenNestedInput = {
    create?: XOR<tb_provinsiCreateWithoutFk_kodeProv_dosenInput, tb_provinsiUncheckedCreateWithoutFk_kodeProv_dosenInput>
    connectOrCreate?: tb_provinsiCreateOrConnectWithoutFk_kodeProv_dosenInput
    upsert?: tb_provinsiUpsertWithoutFk_kodeProv_dosenInput
    disconnect?: tb_provinsiWhereInput | boolean
    delete?: tb_provinsiWhereInput | boolean
    connect?: tb_provinsiWhereUniqueInput
    update?: XOR<XOR<tb_provinsiUpdateToOneWithWhereWithoutFk_kodeProv_dosenInput, tb_provinsiUpdateWithoutFk_kodeProv_dosenInput>, tb_provinsiUncheckedUpdateWithoutFk_kodeProv_dosenInput>
  }

  export type tb_mhsUpdateManyWithoutFk_kodeWaliNestedInput = {
    create?: XOR<tb_mhsCreateWithoutFk_kodeWaliInput, tb_mhsUncheckedCreateWithoutFk_kodeWaliInput> | tb_mhsCreateWithoutFk_kodeWaliInput[] | tb_mhsUncheckedCreateWithoutFk_kodeWaliInput[]
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_kodeWaliInput | tb_mhsCreateOrConnectWithoutFk_kodeWaliInput[]
    upsert?: tb_mhsUpsertWithWhereUniqueWithoutFk_kodeWaliInput | tb_mhsUpsertWithWhereUniqueWithoutFk_kodeWaliInput[]
    createMany?: tb_mhsCreateManyFk_kodeWaliInputEnvelope
    set?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    disconnect?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    delete?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    connect?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    update?: tb_mhsUpdateWithWhereUniqueWithoutFk_kodeWaliInput | tb_mhsUpdateWithWhereUniqueWithoutFk_kodeWaliInput[]
    updateMany?: tb_mhsUpdateManyWithWhereWithoutFk_kodeWaliInput | tb_mhsUpdateManyWithWhereWithoutFk_kodeWaliInput[]
    deleteMany?: tb_mhsScalarWhereInput | tb_mhsScalarWhereInput[]
  }

  export type tb_akun_dosenUpdateOneWithoutFk_pemilikNestedInput = {
    create?: XOR<tb_akun_dosenCreateWithoutFk_pemilikInput, tb_akun_dosenUncheckedCreateWithoutFk_pemilikInput>
    connectOrCreate?: tb_akun_dosenCreateOrConnectWithoutFk_pemilikInput
    upsert?: tb_akun_dosenUpsertWithoutFk_pemilikInput
    disconnect?: tb_akun_dosenWhereInput | boolean
    delete?: tb_akun_dosenWhereInput | boolean
    connect?: tb_akun_dosenWhereUniqueInput
    update?: XOR<XOR<tb_akun_dosenUpdateToOneWithWhereWithoutFk_pemilikInput, tb_akun_dosenUpdateWithoutFk_pemilikInput>, tb_akun_dosenUncheckedUpdateWithoutFk_pemilikInput>
  }

  export type tb_mhsUncheckedUpdateManyWithoutFk_kodeWaliNestedInput = {
    create?: XOR<tb_mhsCreateWithoutFk_kodeWaliInput, tb_mhsUncheckedCreateWithoutFk_kodeWaliInput> | tb_mhsCreateWithoutFk_kodeWaliInput[] | tb_mhsUncheckedCreateWithoutFk_kodeWaliInput[]
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_kodeWaliInput | tb_mhsCreateOrConnectWithoutFk_kodeWaliInput[]
    upsert?: tb_mhsUpsertWithWhereUniqueWithoutFk_kodeWaliInput | tb_mhsUpsertWithWhereUniqueWithoutFk_kodeWaliInput[]
    createMany?: tb_mhsCreateManyFk_kodeWaliInputEnvelope
    set?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    disconnect?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    delete?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    connect?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    update?: tb_mhsUpdateWithWhereUniqueWithoutFk_kodeWaliInput | tb_mhsUpdateWithWhereUniqueWithoutFk_kodeWaliInput[]
    updateMany?: tb_mhsUpdateManyWithWhereWithoutFk_kodeWaliInput | tb_mhsUpdateManyWithWhereWithoutFk_kodeWaliInput[]
    deleteMany?: tb_mhsScalarWhereInput | tb_mhsScalarWhereInput[]
  }

  export type tb_akun_dosenUncheckedUpdateOneWithoutFk_pemilikNestedInput = {
    create?: XOR<tb_akun_dosenCreateWithoutFk_pemilikInput, tb_akun_dosenUncheckedCreateWithoutFk_pemilikInput>
    connectOrCreate?: tb_akun_dosenCreateOrConnectWithoutFk_pemilikInput
    upsert?: tb_akun_dosenUpsertWithoutFk_pemilikInput
    disconnect?: tb_akun_dosenWhereInput | boolean
    delete?: tb_akun_dosenWhereInput | boolean
    connect?: tb_akun_dosenWhereUniqueInput
    update?: XOR<XOR<tb_akun_dosenUpdateToOneWithWhereWithoutFk_pemilikInput, tb_akun_dosenUpdateWithoutFk_pemilikInput>, tb_akun_dosenUncheckedUpdateWithoutFk_pemilikInput>
  }

  export type tb_mhsCreateNestedOneWithoutFk_nim_irsInput = {
    create?: XOR<tb_mhsCreateWithoutFk_nim_irsInput, tb_mhsUncheckedCreateWithoutFk_nim_irsInput>
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_nim_irsInput
    connect?: tb_mhsWhereUniqueInput
  }

  export type EnumStatusAktifFieldUpdateOperationsInput = {
    set?: $Enums.StatusAktif
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type tb_mhsUpdateOneRequiredWithoutFk_nim_irsNestedInput = {
    create?: XOR<tb_mhsCreateWithoutFk_nim_irsInput, tb_mhsUncheckedCreateWithoutFk_nim_irsInput>
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_nim_irsInput
    upsert?: tb_mhsUpsertWithoutFk_nim_irsInput
    connect?: tb_mhsWhereUniqueInput
    update?: XOR<XOR<tb_mhsUpdateToOneWithWhereWithoutFk_nim_irsInput, tb_mhsUpdateWithoutFk_nim_irsInput>, tb_mhsUncheckedUpdateWithoutFk_nim_irsInput>
  }

  export type tb_mhsCreateNestedOneWithoutFk_nim_khsInput = {
    create?: XOR<tb_mhsCreateWithoutFk_nim_khsInput, tb_mhsUncheckedCreateWithoutFk_nim_khsInput>
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_nim_khsInput
    connect?: tb_mhsWhereUniqueInput
  }

  export type tb_mhsUpdateOneRequiredWithoutFk_nim_khsNestedInput = {
    create?: XOR<tb_mhsCreateWithoutFk_nim_khsInput, tb_mhsUncheckedCreateWithoutFk_nim_khsInput>
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_nim_khsInput
    upsert?: tb_mhsUpsertWithoutFk_nim_khsInput
    connect?: tb_mhsWhereUniqueInput
    update?: XOR<XOR<tb_mhsUpdateToOneWithWhereWithoutFk_nim_khsInput, tb_mhsUpdateWithoutFk_nim_khsInput>, tb_mhsUncheckedUpdateWithoutFk_nim_khsInput>
  }

  export type tb_mhsCreateNestedOneWithoutFk_nim_pklInput = {
    create?: XOR<tb_mhsCreateWithoutFk_nim_pklInput, tb_mhsUncheckedCreateWithoutFk_nim_pklInput>
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_nim_pklInput
    connect?: tb_mhsWhereUniqueInput
  }

  export type tb_mhsUpdateOneRequiredWithoutFk_nim_pklNestedInput = {
    create?: XOR<tb_mhsCreateWithoutFk_nim_pklInput, tb_mhsUncheckedCreateWithoutFk_nim_pklInput>
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_nim_pklInput
    upsert?: tb_mhsUpsertWithoutFk_nim_pklInput
    connect?: tb_mhsWhereUniqueInput
    update?: XOR<XOR<tb_mhsUpdateToOneWithWhereWithoutFk_nim_pklInput, tb_mhsUpdateWithoutFk_nim_pklInput>, tb_mhsUncheckedUpdateWithoutFk_nim_pklInput>
  }

  export type tb_mhsCreateNestedOneWithoutFk_nim_skripsiInput = {
    create?: XOR<tb_mhsCreateWithoutFk_nim_skripsiInput, tb_mhsUncheckedCreateWithoutFk_nim_skripsiInput>
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_nim_skripsiInput
    connect?: tb_mhsWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type tb_mhsUpdateOneRequiredWithoutFk_nim_skripsiNestedInput = {
    create?: XOR<tb_mhsCreateWithoutFk_nim_skripsiInput, tb_mhsUncheckedCreateWithoutFk_nim_skripsiInput>
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_nim_skripsiInput
    upsert?: tb_mhsUpsertWithoutFk_nim_skripsiInput
    connect?: tb_mhsWhereUniqueInput
    update?: XOR<XOR<tb_mhsUpdateToOneWithWhereWithoutFk_nim_skripsiInput, tb_mhsUpdateWithoutFk_nim_skripsiInput>, tb_mhsUncheckedUpdateWithoutFk_nim_skripsiInput>
  }

  export type tb_mhsCreateNestedManyWithoutFk_kodeProvInput = {
    create?: XOR<tb_mhsCreateWithoutFk_kodeProvInput, tb_mhsUncheckedCreateWithoutFk_kodeProvInput> | tb_mhsCreateWithoutFk_kodeProvInput[] | tb_mhsUncheckedCreateWithoutFk_kodeProvInput[]
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_kodeProvInput | tb_mhsCreateOrConnectWithoutFk_kodeProvInput[]
    createMany?: tb_mhsCreateManyFk_kodeProvInputEnvelope
    connect?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
  }

  export type tb_dosenCreateNestedManyWithoutFk_kodeProvInput = {
    create?: XOR<tb_dosenCreateWithoutFk_kodeProvInput, tb_dosenUncheckedCreateWithoutFk_kodeProvInput> | tb_dosenCreateWithoutFk_kodeProvInput[] | tb_dosenUncheckedCreateWithoutFk_kodeProvInput[]
    connectOrCreate?: tb_dosenCreateOrConnectWithoutFk_kodeProvInput | tb_dosenCreateOrConnectWithoutFk_kodeProvInput[]
    createMany?: tb_dosenCreateManyFk_kodeProvInputEnvelope
    connect?: tb_dosenWhereUniqueInput | tb_dosenWhereUniqueInput[]
  }

  export type tb_kabupatenCreateNestedManyWithoutFk_kodeProvInput = {
    create?: XOR<tb_kabupatenCreateWithoutFk_kodeProvInput, tb_kabupatenUncheckedCreateWithoutFk_kodeProvInput> | tb_kabupatenCreateWithoutFk_kodeProvInput[] | tb_kabupatenUncheckedCreateWithoutFk_kodeProvInput[]
    connectOrCreate?: tb_kabupatenCreateOrConnectWithoutFk_kodeProvInput | tb_kabupatenCreateOrConnectWithoutFk_kodeProvInput[]
    createMany?: tb_kabupatenCreateManyFk_kodeProvInputEnvelope
    connect?: tb_kabupatenWhereUniqueInput | tb_kabupatenWhereUniqueInput[]
  }

  export type tb_mhsUncheckedCreateNestedManyWithoutFk_kodeProvInput = {
    create?: XOR<tb_mhsCreateWithoutFk_kodeProvInput, tb_mhsUncheckedCreateWithoutFk_kodeProvInput> | tb_mhsCreateWithoutFk_kodeProvInput[] | tb_mhsUncheckedCreateWithoutFk_kodeProvInput[]
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_kodeProvInput | tb_mhsCreateOrConnectWithoutFk_kodeProvInput[]
    createMany?: tb_mhsCreateManyFk_kodeProvInputEnvelope
    connect?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
  }

  export type tb_dosenUncheckedCreateNestedManyWithoutFk_kodeProvInput = {
    create?: XOR<tb_dosenCreateWithoutFk_kodeProvInput, tb_dosenUncheckedCreateWithoutFk_kodeProvInput> | tb_dosenCreateWithoutFk_kodeProvInput[] | tb_dosenUncheckedCreateWithoutFk_kodeProvInput[]
    connectOrCreate?: tb_dosenCreateOrConnectWithoutFk_kodeProvInput | tb_dosenCreateOrConnectWithoutFk_kodeProvInput[]
    createMany?: tb_dosenCreateManyFk_kodeProvInputEnvelope
    connect?: tb_dosenWhereUniqueInput | tb_dosenWhereUniqueInput[]
  }

  export type tb_kabupatenUncheckedCreateNestedManyWithoutFk_kodeProvInput = {
    create?: XOR<tb_kabupatenCreateWithoutFk_kodeProvInput, tb_kabupatenUncheckedCreateWithoutFk_kodeProvInput> | tb_kabupatenCreateWithoutFk_kodeProvInput[] | tb_kabupatenUncheckedCreateWithoutFk_kodeProvInput[]
    connectOrCreate?: tb_kabupatenCreateOrConnectWithoutFk_kodeProvInput | tb_kabupatenCreateOrConnectWithoutFk_kodeProvInput[]
    createMany?: tb_kabupatenCreateManyFk_kodeProvInputEnvelope
    connect?: tb_kabupatenWhereUniqueInput | tb_kabupatenWhereUniqueInput[]
  }

  export type tb_mhsUpdateManyWithoutFk_kodeProvNestedInput = {
    create?: XOR<tb_mhsCreateWithoutFk_kodeProvInput, tb_mhsUncheckedCreateWithoutFk_kodeProvInput> | tb_mhsCreateWithoutFk_kodeProvInput[] | tb_mhsUncheckedCreateWithoutFk_kodeProvInput[]
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_kodeProvInput | tb_mhsCreateOrConnectWithoutFk_kodeProvInput[]
    upsert?: tb_mhsUpsertWithWhereUniqueWithoutFk_kodeProvInput | tb_mhsUpsertWithWhereUniqueWithoutFk_kodeProvInput[]
    createMany?: tb_mhsCreateManyFk_kodeProvInputEnvelope
    set?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    disconnect?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    delete?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    connect?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    update?: tb_mhsUpdateWithWhereUniqueWithoutFk_kodeProvInput | tb_mhsUpdateWithWhereUniqueWithoutFk_kodeProvInput[]
    updateMany?: tb_mhsUpdateManyWithWhereWithoutFk_kodeProvInput | tb_mhsUpdateManyWithWhereWithoutFk_kodeProvInput[]
    deleteMany?: tb_mhsScalarWhereInput | tb_mhsScalarWhereInput[]
  }

  export type tb_dosenUpdateManyWithoutFk_kodeProvNestedInput = {
    create?: XOR<tb_dosenCreateWithoutFk_kodeProvInput, tb_dosenUncheckedCreateWithoutFk_kodeProvInput> | tb_dosenCreateWithoutFk_kodeProvInput[] | tb_dosenUncheckedCreateWithoutFk_kodeProvInput[]
    connectOrCreate?: tb_dosenCreateOrConnectWithoutFk_kodeProvInput | tb_dosenCreateOrConnectWithoutFk_kodeProvInput[]
    upsert?: tb_dosenUpsertWithWhereUniqueWithoutFk_kodeProvInput | tb_dosenUpsertWithWhereUniqueWithoutFk_kodeProvInput[]
    createMany?: tb_dosenCreateManyFk_kodeProvInputEnvelope
    set?: tb_dosenWhereUniqueInput | tb_dosenWhereUniqueInput[]
    disconnect?: tb_dosenWhereUniqueInput | tb_dosenWhereUniqueInput[]
    delete?: tb_dosenWhereUniqueInput | tb_dosenWhereUniqueInput[]
    connect?: tb_dosenWhereUniqueInput | tb_dosenWhereUniqueInput[]
    update?: tb_dosenUpdateWithWhereUniqueWithoutFk_kodeProvInput | tb_dosenUpdateWithWhereUniqueWithoutFk_kodeProvInput[]
    updateMany?: tb_dosenUpdateManyWithWhereWithoutFk_kodeProvInput | tb_dosenUpdateManyWithWhereWithoutFk_kodeProvInput[]
    deleteMany?: tb_dosenScalarWhereInput | tb_dosenScalarWhereInput[]
  }

  export type tb_kabupatenUpdateManyWithoutFk_kodeProvNestedInput = {
    create?: XOR<tb_kabupatenCreateWithoutFk_kodeProvInput, tb_kabupatenUncheckedCreateWithoutFk_kodeProvInput> | tb_kabupatenCreateWithoutFk_kodeProvInput[] | tb_kabupatenUncheckedCreateWithoutFk_kodeProvInput[]
    connectOrCreate?: tb_kabupatenCreateOrConnectWithoutFk_kodeProvInput | tb_kabupatenCreateOrConnectWithoutFk_kodeProvInput[]
    upsert?: tb_kabupatenUpsertWithWhereUniqueWithoutFk_kodeProvInput | tb_kabupatenUpsertWithWhereUniqueWithoutFk_kodeProvInput[]
    createMany?: tb_kabupatenCreateManyFk_kodeProvInputEnvelope
    set?: tb_kabupatenWhereUniqueInput | tb_kabupatenWhereUniqueInput[]
    disconnect?: tb_kabupatenWhereUniqueInput | tb_kabupatenWhereUniqueInput[]
    delete?: tb_kabupatenWhereUniqueInput | tb_kabupatenWhereUniqueInput[]
    connect?: tb_kabupatenWhereUniqueInput | tb_kabupatenWhereUniqueInput[]
    update?: tb_kabupatenUpdateWithWhereUniqueWithoutFk_kodeProvInput | tb_kabupatenUpdateWithWhereUniqueWithoutFk_kodeProvInput[]
    updateMany?: tb_kabupatenUpdateManyWithWhereWithoutFk_kodeProvInput | tb_kabupatenUpdateManyWithWhereWithoutFk_kodeProvInput[]
    deleteMany?: tb_kabupatenScalarWhereInput | tb_kabupatenScalarWhereInput[]
  }

  export type tb_mhsUncheckedUpdateManyWithoutFk_kodeProvNestedInput = {
    create?: XOR<tb_mhsCreateWithoutFk_kodeProvInput, tb_mhsUncheckedCreateWithoutFk_kodeProvInput> | tb_mhsCreateWithoutFk_kodeProvInput[] | tb_mhsUncheckedCreateWithoutFk_kodeProvInput[]
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_kodeProvInput | tb_mhsCreateOrConnectWithoutFk_kodeProvInput[]
    upsert?: tb_mhsUpsertWithWhereUniqueWithoutFk_kodeProvInput | tb_mhsUpsertWithWhereUniqueWithoutFk_kodeProvInput[]
    createMany?: tb_mhsCreateManyFk_kodeProvInputEnvelope
    set?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    disconnect?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    delete?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    connect?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    update?: tb_mhsUpdateWithWhereUniqueWithoutFk_kodeProvInput | tb_mhsUpdateWithWhereUniqueWithoutFk_kodeProvInput[]
    updateMany?: tb_mhsUpdateManyWithWhereWithoutFk_kodeProvInput | tb_mhsUpdateManyWithWhereWithoutFk_kodeProvInput[]
    deleteMany?: tb_mhsScalarWhereInput | tb_mhsScalarWhereInput[]
  }

  export type tb_dosenUncheckedUpdateManyWithoutFk_kodeProvNestedInput = {
    create?: XOR<tb_dosenCreateWithoutFk_kodeProvInput, tb_dosenUncheckedCreateWithoutFk_kodeProvInput> | tb_dosenCreateWithoutFk_kodeProvInput[] | tb_dosenUncheckedCreateWithoutFk_kodeProvInput[]
    connectOrCreate?: tb_dosenCreateOrConnectWithoutFk_kodeProvInput | tb_dosenCreateOrConnectWithoutFk_kodeProvInput[]
    upsert?: tb_dosenUpsertWithWhereUniqueWithoutFk_kodeProvInput | tb_dosenUpsertWithWhereUniqueWithoutFk_kodeProvInput[]
    createMany?: tb_dosenCreateManyFk_kodeProvInputEnvelope
    set?: tb_dosenWhereUniqueInput | tb_dosenWhereUniqueInput[]
    disconnect?: tb_dosenWhereUniqueInput | tb_dosenWhereUniqueInput[]
    delete?: tb_dosenWhereUniqueInput | tb_dosenWhereUniqueInput[]
    connect?: tb_dosenWhereUniqueInput | tb_dosenWhereUniqueInput[]
    update?: tb_dosenUpdateWithWhereUniqueWithoutFk_kodeProvInput | tb_dosenUpdateWithWhereUniqueWithoutFk_kodeProvInput[]
    updateMany?: tb_dosenUpdateManyWithWhereWithoutFk_kodeProvInput | tb_dosenUpdateManyWithWhereWithoutFk_kodeProvInput[]
    deleteMany?: tb_dosenScalarWhereInput | tb_dosenScalarWhereInput[]
  }

  export type tb_kabupatenUncheckedUpdateManyWithoutFk_kodeProvNestedInput = {
    create?: XOR<tb_kabupatenCreateWithoutFk_kodeProvInput, tb_kabupatenUncheckedCreateWithoutFk_kodeProvInput> | tb_kabupatenCreateWithoutFk_kodeProvInput[] | tb_kabupatenUncheckedCreateWithoutFk_kodeProvInput[]
    connectOrCreate?: tb_kabupatenCreateOrConnectWithoutFk_kodeProvInput | tb_kabupatenCreateOrConnectWithoutFk_kodeProvInput[]
    upsert?: tb_kabupatenUpsertWithWhereUniqueWithoutFk_kodeProvInput | tb_kabupatenUpsertWithWhereUniqueWithoutFk_kodeProvInput[]
    createMany?: tb_kabupatenCreateManyFk_kodeProvInputEnvelope
    set?: tb_kabupatenWhereUniqueInput | tb_kabupatenWhereUniqueInput[]
    disconnect?: tb_kabupatenWhereUniqueInput | tb_kabupatenWhereUniqueInput[]
    delete?: tb_kabupatenWhereUniqueInput | tb_kabupatenWhereUniqueInput[]
    connect?: tb_kabupatenWhereUniqueInput | tb_kabupatenWhereUniqueInput[]
    update?: tb_kabupatenUpdateWithWhereUniqueWithoutFk_kodeProvInput | tb_kabupatenUpdateWithWhereUniqueWithoutFk_kodeProvInput[]
    updateMany?: tb_kabupatenUpdateManyWithWhereWithoutFk_kodeProvInput | tb_kabupatenUpdateManyWithWhereWithoutFk_kodeProvInput[]
    deleteMany?: tb_kabupatenScalarWhereInput | tb_kabupatenScalarWhereInput[]
  }

  export type tb_provinsiCreateNestedOneWithoutFk_kodeProv_kabupatenInput = {
    create?: XOR<tb_provinsiCreateWithoutFk_kodeProv_kabupatenInput, tb_provinsiUncheckedCreateWithoutFk_kodeProv_kabupatenInput>
    connectOrCreate?: tb_provinsiCreateOrConnectWithoutFk_kodeProv_kabupatenInput
    connect?: tb_provinsiWhereUniqueInput
  }

  export type tb_mhsCreateNestedManyWithoutFk_kodeKabInput = {
    create?: XOR<tb_mhsCreateWithoutFk_kodeKabInput, tb_mhsUncheckedCreateWithoutFk_kodeKabInput> | tb_mhsCreateWithoutFk_kodeKabInput[] | tb_mhsUncheckedCreateWithoutFk_kodeKabInput[]
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_kodeKabInput | tb_mhsCreateOrConnectWithoutFk_kodeKabInput[]
    createMany?: tb_mhsCreateManyFk_kodeKabInputEnvelope
    connect?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
  }

  export type tb_dosenCreateNestedManyWithoutFk_kodeKabInput = {
    create?: XOR<tb_dosenCreateWithoutFk_kodeKabInput, tb_dosenUncheckedCreateWithoutFk_kodeKabInput> | tb_dosenCreateWithoutFk_kodeKabInput[] | tb_dosenUncheckedCreateWithoutFk_kodeKabInput[]
    connectOrCreate?: tb_dosenCreateOrConnectWithoutFk_kodeKabInput | tb_dosenCreateOrConnectWithoutFk_kodeKabInput[]
    createMany?: tb_dosenCreateManyFk_kodeKabInputEnvelope
    connect?: tb_dosenWhereUniqueInput | tb_dosenWhereUniqueInput[]
  }

  export type tb_mhsUncheckedCreateNestedManyWithoutFk_kodeKabInput = {
    create?: XOR<tb_mhsCreateWithoutFk_kodeKabInput, tb_mhsUncheckedCreateWithoutFk_kodeKabInput> | tb_mhsCreateWithoutFk_kodeKabInput[] | tb_mhsUncheckedCreateWithoutFk_kodeKabInput[]
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_kodeKabInput | tb_mhsCreateOrConnectWithoutFk_kodeKabInput[]
    createMany?: tb_mhsCreateManyFk_kodeKabInputEnvelope
    connect?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
  }

  export type tb_dosenUncheckedCreateNestedManyWithoutFk_kodeKabInput = {
    create?: XOR<tb_dosenCreateWithoutFk_kodeKabInput, tb_dosenUncheckedCreateWithoutFk_kodeKabInput> | tb_dosenCreateWithoutFk_kodeKabInput[] | tb_dosenUncheckedCreateWithoutFk_kodeKabInput[]
    connectOrCreate?: tb_dosenCreateOrConnectWithoutFk_kodeKabInput | tb_dosenCreateOrConnectWithoutFk_kodeKabInput[]
    createMany?: tb_dosenCreateManyFk_kodeKabInputEnvelope
    connect?: tb_dosenWhereUniqueInput | tb_dosenWhereUniqueInput[]
  }

  export type tb_provinsiUpdateOneRequiredWithoutFk_kodeProv_kabupatenNestedInput = {
    create?: XOR<tb_provinsiCreateWithoutFk_kodeProv_kabupatenInput, tb_provinsiUncheckedCreateWithoutFk_kodeProv_kabupatenInput>
    connectOrCreate?: tb_provinsiCreateOrConnectWithoutFk_kodeProv_kabupatenInput
    upsert?: tb_provinsiUpsertWithoutFk_kodeProv_kabupatenInput
    connect?: tb_provinsiWhereUniqueInput
    update?: XOR<XOR<tb_provinsiUpdateToOneWithWhereWithoutFk_kodeProv_kabupatenInput, tb_provinsiUpdateWithoutFk_kodeProv_kabupatenInput>, tb_provinsiUncheckedUpdateWithoutFk_kodeProv_kabupatenInput>
  }

  export type tb_mhsUpdateManyWithoutFk_kodeKabNestedInput = {
    create?: XOR<tb_mhsCreateWithoutFk_kodeKabInput, tb_mhsUncheckedCreateWithoutFk_kodeKabInput> | tb_mhsCreateWithoutFk_kodeKabInput[] | tb_mhsUncheckedCreateWithoutFk_kodeKabInput[]
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_kodeKabInput | tb_mhsCreateOrConnectWithoutFk_kodeKabInput[]
    upsert?: tb_mhsUpsertWithWhereUniqueWithoutFk_kodeKabInput | tb_mhsUpsertWithWhereUniqueWithoutFk_kodeKabInput[]
    createMany?: tb_mhsCreateManyFk_kodeKabInputEnvelope
    set?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    disconnect?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    delete?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    connect?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    update?: tb_mhsUpdateWithWhereUniqueWithoutFk_kodeKabInput | tb_mhsUpdateWithWhereUniqueWithoutFk_kodeKabInput[]
    updateMany?: tb_mhsUpdateManyWithWhereWithoutFk_kodeKabInput | tb_mhsUpdateManyWithWhereWithoutFk_kodeKabInput[]
    deleteMany?: tb_mhsScalarWhereInput | tb_mhsScalarWhereInput[]
  }

  export type tb_dosenUpdateManyWithoutFk_kodeKabNestedInput = {
    create?: XOR<tb_dosenCreateWithoutFk_kodeKabInput, tb_dosenUncheckedCreateWithoutFk_kodeKabInput> | tb_dosenCreateWithoutFk_kodeKabInput[] | tb_dosenUncheckedCreateWithoutFk_kodeKabInput[]
    connectOrCreate?: tb_dosenCreateOrConnectWithoutFk_kodeKabInput | tb_dosenCreateOrConnectWithoutFk_kodeKabInput[]
    upsert?: tb_dosenUpsertWithWhereUniqueWithoutFk_kodeKabInput | tb_dosenUpsertWithWhereUniqueWithoutFk_kodeKabInput[]
    createMany?: tb_dosenCreateManyFk_kodeKabInputEnvelope
    set?: tb_dosenWhereUniqueInput | tb_dosenWhereUniqueInput[]
    disconnect?: tb_dosenWhereUniqueInput | tb_dosenWhereUniqueInput[]
    delete?: tb_dosenWhereUniqueInput | tb_dosenWhereUniqueInput[]
    connect?: tb_dosenWhereUniqueInput | tb_dosenWhereUniqueInput[]
    update?: tb_dosenUpdateWithWhereUniqueWithoutFk_kodeKabInput | tb_dosenUpdateWithWhereUniqueWithoutFk_kodeKabInput[]
    updateMany?: tb_dosenUpdateManyWithWhereWithoutFk_kodeKabInput | tb_dosenUpdateManyWithWhereWithoutFk_kodeKabInput[]
    deleteMany?: tb_dosenScalarWhereInput | tb_dosenScalarWhereInput[]
  }

  export type tb_mhsUncheckedUpdateManyWithoutFk_kodeKabNestedInput = {
    create?: XOR<tb_mhsCreateWithoutFk_kodeKabInput, tb_mhsUncheckedCreateWithoutFk_kodeKabInput> | tb_mhsCreateWithoutFk_kodeKabInput[] | tb_mhsUncheckedCreateWithoutFk_kodeKabInput[]
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_kodeKabInput | tb_mhsCreateOrConnectWithoutFk_kodeKabInput[]
    upsert?: tb_mhsUpsertWithWhereUniqueWithoutFk_kodeKabInput | tb_mhsUpsertWithWhereUniqueWithoutFk_kodeKabInput[]
    createMany?: tb_mhsCreateManyFk_kodeKabInputEnvelope
    set?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    disconnect?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    delete?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    connect?: tb_mhsWhereUniqueInput | tb_mhsWhereUniqueInput[]
    update?: tb_mhsUpdateWithWhereUniqueWithoutFk_kodeKabInput | tb_mhsUpdateWithWhereUniqueWithoutFk_kodeKabInput[]
    updateMany?: tb_mhsUpdateManyWithWhereWithoutFk_kodeKabInput | tb_mhsUpdateManyWithWhereWithoutFk_kodeKabInput[]
    deleteMany?: tb_mhsScalarWhereInput | tb_mhsScalarWhereInput[]
  }

  export type tb_dosenUncheckedUpdateManyWithoutFk_kodeKabNestedInput = {
    create?: XOR<tb_dosenCreateWithoutFk_kodeKabInput, tb_dosenUncheckedCreateWithoutFk_kodeKabInput> | tb_dosenCreateWithoutFk_kodeKabInput[] | tb_dosenUncheckedCreateWithoutFk_kodeKabInput[]
    connectOrCreate?: tb_dosenCreateOrConnectWithoutFk_kodeKabInput | tb_dosenCreateOrConnectWithoutFk_kodeKabInput[]
    upsert?: tb_dosenUpsertWithWhereUniqueWithoutFk_kodeKabInput | tb_dosenUpsertWithWhereUniqueWithoutFk_kodeKabInput[]
    createMany?: tb_dosenCreateManyFk_kodeKabInputEnvelope
    set?: tb_dosenWhereUniqueInput | tb_dosenWhereUniqueInput[]
    disconnect?: tb_dosenWhereUniqueInput | tb_dosenWhereUniqueInput[]
    delete?: tb_dosenWhereUniqueInput | tb_dosenWhereUniqueInput[]
    connect?: tb_dosenWhereUniqueInput | tb_dosenWhereUniqueInput[]
    update?: tb_dosenUpdateWithWhereUniqueWithoutFk_kodeKabInput | tb_dosenUpdateWithWhereUniqueWithoutFk_kodeKabInput[]
    updateMany?: tb_dosenUpdateManyWithWhereWithoutFk_kodeKabInput | tb_dosenUpdateManyWithWhereWithoutFk_kodeKabInput[]
    deleteMany?: tb_dosenScalarWhereInput | tb_dosenScalarWhereInput[]
  }

  export type tb_mhsCreateNestedOneWithoutFk_pemilik_akun_mhsInput = {
    create?: XOR<tb_mhsCreateWithoutFk_pemilik_akun_mhsInput, tb_mhsUncheckedCreateWithoutFk_pemilik_akun_mhsInput>
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_pemilik_akun_mhsInput
    connect?: tb_mhsWhereUniqueInput
  }

  export type EnumStatusAkunFieldUpdateOperationsInput = {
    set?: $Enums.StatusAkun
  }

  export type tb_mhsUpdateOneRequiredWithoutFk_pemilik_akun_mhsNestedInput = {
    create?: XOR<tb_mhsCreateWithoutFk_pemilik_akun_mhsInput, tb_mhsUncheckedCreateWithoutFk_pemilik_akun_mhsInput>
    connectOrCreate?: tb_mhsCreateOrConnectWithoutFk_pemilik_akun_mhsInput
    upsert?: tb_mhsUpsertWithoutFk_pemilik_akun_mhsInput
    connect?: tb_mhsWhereUniqueInput
    update?: XOR<XOR<tb_mhsUpdateToOneWithWhereWithoutFk_pemilik_akun_mhsInput, tb_mhsUpdateWithoutFk_pemilik_akun_mhsInput>, tb_mhsUncheckedUpdateWithoutFk_pemilik_akun_mhsInput>
  }

  export type tb_dosenCreateNestedOneWithoutFk_pemilik_akun_dosenInput = {
    create?: XOR<tb_dosenCreateWithoutFk_pemilik_akun_dosenInput, tb_dosenUncheckedCreateWithoutFk_pemilik_akun_dosenInput>
    connectOrCreate?: tb_dosenCreateOrConnectWithoutFk_pemilik_akun_dosenInput
    connect?: tb_dosenWhereUniqueInput
  }

  export type tb_role_akun_dosenCreateNestedManyWithoutFk_usernameInput = {
    create?: XOR<tb_role_akun_dosenCreateWithoutFk_usernameInput, tb_role_akun_dosenUncheckedCreateWithoutFk_usernameInput> | tb_role_akun_dosenCreateWithoutFk_usernameInput[] | tb_role_akun_dosenUncheckedCreateWithoutFk_usernameInput[]
    connectOrCreate?: tb_role_akun_dosenCreateOrConnectWithoutFk_usernameInput | tb_role_akun_dosenCreateOrConnectWithoutFk_usernameInput[]
    createMany?: tb_role_akun_dosenCreateManyFk_usernameInputEnvelope
    connect?: tb_role_akun_dosenWhereUniqueInput | tb_role_akun_dosenWhereUniqueInput[]
  }

  export type tb_role_akun_dosenUncheckedCreateNestedManyWithoutFk_usernameInput = {
    create?: XOR<tb_role_akun_dosenCreateWithoutFk_usernameInput, tb_role_akun_dosenUncheckedCreateWithoutFk_usernameInput> | tb_role_akun_dosenCreateWithoutFk_usernameInput[] | tb_role_akun_dosenUncheckedCreateWithoutFk_usernameInput[]
    connectOrCreate?: tb_role_akun_dosenCreateOrConnectWithoutFk_usernameInput | tb_role_akun_dosenCreateOrConnectWithoutFk_usernameInput[]
    createMany?: tb_role_akun_dosenCreateManyFk_usernameInputEnvelope
    connect?: tb_role_akun_dosenWhereUniqueInput | tb_role_akun_dosenWhereUniqueInput[]
  }

  export type tb_dosenUpdateOneRequiredWithoutFk_pemilik_akun_dosenNestedInput = {
    create?: XOR<tb_dosenCreateWithoutFk_pemilik_akun_dosenInput, tb_dosenUncheckedCreateWithoutFk_pemilik_akun_dosenInput>
    connectOrCreate?: tb_dosenCreateOrConnectWithoutFk_pemilik_akun_dosenInput
    upsert?: tb_dosenUpsertWithoutFk_pemilik_akun_dosenInput
    connect?: tb_dosenWhereUniqueInput
    update?: XOR<XOR<tb_dosenUpdateToOneWithWhereWithoutFk_pemilik_akun_dosenInput, tb_dosenUpdateWithoutFk_pemilik_akun_dosenInput>, tb_dosenUncheckedUpdateWithoutFk_pemilik_akun_dosenInput>
  }

  export type tb_role_akun_dosenUpdateManyWithoutFk_usernameNestedInput = {
    create?: XOR<tb_role_akun_dosenCreateWithoutFk_usernameInput, tb_role_akun_dosenUncheckedCreateWithoutFk_usernameInput> | tb_role_akun_dosenCreateWithoutFk_usernameInput[] | tb_role_akun_dosenUncheckedCreateWithoutFk_usernameInput[]
    connectOrCreate?: tb_role_akun_dosenCreateOrConnectWithoutFk_usernameInput | tb_role_akun_dosenCreateOrConnectWithoutFk_usernameInput[]
    upsert?: tb_role_akun_dosenUpsertWithWhereUniqueWithoutFk_usernameInput | tb_role_akun_dosenUpsertWithWhereUniqueWithoutFk_usernameInput[]
    createMany?: tb_role_akun_dosenCreateManyFk_usernameInputEnvelope
    set?: tb_role_akun_dosenWhereUniqueInput | tb_role_akun_dosenWhereUniqueInput[]
    disconnect?: tb_role_akun_dosenWhereUniqueInput | tb_role_akun_dosenWhereUniqueInput[]
    delete?: tb_role_akun_dosenWhereUniqueInput | tb_role_akun_dosenWhereUniqueInput[]
    connect?: tb_role_akun_dosenWhereUniqueInput | tb_role_akun_dosenWhereUniqueInput[]
    update?: tb_role_akun_dosenUpdateWithWhereUniqueWithoutFk_usernameInput | tb_role_akun_dosenUpdateWithWhereUniqueWithoutFk_usernameInput[]
    updateMany?: tb_role_akun_dosenUpdateManyWithWhereWithoutFk_usernameInput | tb_role_akun_dosenUpdateManyWithWhereWithoutFk_usernameInput[]
    deleteMany?: tb_role_akun_dosenScalarWhereInput | tb_role_akun_dosenScalarWhereInput[]
  }

  export type tb_role_akun_dosenUncheckedUpdateManyWithoutFk_usernameNestedInput = {
    create?: XOR<tb_role_akun_dosenCreateWithoutFk_usernameInput, tb_role_akun_dosenUncheckedCreateWithoutFk_usernameInput> | tb_role_akun_dosenCreateWithoutFk_usernameInput[] | tb_role_akun_dosenUncheckedCreateWithoutFk_usernameInput[]
    connectOrCreate?: tb_role_akun_dosenCreateOrConnectWithoutFk_usernameInput | tb_role_akun_dosenCreateOrConnectWithoutFk_usernameInput[]
    upsert?: tb_role_akun_dosenUpsertWithWhereUniqueWithoutFk_usernameInput | tb_role_akun_dosenUpsertWithWhereUniqueWithoutFk_usernameInput[]
    createMany?: tb_role_akun_dosenCreateManyFk_usernameInputEnvelope
    set?: tb_role_akun_dosenWhereUniqueInput | tb_role_akun_dosenWhereUniqueInput[]
    disconnect?: tb_role_akun_dosenWhereUniqueInput | tb_role_akun_dosenWhereUniqueInput[]
    delete?: tb_role_akun_dosenWhereUniqueInput | tb_role_akun_dosenWhereUniqueInput[]
    connect?: tb_role_akun_dosenWhereUniqueInput | tb_role_akun_dosenWhereUniqueInput[]
    update?: tb_role_akun_dosenUpdateWithWhereUniqueWithoutFk_usernameInput | tb_role_akun_dosenUpdateWithWhereUniqueWithoutFk_usernameInput[]
    updateMany?: tb_role_akun_dosenUpdateManyWithWhereWithoutFk_usernameInput | tb_role_akun_dosenUpdateManyWithWhereWithoutFk_usernameInput[]
    deleteMany?: tb_role_akun_dosenScalarWhereInput | tb_role_akun_dosenScalarWhereInput[]
  }

  export type tb_akun_dosenCreateNestedOneWithoutFk_username_roleInput = {
    create?: XOR<tb_akun_dosenCreateWithoutFk_username_roleInput, tb_akun_dosenUncheckedCreateWithoutFk_username_roleInput>
    connectOrCreate?: tb_akun_dosenCreateOrConnectWithoutFk_username_roleInput
    connect?: tb_akun_dosenWhereUniqueInput
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type tb_akun_dosenUpdateOneRequiredWithoutFk_username_roleNestedInput = {
    create?: XOR<tb_akun_dosenCreateWithoutFk_username_roleInput, tb_akun_dosenUncheckedCreateWithoutFk_username_roleInput>
    connectOrCreate?: tb_akun_dosenCreateOrConnectWithoutFk_username_roleInput
    upsert?: tb_akun_dosenUpsertWithoutFk_username_roleInput
    connect?: tb_akun_dosenWhereUniqueInput
    update?: XOR<XOR<tb_akun_dosenUpdateToOneWithWhereWithoutFk_username_roleInput, tb_akun_dosenUpdateWithoutFk_username_roleInput>, tb_akun_dosenUncheckedUpdateWithoutFk_username_roleInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumStatusMhsFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusMhs | EnumStatusMhsFieldRefInput<$PrismaModel>
    in?: $Enums.StatusMhs[] | ListEnumStatusMhsFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusMhs[] | ListEnumStatusMhsFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusMhsFilter<$PrismaModel> | $Enums.StatusMhs
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumJalurMasukFilter<$PrismaModel = never> = {
    equals?: $Enums.JalurMasuk | EnumJalurMasukFieldRefInput<$PrismaModel>
    in?: $Enums.JalurMasuk[] | ListEnumJalurMasukFieldRefInput<$PrismaModel>
    notIn?: $Enums.JalurMasuk[] | ListEnumJalurMasukFieldRefInput<$PrismaModel>
    not?: NestedEnumJalurMasukFilter<$PrismaModel> | $Enums.JalurMasuk
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumStatusMhsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusMhs | EnumStatusMhsFieldRefInput<$PrismaModel>
    in?: $Enums.StatusMhs[] | ListEnumStatusMhsFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusMhs[] | ListEnumStatusMhsFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusMhsWithAggregatesFilter<$PrismaModel> | $Enums.StatusMhs
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusMhsFilter<$PrismaModel>
    _max?: NestedEnumStatusMhsFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumJalurMasukWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JalurMasuk | EnumJalurMasukFieldRefInput<$PrismaModel>
    in?: $Enums.JalurMasuk[] | ListEnumJalurMasukFieldRefInput<$PrismaModel>
    notIn?: $Enums.JalurMasuk[] | ListEnumJalurMasukFieldRefInput<$PrismaModel>
    not?: NestedEnumJalurMasukWithAggregatesFilter<$PrismaModel> | $Enums.JalurMasuk
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJalurMasukFilter<$PrismaModel>
    _max?: NestedEnumJalurMasukFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumStatusAktifFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusAktif | EnumStatusAktifFieldRefInput<$PrismaModel>
    in?: $Enums.StatusAktif[] | ListEnumStatusAktifFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusAktif[] | ListEnumStatusAktifFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusAktifFilter<$PrismaModel> | $Enums.StatusAktif
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumStatusAktifWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusAktif | EnumStatusAktifFieldRefInput<$PrismaModel>
    in?: $Enums.StatusAktif[] | ListEnumStatusAktifFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusAktif[] | ListEnumStatusAktifFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusAktifWithAggregatesFilter<$PrismaModel> | $Enums.StatusAktif
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusAktifFilter<$PrismaModel>
    _max?: NestedEnumStatusAktifFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumStatusAkunFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusAkun | EnumStatusAkunFieldRefInput<$PrismaModel>
    in?: $Enums.StatusAkun[] | ListEnumStatusAkunFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusAkun[] | ListEnumStatusAkunFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusAkunFilter<$PrismaModel> | $Enums.StatusAkun
  }

  export type NestedEnumStatusAkunWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusAkun | EnumStatusAkunFieldRefInput<$PrismaModel>
    in?: $Enums.StatusAkun[] | ListEnumStatusAkunFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusAkun[] | ListEnumStatusAkunFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusAkunWithAggregatesFilter<$PrismaModel> | $Enums.StatusAkun
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusAkunFilter<$PrismaModel>
    _max?: NestedEnumStatusAkunFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type tb_kabupatenCreateWithoutFk_kodeKab_mhsInput = {
    kodeKab: string
    namaKab: string
    fk_kodeProv: tb_provinsiCreateNestedOneWithoutFk_kodeProv_kabupatenInput
    fk_kodeKab_dosen?: tb_dosenCreateNestedManyWithoutFk_kodeKabInput
  }

  export type tb_kabupatenUncheckedCreateWithoutFk_kodeKab_mhsInput = {
    kodeKab: string
    namaKab: string
    kodeProv: string
    fk_kodeKab_dosen?: tb_dosenUncheckedCreateNestedManyWithoutFk_kodeKabInput
  }

  export type tb_kabupatenCreateOrConnectWithoutFk_kodeKab_mhsInput = {
    where: tb_kabupatenWhereUniqueInput
    create: XOR<tb_kabupatenCreateWithoutFk_kodeKab_mhsInput, tb_kabupatenUncheckedCreateWithoutFk_kodeKab_mhsInput>
  }

  export type tb_provinsiCreateWithoutFk_kodeProv_mhsInput = {
    kodeProv: string
    namaProv: string
    fk_kodeProv_dosen?: tb_dosenCreateNestedManyWithoutFk_kodeProvInput
    fk_kodeProv_kabupaten?: tb_kabupatenCreateNestedManyWithoutFk_kodeProvInput
  }

  export type tb_provinsiUncheckedCreateWithoutFk_kodeProv_mhsInput = {
    kodeProv: string
    namaProv: string
    fk_kodeProv_dosen?: tb_dosenUncheckedCreateNestedManyWithoutFk_kodeProvInput
    fk_kodeProv_kabupaten?: tb_kabupatenUncheckedCreateNestedManyWithoutFk_kodeProvInput
  }

  export type tb_provinsiCreateOrConnectWithoutFk_kodeProv_mhsInput = {
    where: tb_provinsiWhereUniqueInput
    create: XOR<tb_provinsiCreateWithoutFk_kodeProv_mhsInput, tb_provinsiUncheckedCreateWithoutFk_kodeProv_mhsInput>
  }

  export type tb_dosenCreateWithoutFk_kodeWali_mhsInput = {
    nip: string
    nama: string
    alamat?: string | null
    email?: string | null
    noHP?: string | null
    foto?: string | null
    fk_kodeKab?: tb_kabupatenCreateNestedOneWithoutFk_kodeKab_dosenInput
    fk_kodeProv?: tb_provinsiCreateNestedOneWithoutFk_kodeProv_dosenInput
    fk_pemilik_akun_dosen?: tb_akun_dosenCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_dosenUncheckedCreateWithoutFk_kodeWali_mhsInput = {
    nip: string
    nama: string
    alamat?: string | null
    email?: string | null
    kodeKab?: string | null
    kodeProv?: string | null
    noHP?: string | null
    foto?: string | null
    fk_pemilik_akun_dosen?: tb_akun_dosenUncheckedCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_dosenCreateOrConnectWithoutFk_kodeWali_mhsInput = {
    where: tb_dosenWhereUniqueInput
    create: XOR<tb_dosenCreateWithoutFk_kodeWali_mhsInput, tb_dosenUncheckedCreateWithoutFk_kodeWali_mhsInput>
  }

  export type tb_irsCreateWithoutFk_nimInput = {
    semester: string
    status: $Enums.StatusAktif
    jumlahSks?: string | null
    fileIrs?: string | null
    statusValidasi?: boolean
  }

  export type tb_irsUncheckedCreateWithoutFk_nimInput = {
    semester: string
    status: $Enums.StatusAktif
    jumlahSks?: string | null
    fileIrs?: string | null
    statusValidasi?: boolean
  }

  export type tb_irsCreateOrConnectWithoutFk_nimInput = {
    where: tb_irsWhereUniqueInput
    create: XOR<tb_irsCreateWithoutFk_nimInput, tb_irsUncheckedCreateWithoutFk_nimInput>
  }

  export type tb_irsCreateManyFk_nimInputEnvelope = {
    data: tb_irsCreateManyFk_nimInput | tb_irsCreateManyFk_nimInput[]
    skipDuplicates?: boolean
  }

  export type tb_khsCreateWithoutFk_nimInput = {
    semester: string
    status: $Enums.StatusAktif
    jumlahSksSemester?: string | null
    ips?: string | null
    jumlahSksKumulatif?: string | null
    ipk?: string | null
    fileKhs?: string | null
    statusValidasi?: boolean
  }

  export type tb_khsUncheckedCreateWithoutFk_nimInput = {
    semester: string
    status: $Enums.StatusAktif
    jumlahSksSemester?: string | null
    ips?: string | null
    jumlahSksKumulatif?: string | null
    ipk?: string | null
    fileKhs?: string | null
    statusValidasi?: boolean
  }

  export type tb_khsCreateOrConnectWithoutFk_nimInput = {
    where: tb_khsWhereUniqueInput
    create: XOR<tb_khsCreateWithoutFk_nimInput, tb_khsUncheckedCreateWithoutFk_nimInput>
  }

  export type tb_khsCreateManyFk_nimInputEnvelope = {
    data: tb_khsCreateManyFk_nimInput | tb_khsCreateManyFk_nimInput[]
    skipDuplicates?: boolean
  }

  export type tb_pklCreateWithoutFk_nimInput = {
    semester: string
    nilai: string
    filePkl: string
    statusValidasi?: boolean
  }

  export type tb_pklUncheckedCreateWithoutFk_nimInput = {
    semester: string
    nilai: string
    filePkl: string
    statusValidasi?: boolean
  }

  export type tb_pklCreateOrConnectWithoutFk_nimInput = {
    where: tb_pklWhereUniqueInput
    create: XOR<tb_pklCreateWithoutFk_nimInput, tb_pklUncheckedCreateWithoutFk_nimInput>
  }

  export type tb_pklCreateManyFk_nimInputEnvelope = {
    data: tb_pklCreateManyFk_nimInput | tb_pklCreateManyFk_nimInput[]
    skipDuplicates?: boolean
  }

  export type tb_skripsiCreateWithoutFk_nimInput = {
    semester: string
    nilai: string
    tanggalLulusSidang: Date | string
    lamaStudi: number
    fileSkripsi: string
    statusValidasi?: boolean
  }

  export type tb_skripsiUncheckedCreateWithoutFk_nimInput = {
    semester: string
    nilai: string
    tanggalLulusSidang: Date | string
    lamaStudi: number
    fileSkripsi: string
    statusValidasi?: boolean
  }

  export type tb_skripsiCreateOrConnectWithoutFk_nimInput = {
    where: tb_skripsiWhereUniqueInput
    create: XOR<tb_skripsiCreateWithoutFk_nimInput, tb_skripsiUncheckedCreateWithoutFk_nimInput>
  }

  export type tb_skripsiCreateManyFk_nimInputEnvelope = {
    data: tb_skripsiCreateManyFk_nimInput | tb_skripsiCreateManyFk_nimInput[]
    skipDuplicates?: boolean
  }

  export type tb_akun_mhsCreateWithoutFk_pemilikInput = {
    username: string
    password: string
    status: $Enums.StatusAkun
  }

  export type tb_akun_mhsUncheckedCreateWithoutFk_pemilikInput = {
    username: string
    password: string
    status: $Enums.StatusAkun
  }

  export type tb_akun_mhsCreateOrConnectWithoutFk_pemilikInput = {
    where: tb_akun_mhsWhereUniqueInput
    create: XOR<tb_akun_mhsCreateWithoutFk_pemilikInput, tb_akun_mhsUncheckedCreateWithoutFk_pemilikInput>
  }

  export type tb_kabupatenUpsertWithoutFk_kodeKab_mhsInput = {
    update: XOR<tb_kabupatenUpdateWithoutFk_kodeKab_mhsInput, tb_kabupatenUncheckedUpdateWithoutFk_kodeKab_mhsInput>
    create: XOR<tb_kabupatenCreateWithoutFk_kodeKab_mhsInput, tb_kabupatenUncheckedCreateWithoutFk_kodeKab_mhsInput>
    where?: tb_kabupatenWhereInput
  }

  export type tb_kabupatenUpdateToOneWithWhereWithoutFk_kodeKab_mhsInput = {
    where?: tb_kabupatenWhereInput
    data: XOR<tb_kabupatenUpdateWithoutFk_kodeKab_mhsInput, tb_kabupatenUncheckedUpdateWithoutFk_kodeKab_mhsInput>
  }

  export type tb_kabupatenUpdateWithoutFk_kodeKab_mhsInput = {
    kodeKab?: StringFieldUpdateOperationsInput | string
    namaKab?: StringFieldUpdateOperationsInput | string
    fk_kodeProv?: tb_provinsiUpdateOneRequiredWithoutFk_kodeProv_kabupatenNestedInput
    fk_kodeKab_dosen?: tb_dosenUpdateManyWithoutFk_kodeKabNestedInput
  }

  export type tb_kabupatenUncheckedUpdateWithoutFk_kodeKab_mhsInput = {
    kodeKab?: StringFieldUpdateOperationsInput | string
    namaKab?: StringFieldUpdateOperationsInput | string
    kodeProv?: StringFieldUpdateOperationsInput | string
    fk_kodeKab_dosen?: tb_dosenUncheckedUpdateManyWithoutFk_kodeKabNestedInput
  }

  export type tb_provinsiUpsertWithoutFk_kodeProv_mhsInput = {
    update: XOR<tb_provinsiUpdateWithoutFk_kodeProv_mhsInput, tb_provinsiUncheckedUpdateWithoutFk_kodeProv_mhsInput>
    create: XOR<tb_provinsiCreateWithoutFk_kodeProv_mhsInput, tb_provinsiUncheckedCreateWithoutFk_kodeProv_mhsInput>
    where?: tb_provinsiWhereInput
  }

  export type tb_provinsiUpdateToOneWithWhereWithoutFk_kodeProv_mhsInput = {
    where?: tb_provinsiWhereInput
    data: XOR<tb_provinsiUpdateWithoutFk_kodeProv_mhsInput, tb_provinsiUncheckedUpdateWithoutFk_kodeProv_mhsInput>
  }

  export type tb_provinsiUpdateWithoutFk_kodeProv_mhsInput = {
    kodeProv?: StringFieldUpdateOperationsInput | string
    namaProv?: StringFieldUpdateOperationsInput | string
    fk_kodeProv_dosen?: tb_dosenUpdateManyWithoutFk_kodeProvNestedInput
    fk_kodeProv_kabupaten?: tb_kabupatenUpdateManyWithoutFk_kodeProvNestedInput
  }

  export type tb_provinsiUncheckedUpdateWithoutFk_kodeProv_mhsInput = {
    kodeProv?: StringFieldUpdateOperationsInput | string
    namaProv?: StringFieldUpdateOperationsInput | string
    fk_kodeProv_dosen?: tb_dosenUncheckedUpdateManyWithoutFk_kodeProvNestedInput
    fk_kodeProv_kabupaten?: tb_kabupatenUncheckedUpdateManyWithoutFk_kodeProvNestedInput
  }

  export type tb_dosenUpsertWithoutFk_kodeWali_mhsInput = {
    update: XOR<tb_dosenUpdateWithoutFk_kodeWali_mhsInput, tb_dosenUncheckedUpdateWithoutFk_kodeWali_mhsInput>
    create: XOR<tb_dosenCreateWithoutFk_kodeWali_mhsInput, tb_dosenUncheckedCreateWithoutFk_kodeWali_mhsInput>
    where?: tb_dosenWhereInput
  }

  export type tb_dosenUpdateToOneWithWhereWithoutFk_kodeWali_mhsInput = {
    where?: tb_dosenWhereInput
    data: XOR<tb_dosenUpdateWithoutFk_kodeWali_mhsInput, tb_dosenUncheckedUpdateWithoutFk_kodeWali_mhsInput>
  }

  export type tb_dosenUpdateWithoutFk_kodeWali_mhsInput = {
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_kodeKab?: tb_kabupatenUpdateOneWithoutFk_kodeKab_dosenNestedInput
    fk_kodeProv?: tb_provinsiUpdateOneWithoutFk_kodeProv_dosenNestedInput
    fk_pemilik_akun_dosen?: tb_akun_dosenUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_dosenUncheckedUpdateWithoutFk_kodeWali_mhsInput = {
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeKab?: NullableStringFieldUpdateOperationsInput | string | null
    kodeProv?: NullableStringFieldUpdateOperationsInput | string | null
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_pemilik_akun_dosen?: tb_akun_dosenUncheckedUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_irsUpsertWithWhereUniqueWithoutFk_nimInput = {
    where: tb_irsWhereUniqueInput
    update: XOR<tb_irsUpdateWithoutFk_nimInput, tb_irsUncheckedUpdateWithoutFk_nimInput>
    create: XOR<tb_irsCreateWithoutFk_nimInput, tb_irsUncheckedCreateWithoutFk_nimInput>
  }

  export type tb_irsUpdateWithWhereUniqueWithoutFk_nimInput = {
    where: tb_irsWhereUniqueInput
    data: XOR<tb_irsUpdateWithoutFk_nimInput, tb_irsUncheckedUpdateWithoutFk_nimInput>
  }

  export type tb_irsUpdateManyWithWhereWithoutFk_nimInput = {
    where: tb_irsScalarWhereInput
    data: XOR<tb_irsUpdateManyMutationInput, tb_irsUncheckedUpdateManyWithoutFk_nimInput>
  }

  export type tb_irsScalarWhereInput = {
    AND?: tb_irsScalarWhereInput | tb_irsScalarWhereInput[]
    OR?: tb_irsScalarWhereInput[]
    NOT?: tb_irsScalarWhereInput | tb_irsScalarWhereInput[]
    nim?: StringFilter<"tb_irs"> | string
    semester?: StringFilter<"tb_irs"> | string
    status?: EnumStatusAktifFilter<"tb_irs"> | $Enums.StatusAktif
    jumlahSks?: StringNullableFilter<"tb_irs"> | string | null
    fileIrs?: StringNullableFilter<"tb_irs"> | string | null
    statusValidasi?: BoolFilter<"tb_irs"> | boolean
  }

  export type tb_khsUpsertWithWhereUniqueWithoutFk_nimInput = {
    where: tb_khsWhereUniqueInput
    update: XOR<tb_khsUpdateWithoutFk_nimInput, tb_khsUncheckedUpdateWithoutFk_nimInput>
    create: XOR<tb_khsCreateWithoutFk_nimInput, tb_khsUncheckedCreateWithoutFk_nimInput>
  }

  export type tb_khsUpdateWithWhereUniqueWithoutFk_nimInput = {
    where: tb_khsWhereUniqueInput
    data: XOR<tb_khsUpdateWithoutFk_nimInput, tb_khsUncheckedUpdateWithoutFk_nimInput>
  }

  export type tb_khsUpdateManyWithWhereWithoutFk_nimInput = {
    where: tb_khsScalarWhereInput
    data: XOR<tb_khsUpdateManyMutationInput, tb_khsUncheckedUpdateManyWithoutFk_nimInput>
  }

  export type tb_khsScalarWhereInput = {
    AND?: tb_khsScalarWhereInput | tb_khsScalarWhereInput[]
    OR?: tb_khsScalarWhereInput[]
    NOT?: tb_khsScalarWhereInput | tb_khsScalarWhereInput[]
    nim?: StringFilter<"tb_khs"> | string
    semester?: StringFilter<"tb_khs"> | string
    status?: EnumStatusAktifFilter<"tb_khs"> | $Enums.StatusAktif
    jumlahSksSemester?: StringNullableFilter<"tb_khs"> | string | null
    ips?: StringNullableFilter<"tb_khs"> | string | null
    jumlahSksKumulatif?: StringNullableFilter<"tb_khs"> | string | null
    ipk?: StringNullableFilter<"tb_khs"> | string | null
    fileKhs?: StringNullableFilter<"tb_khs"> | string | null
    statusValidasi?: BoolFilter<"tb_khs"> | boolean
  }

  export type tb_pklUpsertWithWhereUniqueWithoutFk_nimInput = {
    where: tb_pklWhereUniqueInput
    update: XOR<tb_pklUpdateWithoutFk_nimInput, tb_pklUncheckedUpdateWithoutFk_nimInput>
    create: XOR<tb_pklCreateWithoutFk_nimInput, tb_pklUncheckedCreateWithoutFk_nimInput>
  }

  export type tb_pklUpdateWithWhereUniqueWithoutFk_nimInput = {
    where: tb_pklWhereUniqueInput
    data: XOR<tb_pklUpdateWithoutFk_nimInput, tb_pklUncheckedUpdateWithoutFk_nimInput>
  }

  export type tb_pklUpdateManyWithWhereWithoutFk_nimInput = {
    where: tb_pklScalarWhereInput
    data: XOR<tb_pklUpdateManyMutationInput, tb_pklUncheckedUpdateManyWithoutFk_nimInput>
  }

  export type tb_pklScalarWhereInput = {
    AND?: tb_pklScalarWhereInput | tb_pklScalarWhereInput[]
    OR?: tb_pklScalarWhereInput[]
    NOT?: tb_pklScalarWhereInput | tb_pklScalarWhereInput[]
    nim?: StringFilter<"tb_pkl"> | string
    semester?: StringFilter<"tb_pkl"> | string
    nilai?: StringFilter<"tb_pkl"> | string
    filePkl?: StringFilter<"tb_pkl"> | string
    statusValidasi?: BoolFilter<"tb_pkl"> | boolean
  }

  export type tb_skripsiUpsertWithWhereUniqueWithoutFk_nimInput = {
    where: tb_skripsiWhereUniqueInput
    update: XOR<tb_skripsiUpdateWithoutFk_nimInput, tb_skripsiUncheckedUpdateWithoutFk_nimInput>
    create: XOR<tb_skripsiCreateWithoutFk_nimInput, tb_skripsiUncheckedCreateWithoutFk_nimInput>
  }

  export type tb_skripsiUpdateWithWhereUniqueWithoutFk_nimInput = {
    where: tb_skripsiWhereUniqueInput
    data: XOR<tb_skripsiUpdateWithoutFk_nimInput, tb_skripsiUncheckedUpdateWithoutFk_nimInput>
  }

  export type tb_skripsiUpdateManyWithWhereWithoutFk_nimInput = {
    where: tb_skripsiScalarWhereInput
    data: XOR<tb_skripsiUpdateManyMutationInput, tb_skripsiUncheckedUpdateManyWithoutFk_nimInput>
  }

  export type tb_skripsiScalarWhereInput = {
    AND?: tb_skripsiScalarWhereInput | tb_skripsiScalarWhereInput[]
    OR?: tb_skripsiScalarWhereInput[]
    NOT?: tb_skripsiScalarWhereInput | tb_skripsiScalarWhereInput[]
    nim?: StringFilter<"tb_skripsi"> | string
    semester?: StringFilter<"tb_skripsi"> | string
    nilai?: StringFilter<"tb_skripsi"> | string
    tanggalLulusSidang?: DateTimeFilter<"tb_skripsi"> | Date | string
    lamaStudi?: IntFilter<"tb_skripsi"> | number
    fileSkripsi?: StringFilter<"tb_skripsi"> | string
    statusValidasi?: BoolFilter<"tb_skripsi"> | boolean
  }

  export type tb_akun_mhsUpsertWithoutFk_pemilikInput = {
    update: XOR<tb_akun_mhsUpdateWithoutFk_pemilikInput, tb_akun_mhsUncheckedUpdateWithoutFk_pemilikInput>
    create: XOR<tb_akun_mhsCreateWithoutFk_pemilikInput, tb_akun_mhsUncheckedCreateWithoutFk_pemilikInput>
    where?: tb_akun_mhsWhereInput
  }

  export type tb_akun_mhsUpdateToOneWithWhereWithoutFk_pemilikInput = {
    where?: tb_akun_mhsWhereInput
    data: XOR<tb_akun_mhsUpdateWithoutFk_pemilikInput, tb_akun_mhsUncheckedUpdateWithoutFk_pemilikInput>
  }

  export type tb_akun_mhsUpdateWithoutFk_pemilikInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAkunFieldUpdateOperationsInput | $Enums.StatusAkun
  }

  export type tb_akun_mhsUncheckedUpdateWithoutFk_pemilikInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAkunFieldUpdateOperationsInput | $Enums.StatusAkun
  }

  export type tb_kabupatenCreateWithoutFk_kodeKab_dosenInput = {
    kodeKab: string
    namaKab: string
    fk_kodeProv: tb_provinsiCreateNestedOneWithoutFk_kodeProv_kabupatenInput
    fk_kodeKab_mhs?: tb_mhsCreateNestedManyWithoutFk_kodeKabInput
  }

  export type tb_kabupatenUncheckedCreateWithoutFk_kodeKab_dosenInput = {
    kodeKab: string
    namaKab: string
    kodeProv: string
    fk_kodeKab_mhs?: tb_mhsUncheckedCreateNestedManyWithoutFk_kodeKabInput
  }

  export type tb_kabupatenCreateOrConnectWithoutFk_kodeKab_dosenInput = {
    where: tb_kabupatenWhereUniqueInput
    create: XOR<tb_kabupatenCreateWithoutFk_kodeKab_dosenInput, tb_kabupatenUncheckedCreateWithoutFk_kodeKab_dosenInput>
  }

  export type tb_provinsiCreateWithoutFk_kodeProv_dosenInput = {
    kodeProv: string
    namaProv: string
    fk_kodeProv_mhs?: tb_mhsCreateNestedManyWithoutFk_kodeProvInput
    fk_kodeProv_kabupaten?: tb_kabupatenCreateNestedManyWithoutFk_kodeProvInput
  }

  export type tb_provinsiUncheckedCreateWithoutFk_kodeProv_dosenInput = {
    kodeProv: string
    namaProv: string
    fk_kodeProv_mhs?: tb_mhsUncheckedCreateNestedManyWithoutFk_kodeProvInput
    fk_kodeProv_kabupaten?: tb_kabupatenUncheckedCreateNestedManyWithoutFk_kodeProvInput
  }

  export type tb_provinsiCreateOrConnectWithoutFk_kodeProv_dosenInput = {
    where: tb_provinsiWhereUniqueInput
    create: XOR<tb_provinsiCreateWithoutFk_kodeProv_dosenInput, tb_provinsiUncheckedCreateWithoutFk_kodeProv_dosenInput>
  }

  export type tb_mhsCreateWithoutFk_kodeWaliInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    foto?: string | null
    fk_kodeKab?: tb_kabupatenCreateNestedOneWithoutFk_kodeKab_mhsInput
    fk_kodeProv?: tb_provinsiCreateNestedOneWithoutFk_kodeProv_mhsInput
    fk_nim_irs?: tb_irsCreateNestedManyWithoutFk_nimInput
    fk_nim_khs?: tb_khsCreateNestedManyWithoutFk_nimInput
    fk_nim_pkl?: tb_pklCreateNestedManyWithoutFk_nimInput
    fk_nim_skripsi?: tb_skripsiCreateNestedManyWithoutFk_nimInput
    fk_pemilik_akun_mhs?: tb_akun_mhsCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_mhsUncheckedCreateWithoutFk_kodeWaliInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    kodeKab?: string | null
    kodeProv?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    foto?: string | null
    fk_nim_irs?: tb_irsUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_khs?: tb_khsUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_pkl?: tb_pklUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_skripsi?: tb_skripsiUncheckedCreateNestedManyWithoutFk_nimInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUncheckedCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_mhsCreateOrConnectWithoutFk_kodeWaliInput = {
    where: tb_mhsWhereUniqueInput
    create: XOR<tb_mhsCreateWithoutFk_kodeWaliInput, tb_mhsUncheckedCreateWithoutFk_kodeWaliInput>
  }

  export type tb_mhsCreateManyFk_kodeWaliInputEnvelope = {
    data: tb_mhsCreateManyFk_kodeWaliInput | tb_mhsCreateManyFk_kodeWaliInput[]
    skipDuplicates?: boolean
  }

  export type tb_akun_dosenCreateWithoutFk_pemilikInput = {
    username: string
    password: string
    status: $Enums.StatusAkun
    fk_username_role?: tb_role_akun_dosenCreateNestedManyWithoutFk_usernameInput
  }

  export type tb_akun_dosenUncheckedCreateWithoutFk_pemilikInput = {
    username: string
    password: string
    status: $Enums.StatusAkun
    fk_username_role?: tb_role_akun_dosenUncheckedCreateNestedManyWithoutFk_usernameInput
  }

  export type tb_akun_dosenCreateOrConnectWithoutFk_pemilikInput = {
    where: tb_akun_dosenWhereUniqueInput
    create: XOR<tb_akun_dosenCreateWithoutFk_pemilikInput, tb_akun_dosenUncheckedCreateWithoutFk_pemilikInput>
  }

  export type tb_kabupatenUpsertWithoutFk_kodeKab_dosenInput = {
    update: XOR<tb_kabupatenUpdateWithoutFk_kodeKab_dosenInput, tb_kabupatenUncheckedUpdateWithoutFk_kodeKab_dosenInput>
    create: XOR<tb_kabupatenCreateWithoutFk_kodeKab_dosenInput, tb_kabupatenUncheckedCreateWithoutFk_kodeKab_dosenInput>
    where?: tb_kabupatenWhereInput
  }

  export type tb_kabupatenUpdateToOneWithWhereWithoutFk_kodeKab_dosenInput = {
    where?: tb_kabupatenWhereInput
    data: XOR<tb_kabupatenUpdateWithoutFk_kodeKab_dosenInput, tb_kabupatenUncheckedUpdateWithoutFk_kodeKab_dosenInput>
  }

  export type tb_kabupatenUpdateWithoutFk_kodeKab_dosenInput = {
    kodeKab?: StringFieldUpdateOperationsInput | string
    namaKab?: StringFieldUpdateOperationsInput | string
    fk_kodeProv?: tb_provinsiUpdateOneRequiredWithoutFk_kodeProv_kabupatenNestedInput
    fk_kodeKab_mhs?: tb_mhsUpdateManyWithoutFk_kodeKabNestedInput
  }

  export type tb_kabupatenUncheckedUpdateWithoutFk_kodeKab_dosenInput = {
    kodeKab?: StringFieldUpdateOperationsInput | string
    namaKab?: StringFieldUpdateOperationsInput | string
    kodeProv?: StringFieldUpdateOperationsInput | string
    fk_kodeKab_mhs?: tb_mhsUncheckedUpdateManyWithoutFk_kodeKabNestedInput
  }

  export type tb_provinsiUpsertWithoutFk_kodeProv_dosenInput = {
    update: XOR<tb_provinsiUpdateWithoutFk_kodeProv_dosenInput, tb_provinsiUncheckedUpdateWithoutFk_kodeProv_dosenInput>
    create: XOR<tb_provinsiCreateWithoutFk_kodeProv_dosenInput, tb_provinsiUncheckedCreateWithoutFk_kodeProv_dosenInput>
    where?: tb_provinsiWhereInput
  }

  export type tb_provinsiUpdateToOneWithWhereWithoutFk_kodeProv_dosenInput = {
    where?: tb_provinsiWhereInput
    data: XOR<tb_provinsiUpdateWithoutFk_kodeProv_dosenInput, tb_provinsiUncheckedUpdateWithoutFk_kodeProv_dosenInput>
  }

  export type tb_provinsiUpdateWithoutFk_kodeProv_dosenInput = {
    kodeProv?: StringFieldUpdateOperationsInput | string
    namaProv?: StringFieldUpdateOperationsInput | string
    fk_kodeProv_mhs?: tb_mhsUpdateManyWithoutFk_kodeProvNestedInput
    fk_kodeProv_kabupaten?: tb_kabupatenUpdateManyWithoutFk_kodeProvNestedInput
  }

  export type tb_provinsiUncheckedUpdateWithoutFk_kodeProv_dosenInput = {
    kodeProv?: StringFieldUpdateOperationsInput | string
    namaProv?: StringFieldUpdateOperationsInput | string
    fk_kodeProv_mhs?: tb_mhsUncheckedUpdateManyWithoutFk_kodeProvNestedInput
    fk_kodeProv_kabupaten?: tb_kabupatenUncheckedUpdateManyWithoutFk_kodeProvNestedInput
  }

  export type tb_mhsUpsertWithWhereUniqueWithoutFk_kodeWaliInput = {
    where: tb_mhsWhereUniqueInput
    update: XOR<tb_mhsUpdateWithoutFk_kodeWaliInput, tb_mhsUncheckedUpdateWithoutFk_kodeWaliInput>
    create: XOR<tb_mhsCreateWithoutFk_kodeWaliInput, tb_mhsUncheckedCreateWithoutFk_kodeWaliInput>
  }

  export type tb_mhsUpdateWithWhereUniqueWithoutFk_kodeWaliInput = {
    where: tb_mhsWhereUniqueInput
    data: XOR<tb_mhsUpdateWithoutFk_kodeWaliInput, tb_mhsUncheckedUpdateWithoutFk_kodeWaliInput>
  }

  export type tb_mhsUpdateManyWithWhereWithoutFk_kodeWaliInput = {
    where: tb_mhsScalarWhereInput
    data: XOR<tb_mhsUpdateManyMutationInput, tb_mhsUncheckedUpdateManyWithoutFk_kodeWaliInput>
  }

  export type tb_mhsScalarWhereInput = {
    AND?: tb_mhsScalarWhereInput | tb_mhsScalarWhereInput[]
    OR?: tb_mhsScalarWhereInput[]
    NOT?: tb_mhsScalarWhereInput | tb_mhsScalarWhereInput[]
    nim?: StringFilter<"tb_mhs"> | string
    nama?: StringFilter<"tb_mhs"> | string
    statusAktif?: EnumStatusMhsFilter<"tb_mhs"> | $Enums.StatusMhs
    alamat?: StringNullableFilter<"tb_mhs"> | string | null
    email?: StringNullableFilter<"tb_mhs"> | string | null
    kodeKab?: StringNullableFilter<"tb_mhs"> | string | null
    kodeProv?: StringNullableFilter<"tb_mhs"> | string | null
    jalurMasuk?: EnumJalurMasukFilter<"tb_mhs"> | $Enums.JalurMasuk
    angkatan?: IntFilter<"tb_mhs"> | number
    noHP?: StringNullableFilter<"tb_mhs"> | string | null
    kodeWali?: StringFilter<"tb_mhs"> | string
    foto?: StringNullableFilter<"tb_mhs"> | string | null
  }

  export type tb_akun_dosenUpsertWithoutFk_pemilikInput = {
    update: XOR<tb_akun_dosenUpdateWithoutFk_pemilikInput, tb_akun_dosenUncheckedUpdateWithoutFk_pemilikInput>
    create: XOR<tb_akun_dosenCreateWithoutFk_pemilikInput, tb_akun_dosenUncheckedCreateWithoutFk_pemilikInput>
    where?: tb_akun_dosenWhereInput
  }

  export type tb_akun_dosenUpdateToOneWithWhereWithoutFk_pemilikInput = {
    where?: tb_akun_dosenWhereInput
    data: XOR<tb_akun_dosenUpdateWithoutFk_pemilikInput, tb_akun_dosenUncheckedUpdateWithoutFk_pemilikInput>
  }

  export type tb_akun_dosenUpdateWithoutFk_pemilikInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAkunFieldUpdateOperationsInput | $Enums.StatusAkun
    fk_username_role?: tb_role_akun_dosenUpdateManyWithoutFk_usernameNestedInput
  }

  export type tb_akun_dosenUncheckedUpdateWithoutFk_pemilikInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAkunFieldUpdateOperationsInput | $Enums.StatusAkun
    fk_username_role?: tb_role_akun_dosenUncheckedUpdateManyWithoutFk_usernameNestedInput
  }

  export type tb_mhsCreateWithoutFk_nim_irsInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    foto?: string | null
    fk_kodeKab?: tb_kabupatenCreateNestedOneWithoutFk_kodeKab_mhsInput
    fk_kodeProv?: tb_provinsiCreateNestedOneWithoutFk_kodeProv_mhsInput
    fk_kodeWali: tb_dosenCreateNestedOneWithoutFk_kodeWali_mhsInput
    fk_nim_khs?: tb_khsCreateNestedManyWithoutFk_nimInput
    fk_nim_pkl?: tb_pklCreateNestedManyWithoutFk_nimInput
    fk_nim_skripsi?: tb_skripsiCreateNestedManyWithoutFk_nimInput
    fk_pemilik_akun_mhs?: tb_akun_mhsCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_mhsUncheckedCreateWithoutFk_nim_irsInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    kodeKab?: string | null
    kodeProv?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    kodeWali: string
    foto?: string | null
    fk_nim_khs?: tb_khsUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_pkl?: tb_pklUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_skripsi?: tb_skripsiUncheckedCreateNestedManyWithoutFk_nimInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUncheckedCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_mhsCreateOrConnectWithoutFk_nim_irsInput = {
    where: tb_mhsWhereUniqueInput
    create: XOR<tb_mhsCreateWithoutFk_nim_irsInput, tb_mhsUncheckedCreateWithoutFk_nim_irsInput>
  }

  export type tb_mhsUpsertWithoutFk_nim_irsInput = {
    update: XOR<tb_mhsUpdateWithoutFk_nim_irsInput, tb_mhsUncheckedUpdateWithoutFk_nim_irsInput>
    create: XOR<tb_mhsCreateWithoutFk_nim_irsInput, tb_mhsUncheckedCreateWithoutFk_nim_irsInput>
    where?: tb_mhsWhereInput
  }

  export type tb_mhsUpdateToOneWithWhereWithoutFk_nim_irsInput = {
    where?: tb_mhsWhereInput
    data: XOR<tb_mhsUpdateWithoutFk_nim_irsInput, tb_mhsUncheckedUpdateWithoutFk_nim_irsInput>
  }

  export type tb_mhsUpdateWithoutFk_nim_irsInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_kodeKab?: tb_kabupatenUpdateOneWithoutFk_kodeKab_mhsNestedInput
    fk_kodeProv?: tb_provinsiUpdateOneWithoutFk_kodeProv_mhsNestedInput
    fk_kodeWali?: tb_dosenUpdateOneRequiredWithoutFk_kodeWali_mhsNestedInput
    fk_nim_khs?: tb_khsUpdateManyWithoutFk_nimNestedInput
    fk_nim_pkl?: tb_pklUpdateManyWithoutFk_nimNestedInput
    fk_nim_skripsi?: tb_skripsiUpdateManyWithoutFk_nimNestedInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_mhsUncheckedUpdateWithoutFk_nim_irsInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeKab?: NullableStringFieldUpdateOperationsInput | string | null
    kodeProv?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    kodeWali?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_nim_khs?: tb_khsUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_pkl?: tb_pklUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_skripsi?: tb_skripsiUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUncheckedUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_mhsCreateWithoutFk_nim_khsInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    foto?: string | null
    fk_kodeKab?: tb_kabupatenCreateNestedOneWithoutFk_kodeKab_mhsInput
    fk_kodeProv?: tb_provinsiCreateNestedOneWithoutFk_kodeProv_mhsInput
    fk_kodeWali: tb_dosenCreateNestedOneWithoutFk_kodeWali_mhsInput
    fk_nim_irs?: tb_irsCreateNestedManyWithoutFk_nimInput
    fk_nim_pkl?: tb_pklCreateNestedManyWithoutFk_nimInput
    fk_nim_skripsi?: tb_skripsiCreateNestedManyWithoutFk_nimInput
    fk_pemilik_akun_mhs?: tb_akun_mhsCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_mhsUncheckedCreateWithoutFk_nim_khsInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    kodeKab?: string | null
    kodeProv?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    kodeWali: string
    foto?: string | null
    fk_nim_irs?: tb_irsUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_pkl?: tb_pklUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_skripsi?: tb_skripsiUncheckedCreateNestedManyWithoutFk_nimInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUncheckedCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_mhsCreateOrConnectWithoutFk_nim_khsInput = {
    where: tb_mhsWhereUniqueInput
    create: XOR<tb_mhsCreateWithoutFk_nim_khsInput, tb_mhsUncheckedCreateWithoutFk_nim_khsInput>
  }

  export type tb_mhsUpsertWithoutFk_nim_khsInput = {
    update: XOR<tb_mhsUpdateWithoutFk_nim_khsInput, tb_mhsUncheckedUpdateWithoutFk_nim_khsInput>
    create: XOR<tb_mhsCreateWithoutFk_nim_khsInput, tb_mhsUncheckedCreateWithoutFk_nim_khsInput>
    where?: tb_mhsWhereInput
  }

  export type tb_mhsUpdateToOneWithWhereWithoutFk_nim_khsInput = {
    where?: tb_mhsWhereInput
    data: XOR<tb_mhsUpdateWithoutFk_nim_khsInput, tb_mhsUncheckedUpdateWithoutFk_nim_khsInput>
  }

  export type tb_mhsUpdateWithoutFk_nim_khsInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_kodeKab?: tb_kabupatenUpdateOneWithoutFk_kodeKab_mhsNestedInput
    fk_kodeProv?: tb_provinsiUpdateOneWithoutFk_kodeProv_mhsNestedInput
    fk_kodeWali?: tb_dosenUpdateOneRequiredWithoutFk_kodeWali_mhsNestedInput
    fk_nim_irs?: tb_irsUpdateManyWithoutFk_nimNestedInput
    fk_nim_pkl?: tb_pklUpdateManyWithoutFk_nimNestedInput
    fk_nim_skripsi?: tb_skripsiUpdateManyWithoutFk_nimNestedInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_mhsUncheckedUpdateWithoutFk_nim_khsInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeKab?: NullableStringFieldUpdateOperationsInput | string | null
    kodeProv?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    kodeWali?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_nim_irs?: tb_irsUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_pkl?: tb_pklUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_skripsi?: tb_skripsiUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUncheckedUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_mhsCreateWithoutFk_nim_pklInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    foto?: string | null
    fk_kodeKab?: tb_kabupatenCreateNestedOneWithoutFk_kodeKab_mhsInput
    fk_kodeProv?: tb_provinsiCreateNestedOneWithoutFk_kodeProv_mhsInput
    fk_kodeWali: tb_dosenCreateNestedOneWithoutFk_kodeWali_mhsInput
    fk_nim_irs?: tb_irsCreateNestedManyWithoutFk_nimInput
    fk_nim_khs?: tb_khsCreateNestedManyWithoutFk_nimInput
    fk_nim_skripsi?: tb_skripsiCreateNestedManyWithoutFk_nimInput
    fk_pemilik_akun_mhs?: tb_akun_mhsCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_mhsUncheckedCreateWithoutFk_nim_pklInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    kodeKab?: string | null
    kodeProv?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    kodeWali: string
    foto?: string | null
    fk_nim_irs?: tb_irsUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_khs?: tb_khsUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_skripsi?: tb_skripsiUncheckedCreateNestedManyWithoutFk_nimInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUncheckedCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_mhsCreateOrConnectWithoutFk_nim_pklInput = {
    where: tb_mhsWhereUniqueInput
    create: XOR<tb_mhsCreateWithoutFk_nim_pklInput, tb_mhsUncheckedCreateWithoutFk_nim_pklInput>
  }

  export type tb_mhsUpsertWithoutFk_nim_pklInput = {
    update: XOR<tb_mhsUpdateWithoutFk_nim_pklInput, tb_mhsUncheckedUpdateWithoutFk_nim_pklInput>
    create: XOR<tb_mhsCreateWithoutFk_nim_pklInput, tb_mhsUncheckedCreateWithoutFk_nim_pklInput>
    where?: tb_mhsWhereInput
  }

  export type tb_mhsUpdateToOneWithWhereWithoutFk_nim_pklInput = {
    where?: tb_mhsWhereInput
    data: XOR<tb_mhsUpdateWithoutFk_nim_pklInput, tb_mhsUncheckedUpdateWithoutFk_nim_pklInput>
  }

  export type tb_mhsUpdateWithoutFk_nim_pklInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_kodeKab?: tb_kabupatenUpdateOneWithoutFk_kodeKab_mhsNestedInput
    fk_kodeProv?: tb_provinsiUpdateOneWithoutFk_kodeProv_mhsNestedInput
    fk_kodeWali?: tb_dosenUpdateOneRequiredWithoutFk_kodeWali_mhsNestedInput
    fk_nim_irs?: tb_irsUpdateManyWithoutFk_nimNestedInput
    fk_nim_khs?: tb_khsUpdateManyWithoutFk_nimNestedInput
    fk_nim_skripsi?: tb_skripsiUpdateManyWithoutFk_nimNestedInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_mhsUncheckedUpdateWithoutFk_nim_pklInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeKab?: NullableStringFieldUpdateOperationsInput | string | null
    kodeProv?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    kodeWali?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_nim_irs?: tb_irsUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_khs?: tb_khsUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_skripsi?: tb_skripsiUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUncheckedUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_mhsCreateWithoutFk_nim_skripsiInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    foto?: string | null
    fk_kodeKab?: tb_kabupatenCreateNestedOneWithoutFk_kodeKab_mhsInput
    fk_kodeProv?: tb_provinsiCreateNestedOneWithoutFk_kodeProv_mhsInput
    fk_kodeWali: tb_dosenCreateNestedOneWithoutFk_kodeWali_mhsInput
    fk_nim_irs?: tb_irsCreateNestedManyWithoutFk_nimInput
    fk_nim_khs?: tb_khsCreateNestedManyWithoutFk_nimInput
    fk_nim_pkl?: tb_pklCreateNestedManyWithoutFk_nimInput
    fk_pemilik_akun_mhs?: tb_akun_mhsCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_mhsUncheckedCreateWithoutFk_nim_skripsiInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    kodeKab?: string | null
    kodeProv?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    kodeWali: string
    foto?: string | null
    fk_nim_irs?: tb_irsUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_khs?: tb_khsUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_pkl?: tb_pklUncheckedCreateNestedManyWithoutFk_nimInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUncheckedCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_mhsCreateOrConnectWithoutFk_nim_skripsiInput = {
    where: tb_mhsWhereUniqueInput
    create: XOR<tb_mhsCreateWithoutFk_nim_skripsiInput, tb_mhsUncheckedCreateWithoutFk_nim_skripsiInput>
  }

  export type tb_mhsUpsertWithoutFk_nim_skripsiInput = {
    update: XOR<tb_mhsUpdateWithoutFk_nim_skripsiInput, tb_mhsUncheckedUpdateWithoutFk_nim_skripsiInput>
    create: XOR<tb_mhsCreateWithoutFk_nim_skripsiInput, tb_mhsUncheckedCreateWithoutFk_nim_skripsiInput>
    where?: tb_mhsWhereInput
  }

  export type tb_mhsUpdateToOneWithWhereWithoutFk_nim_skripsiInput = {
    where?: tb_mhsWhereInput
    data: XOR<tb_mhsUpdateWithoutFk_nim_skripsiInput, tb_mhsUncheckedUpdateWithoutFk_nim_skripsiInput>
  }

  export type tb_mhsUpdateWithoutFk_nim_skripsiInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_kodeKab?: tb_kabupatenUpdateOneWithoutFk_kodeKab_mhsNestedInput
    fk_kodeProv?: tb_provinsiUpdateOneWithoutFk_kodeProv_mhsNestedInput
    fk_kodeWali?: tb_dosenUpdateOneRequiredWithoutFk_kodeWali_mhsNestedInput
    fk_nim_irs?: tb_irsUpdateManyWithoutFk_nimNestedInput
    fk_nim_khs?: tb_khsUpdateManyWithoutFk_nimNestedInput
    fk_nim_pkl?: tb_pklUpdateManyWithoutFk_nimNestedInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_mhsUncheckedUpdateWithoutFk_nim_skripsiInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeKab?: NullableStringFieldUpdateOperationsInput | string | null
    kodeProv?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    kodeWali?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_nim_irs?: tb_irsUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_khs?: tb_khsUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_pkl?: tb_pklUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUncheckedUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_mhsCreateWithoutFk_kodeProvInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    foto?: string | null
    fk_kodeKab?: tb_kabupatenCreateNestedOneWithoutFk_kodeKab_mhsInput
    fk_kodeWali: tb_dosenCreateNestedOneWithoutFk_kodeWali_mhsInput
    fk_nim_irs?: tb_irsCreateNestedManyWithoutFk_nimInput
    fk_nim_khs?: tb_khsCreateNestedManyWithoutFk_nimInput
    fk_nim_pkl?: tb_pklCreateNestedManyWithoutFk_nimInput
    fk_nim_skripsi?: tb_skripsiCreateNestedManyWithoutFk_nimInput
    fk_pemilik_akun_mhs?: tb_akun_mhsCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_mhsUncheckedCreateWithoutFk_kodeProvInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    kodeKab?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    kodeWali: string
    foto?: string | null
    fk_nim_irs?: tb_irsUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_khs?: tb_khsUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_pkl?: tb_pklUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_skripsi?: tb_skripsiUncheckedCreateNestedManyWithoutFk_nimInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUncheckedCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_mhsCreateOrConnectWithoutFk_kodeProvInput = {
    where: tb_mhsWhereUniqueInput
    create: XOR<tb_mhsCreateWithoutFk_kodeProvInput, tb_mhsUncheckedCreateWithoutFk_kodeProvInput>
  }

  export type tb_mhsCreateManyFk_kodeProvInputEnvelope = {
    data: tb_mhsCreateManyFk_kodeProvInput | tb_mhsCreateManyFk_kodeProvInput[]
    skipDuplicates?: boolean
  }

  export type tb_dosenCreateWithoutFk_kodeProvInput = {
    nip: string
    nama: string
    alamat?: string | null
    email?: string | null
    noHP?: string | null
    foto?: string | null
    fk_kodeKab?: tb_kabupatenCreateNestedOneWithoutFk_kodeKab_dosenInput
    fk_kodeWali_mhs?: tb_mhsCreateNestedManyWithoutFk_kodeWaliInput
    fk_pemilik_akun_dosen?: tb_akun_dosenCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_dosenUncheckedCreateWithoutFk_kodeProvInput = {
    nip: string
    nama: string
    alamat?: string | null
    email?: string | null
    kodeKab?: string | null
    noHP?: string | null
    foto?: string | null
    fk_kodeWali_mhs?: tb_mhsUncheckedCreateNestedManyWithoutFk_kodeWaliInput
    fk_pemilik_akun_dosen?: tb_akun_dosenUncheckedCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_dosenCreateOrConnectWithoutFk_kodeProvInput = {
    where: tb_dosenWhereUniqueInput
    create: XOR<tb_dosenCreateWithoutFk_kodeProvInput, tb_dosenUncheckedCreateWithoutFk_kodeProvInput>
  }

  export type tb_dosenCreateManyFk_kodeProvInputEnvelope = {
    data: tb_dosenCreateManyFk_kodeProvInput | tb_dosenCreateManyFk_kodeProvInput[]
    skipDuplicates?: boolean
  }

  export type tb_kabupatenCreateWithoutFk_kodeProvInput = {
    kodeKab: string
    namaKab: string
    fk_kodeKab_mhs?: tb_mhsCreateNestedManyWithoutFk_kodeKabInput
    fk_kodeKab_dosen?: tb_dosenCreateNestedManyWithoutFk_kodeKabInput
  }

  export type tb_kabupatenUncheckedCreateWithoutFk_kodeProvInput = {
    kodeKab: string
    namaKab: string
    fk_kodeKab_mhs?: tb_mhsUncheckedCreateNestedManyWithoutFk_kodeKabInput
    fk_kodeKab_dosen?: tb_dosenUncheckedCreateNestedManyWithoutFk_kodeKabInput
  }

  export type tb_kabupatenCreateOrConnectWithoutFk_kodeProvInput = {
    where: tb_kabupatenWhereUniqueInput
    create: XOR<tb_kabupatenCreateWithoutFk_kodeProvInput, tb_kabupatenUncheckedCreateWithoutFk_kodeProvInput>
  }

  export type tb_kabupatenCreateManyFk_kodeProvInputEnvelope = {
    data: tb_kabupatenCreateManyFk_kodeProvInput | tb_kabupatenCreateManyFk_kodeProvInput[]
    skipDuplicates?: boolean
  }

  export type tb_mhsUpsertWithWhereUniqueWithoutFk_kodeProvInput = {
    where: tb_mhsWhereUniqueInput
    update: XOR<tb_mhsUpdateWithoutFk_kodeProvInput, tb_mhsUncheckedUpdateWithoutFk_kodeProvInput>
    create: XOR<tb_mhsCreateWithoutFk_kodeProvInput, tb_mhsUncheckedCreateWithoutFk_kodeProvInput>
  }

  export type tb_mhsUpdateWithWhereUniqueWithoutFk_kodeProvInput = {
    where: tb_mhsWhereUniqueInput
    data: XOR<tb_mhsUpdateWithoutFk_kodeProvInput, tb_mhsUncheckedUpdateWithoutFk_kodeProvInput>
  }

  export type tb_mhsUpdateManyWithWhereWithoutFk_kodeProvInput = {
    where: tb_mhsScalarWhereInput
    data: XOR<tb_mhsUpdateManyMutationInput, tb_mhsUncheckedUpdateManyWithoutFk_kodeProvInput>
  }

  export type tb_dosenUpsertWithWhereUniqueWithoutFk_kodeProvInput = {
    where: tb_dosenWhereUniqueInput
    update: XOR<tb_dosenUpdateWithoutFk_kodeProvInput, tb_dosenUncheckedUpdateWithoutFk_kodeProvInput>
    create: XOR<tb_dosenCreateWithoutFk_kodeProvInput, tb_dosenUncheckedCreateWithoutFk_kodeProvInput>
  }

  export type tb_dosenUpdateWithWhereUniqueWithoutFk_kodeProvInput = {
    where: tb_dosenWhereUniqueInput
    data: XOR<tb_dosenUpdateWithoutFk_kodeProvInput, tb_dosenUncheckedUpdateWithoutFk_kodeProvInput>
  }

  export type tb_dosenUpdateManyWithWhereWithoutFk_kodeProvInput = {
    where: tb_dosenScalarWhereInput
    data: XOR<tb_dosenUpdateManyMutationInput, tb_dosenUncheckedUpdateManyWithoutFk_kodeProvInput>
  }

  export type tb_dosenScalarWhereInput = {
    AND?: tb_dosenScalarWhereInput | tb_dosenScalarWhereInput[]
    OR?: tb_dosenScalarWhereInput[]
    NOT?: tb_dosenScalarWhereInput | tb_dosenScalarWhereInput[]
    nip?: StringFilter<"tb_dosen"> | string
    nama?: StringFilter<"tb_dosen"> | string
    alamat?: StringNullableFilter<"tb_dosen"> | string | null
    email?: StringNullableFilter<"tb_dosen"> | string | null
    kodeKab?: StringNullableFilter<"tb_dosen"> | string | null
    kodeProv?: StringNullableFilter<"tb_dosen"> | string | null
    noHP?: StringNullableFilter<"tb_dosen"> | string | null
    foto?: StringNullableFilter<"tb_dosen"> | string | null
  }

  export type tb_kabupatenUpsertWithWhereUniqueWithoutFk_kodeProvInput = {
    where: tb_kabupatenWhereUniqueInput
    update: XOR<tb_kabupatenUpdateWithoutFk_kodeProvInput, tb_kabupatenUncheckedUpdateWithoutFk_kodeProvInput>
    create: XOR<tb_kabupatenCreateWithoutFk_kodeProvInput, tb_kabupatenUncheckedCreateWithoutFk_kodeProvInput>
  }

  export type tb_kabupatenUpdateWithWhereUniqueWithoutFk_kodeProvInput = {
    where: tb_kabupatenWhereUniqueInput
    data: XOR<tb_kabupatenUpdateWithoutFk_kodeProvInput, tb_kabupatenUncheckedUpdateWithoutFk_kodeProvInput>
  }

  export type tb_kabupatenUpdateManyWithWhereWithoutFk_kodeProvInput = {
    where: tb_kabupatenScalarWhereInput
    data: XOR<tb_kabupatenUpdateManyMutationInput, tb_kabupatenUncheckedUpdateManyWithoutFk_kodeProvInput>
  }

  export type tb_kabupatenScalarWhereInput = {
    AND?: tb_kabupatenScalarWhereInput | tb_kabupatenScalarWhereInput[]
    OR?: tb_kabupatenScalarWhereInput[]
    NOT?: tb_kabupatenScalarWhereInput | tb_kabupatenScalarWhereInput[]
    kodeKab?: StringFilter<"tb_kabupaten"> | string
    namaKab?: StringFilter<"tb_kabupaten"> | string
    kodeProv?: StringFilter<"tb_kabupaten"> | string
  }

  export type tb_provinsiCreateWithoutFk_kodeProv_kabupatenInput = {
    kodeProv: string
    namaProv: string
    fk_kodeProv_mhs?: tb_mhsCreateNestedManyWithoutFk_kodeProvInput
    fk_kodeProv_dosen?: tb_dosenCreateNestedManyWithoutFk_kodeProvInput
  }

  export type tb_provinsiUncheckedCreateWithoutFk_kodeProv_kabupatenInput = {
    kodeProv: string
    namaProv: string
    fk_kodeProv_mhs?: tb_mhsUncheckedCreateNestedManyWithoutFk_kodeProvInput
    fk_kodeProv_dosen?: tb_dosenUncheckedCreateNestedManyWithoutFk_kodeProvInput
  }

  export type tb_provinsiCreateOrConnectWithoutFk_kodeProv_kabupatenInput = {
    where: tb_provinsiWhereUniqueInput
    create: XOR<tb_provinsiCreateWithoutFk_kodeProv_kabupatenInput, tb_provinsiUncheckedCreateWithoutFk_kodeProv_kabupatenInput>
  }

  export type tb_mhsCreateWithoutFk_kodeKabInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    foto?: string | null
    fk_kodeProv?: tb_provinsiCreateNestedOneWithoutFk_kodeProv_mhsInput
    fk_kodeWali: tb_dosenCreateNestedOneWithoutFk_kodeWali_mhsInput
    fk_nim_irs?: tb_irsCreateNestedManyWithoutFk_nimInput
    fk_nim_khs?: tb_khsCreateNestedManyWithoutFk_nimInput
    fk_nim_pkl?: tb_pklCreateNestedManyWithoutFk_nimInput
    fk_nim_skripsi?: tb_skripsiCreateNestedManyWithoutFk_nimInput
    fk_pemilik_akun_mhs?: tb_akun_mhsCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_mhsUncheckedCreateWithoutFk_kodeKabInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    kodeProv?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    kodeWali: string
    foto?: string | null
    fk_nim_irs?: tb_irsUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_khs?: tb_khsUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_pkl?: tb_pklUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_skripsi?: tb_skripsiUncheckedCreateNestedManyWithoutFk_nimInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUncheckedCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_mhsCreateOrConnectWithoutFk_kodeKabInput = {
    where: tb_mhsWhereUniqueInput
    create: XOR<tb_mhsCreateWithoutFk_kodeKabInput, tb_mhsUncheckedCreateWithoutFk_kodeKabInput>
  }

  export type tb_mhsCreateManyFk_kodeKabInputEnvelope = {
    data: tb_mhsCreateManyFk_kodeKabInput | tb_mhsCreateManyFk_kodeKabInput[]
    skipDuplicates?: boolean
  }

  export type tb_dosenCreateWithoutFk_kodeKabInput = {
    nip: string
    nama: string
    alamat?: string | null
    email?: string | null
    noHP?: string | null
    foto?: string | null
    fk_kodeProv?: tb_provinsiCreateNestedOneWithoutFk_kodeProv_dosenInput
    fk_kodeWali_mhs?: tb_mhsCreateNestedManyWithoutFk_kodeWaliInput
    fk_pemilik_akun_dosen?: tb_akun_dosenCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_dosenUncheckedCreateWithoutFk_kodeKabInput = {
    nip: string
    nama: string
    alamat?: string | null
    email?: string | null
    kodeProv?: string | null
    noHP?: string | null
    foto?: string | null
    fk_kodeWali_mhs?: tb_mhsUncheckedCreateNestedManyWithoutFk_kodeWaliInput
    fk_pemilik_akun_dosen?: tb_akun_dosenUncheckedCreateNestedOneWithoutFk_pemilikInput
  }

  export type tb_dosenCreateOrConnectWithoutFk_kodeKabInput = {
    where: tb_dosenWhereUniqueInput
    create: XOR<tb_dosenCreateWithoutFk_kodeKabInput, tb_dosenUncheckedCreateWithoutFk_kodeKabInput>
  }

  export type tb_dosenCreateManyFk_kodeKabInputEnvelope = {
    data: tb_dosenCreateManyFk_kodeKabInput | tb_dosenCreateManyFk_kodeKabInput[]
    skipDuplicates?: boolean
  }

  export type tb_provinsiUpsertWithoutFk_kodeProv_kabupatenInput = {
    update: XOR<tb_provinsiUpdateWithoutFk_kodeProv_kabupatenInput, tb_provinsiUncheckedUpdateWithoutFk_kodeProv_kabupatenInput>
    create: XOR<tb_provinsiCreateWithoutFk_kodeProv_kabupatenInput, tb_provinsiUncheckedCreateWithoutFk_kodeProv_kabupatenInput>
    where?: tb_provinsiWhereInput
  }

  export type tb_provinsiUpdateToOneWithWhereWithoutFk_kodeProv_kabupatenInput = {
    where?: tb_provinsiWhereInput
    data: XOR<tb_provinsiUpdateWithoutFk_kodeProv_kabupatenInput, tb_provinsiUncheckedUpdateWithoutFk_kodeProv_kabupatenInput>
  }

  export type tb_provinsiUpdateWithoutFk_kodeProv_kabupatenInput = {
    kodeProv?: StringFieldUpdateOperationsInput | string
    namaProv?: StringFieldUpdateOperationsInput | string
    fk_kodeProv_mhs?: tb_mhsUpdateManyWithoutFk_kodeProvNestedInput
    fk_kodeProv_dosen?: tb_dosenUpdateManyWithoutFk_kodeProvNestedInput
  }

  export type tb_provinsiUncheckedUpdateWithoutFk_kodeProv_kabupatenInput = {
    kodeProv?: StringFieldUpdateOperationsInput | string
    namaProv?: StringFieldUpdateOperationsInput | string
    fk_kodeProv_mhs?: tb_mhsUncheckedUpdateManyWithoutFk_kodeProvNestedInput
    fk_kodeProv_dosen?: tb_dosenUncheckedUpdateManyWithoutFk_kodeProvNestedInput
  }

  export type tb_mhsUpsertWithWhereUniqueWithoutFk_kodeKabInput = {
    where: tb_mhsWhereUniqueInput
    update: XOR<tb_mhsUpdateWithoutFk_kodeKabInput, tb_mhsUncheckedUpdateWithoutFk_kodeKabInput>
    create: XOR<tb_mhsCreateWithoutFk_kodeKabInput, tb_mhsUncheckedCreateWithoutFk_kodeKabInput>
  }

  export type tb_mhsUpdateWithWhereUniqueWithoutFk_kodeKabInput = {
    where: tb_mhsWhereUniqueInput
    data: XOR<tb_mhsUpdateWithoutFk_kodeKabInput, tb_mhsUncheckedUpdateWithoutFk_kodeKabInput>
  }

  export type tb_mhsUpdateManyWithWhereWithoutFk_kodeKabInput = {
    where: tb_mhsScalarWhereInput
    data: XOR<tb_mhsUpdateManyMutationInput, tb_mhsUncheckedUpdateManyWithoutFk_kodeKabInput>
  }

  export type tb_dosenUpsertWithWhereUniqueWithoutFk_kodeKabInput = {
    where: tb_dosenWhereUniqueInput
    update: XOR<tb_dosenUpdateWithoutFk_kodeKabInput, tb_dosenUncheckedUpdateWithoutFk_kodeKabInput>
    create: XOR<tb_dosenCreateWithoutFk_kodeKabInput, tb_dosenUncheckedCreateWithoutFk_kodeKabInput>
  }

  export type tb_dosenUpdateWithWhereUniqueWithoutFk_kodeKabInput = {
    where: tb_dosenWhereUniqueInput
    data: XOR<tb_dosenUpdateWithoutFk_kodeKabInput, tb_dosenUncheckedUpdateWithoutFk_kodeKabInput>
  }

  export type tb_dosenUpdateManyWithWhereWithoutFk_kodeKabInput = {
    where: tb_dosenScalarWhereInput
    data: XOR<tb_dosenUpdateManyMutationInput, tb_dosenUncheckedUpdateManyWithoutFk_kodeKabInput>
  }

  export type tb_mhsCreateWithoutFk_pemilik_akun_mhsInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    foto?: string | null
    fk_kodeKab?: tb_kabupatenCreateNestedOneWithoutFk_kodeKab_mhsInput
    fk_kodeProv?: tb_provinsiCreateNestedOneWithoutFk_kodeProv_mhsInput
    fk_kodeWali: tb_dosenCreateNestedOneWithoutFk_kodeWali_mhsInput
    fk_nim_irs?: tb_irsCreateNestedManyWithoutFk_nimInput
    fk_nim_khs?: tb_khsCreateNestedManyWithoutFk_nimInput
    fk_nim_pkl?: tb_pklCreateNestedManyWithoutFk_nimInput
    fk_nim_skripsi?: tb_skripsiCreateNestedManyWithoutFk_nimInput
  }

  export type tb_mhsUncheckedCreateWithoutFk_pemilik_akun_mhsInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    kodeKab?: string | null
    kodeProv?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    kodeWali: string
    foto?: string | null
    fk_nim_irs?: tb_irsUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_khs?: tb_khsUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_pkl?: tb_pklUncheckedCreateNestedManyWithoutFk_nimInput
    fk_nim_skripsi?: tb_skripsiUncheckedCreateNestedManyWithoutFk_nimInput
  }

  export type tb_mhsCreateOrConnectWithoutFk_pemilik_akun_mhsInput = {
    where: tb_mhsWhereUniqueInput
    create: XOR<tb_mhsCreateWithoutFk_pemilik_akun_mhsInput, tb_mhsUncheckedCreateWithoutFk_pemilik_akun_mhsInput>
  }

  export type tb_mhsUpsertWithoutFk_pemilik_akun_mhsInput = {
    update: XOR<tb_mhsUpdateWithoutFk_pemilik_akun_mhsInput, tb_mhsUncheckedUpdateWithoutFk_pemilik_akun_mhsInput>
    create: XOR<tb_mhsCreateWithoutFk_pemilik_akun_mhsInput, tb_mhsUncheckedCreateWithoutFk_pemilik_akun_mhsInput>
    where?: tb_mhsWhereInput
  }

  export type tb_mhsUpdateToOneWithWhereWithoutFk_pemilik_akun_mhsInput = {
    where?: tb_mhsWhereInput
    data: XOR<tb_mhsUpdateWithoutFk_pemilik_akun_mhsInput, tb_mhsUncheckedUpdateWithoutFk_pemilik_akun_mhsInput>
  }

  export type tb_mhsUpdateWithoutFk_pemilik_akun_mhsInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_kodeKab?: tb_kabupatenUpdateOneWithoutFk_kodeKab_mhsNestedInput
    fk_kodeProv?: tb_provinsiUpdateOneWithoutFk_kodeProv_mhsNestedInput
    fk_kodeWali?: tb_dosenUpdateOneRequiredWithoutFk_kodeWali_mhsNestedInput
    fk_nim_irs?: tb_irsUpdateManyWithoutFk_nimNestedInput
    fk_nim_khs?: tb_khsUpdateManyWithoutFk_nimNestedInput
    fk_nim_pkl?: tb_pklUpdateManyWithoutFk_nimNestedInput
    fk_nim_skripsi?: tb_skripsiUpdateManyWithoutFk_nimNestedInput
  }

  export type tb_mhsUncheckedUpdateWithoutFk_pemilik_akun_mhsInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeKab?: NullableStringFieldUpdateOperationsInput | string | null
    kodeProv?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    kodeWali?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_nim_irs?: tb_irsUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_khs?: tb_khsUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_pkl?: tb_pklUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_skripsi?: tb_skripsiUncheckedUpdateManyWithoutFk_nimNestedInput
  }

  export type tb_dosenCreateWithoutFk_pemilik_akun_dosenInput = {
    nip: string
    nama: string
    alamat?: string | null
    email?: string | null
    noHP?: string | null
    foto?: string | null
    fk_kodeKab?: tb_kabupatenCreateNestedOneWithoutFk_kodeKab_dosenInput
    fk_kodeProv?: tb_provinsiCreateNestedOneWithoutFk_kodeProv_dosenInput
    fk_kodeWali_mhs?: tb_mhsCreateNestedManyWithoutFk_kodeWaliInput
  }

  export type tb_dosenUncheckedCreateWithoutFk_pemilik_akun_dosenInput = {
    nip: string
    nama: string
    alamat?: string | null
    email?: string | null
    kodeKab?: string | null
    kodeProv?: string | null
    noHP?: string | null
    foto?: string | null
    fk_kodeWali_mhs?: tb_mhsUncheckedCreateNestedManyWithoutFk_kodeWaliInput
  }

  export type tb_dosenCreateOrConnectWithoutFk_pemilik_akun_dosenInput = {
    where: tb_dosenWhereUniqueInput
    create: XOR<tb_dosenCreateWithoutFk_pemilik_akun_dosenInput, tb_dosenUncheckedCreateWithoutFk_pemilik_akun_dosenInput>
  }

  export type tb_role_akun_dosenCreateWithoutFk_usernameInput = {
    role: $Enums.Role
  }

  export type tb_role_akun_dosenUncheckedCreateWithoutFk_usernameInput = {
    role: $Enums.Role
  }

  export type tb_role_akun_dosenCreateOrConnectWithoutFk_usernameInput = {
    where: tb_role_akun_dosenWhereUniqueInput
    create: XOR<tb_role_akun_dosenCreateWithoutFk_usernameInput, tb_role_akun_dosenUncheckedCreateWithoutFk_usernameInput>
  }

  export type tb_role_akun_dosenCreateManyFk_usernameInputEnvelope = {
    data: tb_role_akun_dosenCreateManyFk_usernameInput | tb_role_akun_dosenCreateManyFk_usernameInput[]
    skipDuplicates?: boolean
  }

  export type tb_dosenUpsertWithoutFk_pemilik_akun_dosenInput = {
    update: XOR<tb_dosenUpdateWithoutFk_pemilik_akun_dosenInput, tb_dosenUncheckedUpdateWithoutFk_pemilik_akun_dosenInput>
    create: XOR<tb_dosenCreateWithoutFk_pemilik_akun_dosenInput, tb_dosenUncheckedCreateWithoutFk_pemilik_akun_dosenInput>
    where?: tb_dosenWhereInput
  }

  export type tb_dosenUpdateToOneWithWhereWithoutFk_pemilik_akun_dosenInput = {
    where?: tb_dosenWhereInput
    data: XOR<tb_dosenUpdateWithoutFk_pemilik_akun_dosenInput, tb_dosenUncheckedUpdateWithoutFk_pemilik_akun_dosenInput>
  }

  export type tb_dosenUpdateWithoutFk_pemilik_akun_dosenInput = {
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_kodeKab?: tb_kabupatenUpdateOneWithoutFk_kodeKab_dosenNestedInput
    fk_kodeProv?: tb_provinsiUpdateOneWithoutFk_kodeProv_dosenNestedInput
    fk_kodeWali_mhs?: tb_mhsUpdateManyWithoutFk_kodeWaliNestedInput
  }

  export type tb_dosenUncheckedUpdateWithoutFk_pemilik_akun_dosenInput = {
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeKab?: NullableStringFieldUpdateOperationsInput | string | null
    kodeProv?: NullableStringFieldUpdateOperationsInput | string | null
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_kodeWali_mhs?: tb_mhsUncheckedUpdateManyWithoutFk_kodeWaliNestedInput
  }

  export type tb_role_akun_dosenUpsertWithWhereUniqueWithoutFk_usernameInput = {
    where: tb_role_akun_dosenWhereUniqueInput
    update: XOR<tb_role_akun_dosenUpdateWithoutFk_usernameInput, tb_role_akun_dosenUncheckedUpdateWithoutFk_usernameInput>
    create: XOR<tb_role_akun_dosenCreateWithoutFk_usernameInput, tb_role_akun_dosenUncheckedCreateWithoutFk_usernameInput>
  }

  export type tb_role_akun_dosenUpdateWithWhereUniqueWithoutFk_usernameInput = {
    where: tb_role_akun_dosenWhereUniqueInput
    data: XOR<tb_role_akun_dosenUpdateWithoutFk_usernameInput, tb_role_akun_dosenUncheckedUpdateWithoutFk_usernameInput>
  }

  export type tb_role_akun_dosenUpdateManyWithWhereWithoutFk_usernameInput = {
    where: tb_role_akun_dosenScalarWhereInput
    data: XOR<tb_role_akun_dosenUpdateManyMutationInput, tb_role_akun_dosenUncheckedUpdateManyWithoutFk_usernameInput>
  }

  export type tb_role_akun_dosenScalarWhereInput = {
    AND?: tb_role_akun_dosenScalarWhereInput | tb_role_akun_dosenScalarWhereInput[]
    OR?: tb_role_akun_dosenScalarWhereInput[]
    NOT?: tb_role_akun_dosenScalarWhereInput | tb_role_akun_dosenScalarWhereInput[]
    username?: StringFilter<"tb_role_akun_dosen"> | string
    role?: EnumRoleFilter<"tb_role_akun_dosen"> | $Enums.Role
  }

  export type tb_akun_dosenCreateWithoutFk_username_roleInput = {
    username: string
    password: string
    status: $Enums.StatusAkun
    fk_pemilik: tb_dosenCreateNestedOneWithoutFk_pemilik_akun_dosenInput
  }

  export type tb_akun_dosenUncheckedCreateWithoutFk_username_roleInput = {
    username: string
    password: string
    status: $Enums.StatusAkun
    pemilik: string
  }

  export type tb_akun_dosenCreateOrConnectWithoutFk_username_roleInput = {
    where: tb_akun_dosenWhereUniqueInput
    create: XOR<tb_akun_dosenCreateWithoutFk_username_roleInput, tb_akun_dosenUncheckedCreateWithoutFk_username_roleInput>
  }

  export type tb_akun_dosenUpsertWithoutFk_username_roleInput = {
    update: XOR<tb_akun_dosenUpdateWithoutFk_username_roleInput, tb_akun_dosenUncheckedUpdateWithoutFk_username_roleInput>
    create: XOR<tb_akun_dosenCreateWithoutFk_username_roleInput, tb_akun_dosenUncheckedCreateWithoutFk_username_roleInput>
    where?: tb_akun_dosenWhereInput
  }

  export type tb_akun_dosenUpdateToOneWithWhereWithoutFk_username_roleInput = {
    where?: tb_akun_dosenWhereInput
    data: XOR<tb_akun_dosenUpdateWithoutFk_username_roleInput, tb_akun_dosenUncheckedUpdateWithoutFk_username_roleInput>
  }

  export type tb_akun_dosenUpdateWithoutFk_username_roleInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAkunFieldUpdateOperationsInput | $Enums.StatusAkun
    fk_pemilik?: tb_dosenUpdateOneRequiredWithoutFk_pemilik_akun_dosenNestedInput
  }

  export type tb_akun_dosenUncheckedUpdateWithoutFk_username_roleInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAkunFieldUpdateOperationsInput | $Enums.StatusAkun
    pemilik?: StringFieldUpdateOperationsInput | string
  }

  export type tb_irsCreateManyFk_nimInput = {
    semester: string
    status: $Enums.StatusAktif
    jumlahSks?: string | null
    fileIrs?: string | null
    statusValidasi?: boolean
  }

  export type tb_khsCreateManyFk_nimInput = {
    semester: string
    status: $Enums.StatusAktif
    jumlahSksSemester?: string | null
    ips?: string | null
    jumlahSksKumulatif?: string | null
    ipk?: string | null
    fileKhs?: string | null
    statusValidasi?: boolean
  }

  export type tb_pklCreateManyFk_nimInput = {
    semester: string
    nilai: string
    filePkl: string
    statusValidasi?: boolean
  }

  export type tb_skripsiCreateManyFk_nimInput = {
    semester: string
    nilai: string
    tanggalLulusSidang: Date | string
    lamaStudi: number
    fileSkripsi: string
    statusValidasi?: boolean
  }

  export type tb_irsUpdateWithoutFk_nimInput = {
    semester?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    jumlahSks?: NullableStringFieldUpdateOperationsInput | string | null
    fileIrs?: NullableStringFieldUpdateOperationsInput | string | null
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_irsUncheckedUpdateWithoutFk_nimInput = {
    semester?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    jumlahSks?: NullableStringFieldUpdateOperationsInput | string | null
    fileIrs?: NullableStringFieldUpdateOperationsInput | string | null
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_irsUncheckedUpdateManyWithoutFk_nimInput = {
    semester?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    jumlahSks?: NullableStringFieldUpdateOperationsInput | string | null
    fileIrs?: NullableStringFieldUpdateOperationsInput | string | null
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_khsUpdateWithoutFk_nimInput = {
    semester?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    jumlahSksSemester?: NullableStringFieldUpdateOperationsInput | string | null
    ips?: NullableStringFieldUpdateOperationsInput | string | null
    jumlahSksKumulatif?: NullableStringFieldUpdateOperationsInput | string | null
    ipk?: NullableStringFieldUpdateOperationsInput | string | null
    fileKhs?: NullableStringFieldUpdateOperationsInput | string | null
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_khsUncheckedUpdateWithoutFk_nimInput = {
    semester?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    jumlahSksSemester?: NullableStringFieldUpdateOperationsInput | string | null
    ips?: NullableStringFieldUpdateOperationsInput | string | null
    jumlahSksKumulatif?: NullableStringFieldUpdateOperationsInput | string | null
    ipk?: NullableStringFieldUpdateOperationsInput | string | null
    fileKhs?: NullableStringFieldUpdateOperationsInput | string | null
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_khsUncheckedUpdateManyWithoutFk_nimInput = {
    semester?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    jumlahSksSemester?: NullableStringFieldUpdateOperationsInput | string | null
    ips?: NullableStringFieldUpdateOperationsInput | string | null
    jumlahSksKumulatif?: NullableStringFieldUpdateOperationsInput | string | null
    ipk?: NullableStringFieldUpdateOperationsInput | string | null
    fileKhs?: NullableStringFieldUpdateOperationsInput | string | null
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_pklUpdateWithoutFk_nimInput = {
    semester?: StringFieldUpdateOperationsInput | string
    nilai?: StringFieldUpdateOperationsInput | string
    filePkl?: StringFieldUpdateOperationsInput | string
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_pklUncheckedUpdateWithoutFk_nimInput = {
    semester?: StringFieldUpdateOperationsInput | string
    nilai?: StringFieldUpdateOperationsInput | string
    filePkl?: StringFieldUpdateOperationsInput | string
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_pklUncheckedUpdateManyWithoutFk_nimInput = {
    semester?: StringFieldUpdateOperationsInput | string
    nilai?: StringFieldUpdateOperationsInput | string
    filePkl?: StringFieldUpdateOperationsInput | string
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_skripsiUpdateWithoutFk_nimInput = {
    semester?: StringFieldUpdateOperationsInput | string
    nilai?: StringFieldUpdateOperationsInput | string
    tanggalLulusSidang?: DateTimeFieldUpdateOperationsInput | Date | string
    lamaStudi?: IntFieldUpdateOperationsInput | number
    fileSkripsi?: StringFieldUpdateOperationsInput | string
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_skripsiUncheckedUpdateWithoutFk_nimInput = {
    semester?: StringFieldUpdateOperationsInput | string
    nilai?: StringFieldUpdateOperationsInput | string
    tanggalLulusSidang?: DateTimeFieldUpdateOperationsInput | Date | string
    lamaStudi?: IntFieldUpdateOperationsInput | number
    fileSkripsi?: StringFieldUpdateOperationsInput | string
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_skripsiUncheckedUpdateManyWithoutFk_nimInput = {
    semester?: StringFieldUpdateOperationsInput | string
    nilai?: StringFieldUpdateOperationsInput | string
    tanggalLulusSidang?: DateTimeFieldUpdateOperationsInput | Date | string
    lamaStudi?: IntFieldUpdateOperationsInput | number
    fileSkripsi?: StringFieldUpdateOperationsInput | string
    statusValidasi?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tb_mhsCreateManyFk_kodeWaliInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    kodeKab?: string | null
    kodeProv?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    foto?: string | null
  }

  export type tb_mhsUpdateWithoutFk_kodeWaliInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_kodeKab?: tb_kabupatenUpdateOneWithoutFk_kodeKab_mhsNestedInput
    fk_kodeProv?: tb_provinsiUpdateOneWithoutFk_kodeProv_mhsNestedInput
    fk_nim_irs?: tb_irsUpdateManyWithoutFk_nimNestedInput
    fk_nim_khs?: tb_khsUpdateManyWithoutFk_nimNestedInput
    fk_nim_pkl?: tb_pklUpdateManyWithoutFk_nimNestedInput
    fk_nim_skripsi?: tb_skripsiUpdateManyWithoutFk_nimNestedInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_mhsUncheckedUpdateWithoutFk_kodeWaliInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeKab?: NullableStringFieldUpdateOperationsInput | string | null
    kodeProv?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_nim_irs?: tb_irsUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_khs?: tb_khsUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_pkl?: tb_pklUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_skripsi?: tb_skripsiUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUncheckedUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_mhsUncheckedUpdateManyWithoutFk_kodeWaliInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeKab?: NullableStringFieldUpdateOperationsInput | string | null
    kodeProv?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_mhsCreateManyFk_kodeProvInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    kodeKab?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    kodeWali: string
    foto?: string | null
  }

  export type tb_dosenCreateManyFk_kodeProvInput = {
    nip: string
    nama: string
    alamat?: string | null
    email?: string | null
    kodeKab?: string | null
    noHP?: string | null
    foto?: string | null
  }

  export type tb_kabupatenCreateManyFk_kodeProvInput = {
    kodeKab: string
    namaKab: string
  }

  export type tb_mhsUpdateWithoutFk_kodeProvInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_kodeKab?: tb_kabupatenUpdateOneWithoutFk_kodeKab_mhsNestedInput
    fk_kodeWali?: tb_dosenUpdateOneRequiredWithoutFk_kodeWali_mhsNestedInput
    fk_nim_irs?: tb_irsUpdateManyWithoutFk_nimNestedInput
    fk_nim_khs?: tb_khsUpdateManyWithoutFk_nimNestedInput
    fk_nim_pkl?: tb_pklUpdateManyWithoutFk_nimNestedInput
    fk_nim_skripsi?: tb_skripsiUpdateManyWithoutFk_nimNestedInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_mhsUncheckedUpdateWithoutFk_kodeProvInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeKab?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    kodeWali?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_nim_irs?: tb_irsUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_khs?: tb_khsUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_pkl?: tb_pklUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_skripsi?: tb_skripsiUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUncheckedUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_mhsUncheckedUpdateManyWithoutFk_kodeProvInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeKab?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    kodeWali?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_dosenUpdateWithoutFk_kodeProvInput = {
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_kodeKab?: tb_kabupatenUpdateOneWithoutFk_kodeKab_dosenNestedInput
    fk_kodeWali_mhs?: tb_mhsUpdateManyWithoutFk_kodeWaliNestedInput
    fk_pemilik_akun_dosen?: tb_akun_dosenUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_dosenUncheckedUpdateWithoutFk_kodeProvInput = {
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeKab?: NullableStringFieldUpdateOperationsInput | string | null
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_kodeWali_mhs?: tb_mhsUncheckedUpdateManyWithoutFk_kodeWaliNestedInput
    fk_pemilik_akun_dosen?: tb_akun_dosenUncheckedUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_dosenUncheckedUpdateManyWithoutFk_kodeProvInput = {
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeKab?: NullableStringFieldUpdateOperationsInput | string | null
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_kabupatenUpdateWithoutFk_kodeProvInput = {
    kodeKab?: StringFieldUpdateOperationsInput | string
    namaKab?: StringFieldUpdateOperationsInput | string
    fk_kodeKab_mhs?: tb_mhsUpdateManyWithoutFk_kodeKabNestedInput
    fk_kodeKab_dosen?: tb_dosenUpdateManyWithoutFk_kodeKabNestedInput
  }

  export type tb_kabupatenUncheckedUpdateWithoutFk_kodeProvInput = {
    kodeKab?: StringFieldUpdateOperationsInput | string
    namaKab?: StringFieldUpdateOperationsInput | string
    fk_kodeKab_mhs?: tb_mhsUncheckedUpdateManyWithoutFk_kodeKabNestedInput
    fk_kodeKab_dosen?: tb_dosenUncheckedUpdateManyWithoutFk_kodeKabNestedInput
  }

  export type tb_kabupatenUncheckedUpdateManyWithoutFk_kodeProvInput = {
    kodeKab?: StringFieldUpdateOperationsInput | string
    namaKab?: StringFieldUpdateOperationsInput | string
  }

  export type tb_mhsCreateManyFk_kodeKabInput = {
    nim: string
    nama: string
    statusAktif: $Enums.StatusMhs
    alamat?: string | null
    email?: string | null
    kodeProv?: string | null
    jalurMasuk: $Enums.JalurMasuk
    angkatan: number
    noHP?: string | null
    kodeWali: string
    foto?: string | null
  }

  export type tb_dosenCreateManyFk_kodeKabInput = {
    nip: string
    nama: string
    alamat?: string | null
    email?: string | null
    kodeProv?: string | null
    noHP?: string | null
    foto?: string | null
  }

  export type tb_mhsUpdateWithoutFk_kodeKabInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_kodeProv?: tb_provinsiUpdateOneWithoutFk_kodeProv_mhsNestedInput
    fk_kodeWali?: tb_dosenUpdateOneRequiredWithoutFk_kodeWali_mhsNestedInput
    fk_nim_irs?: tb_irsUpdateManyWithoutFk_nimNestedInput
    fk_nim_khs?: tb_khsUpdateManyWithoutFk_nimNestedInput
    fk_nim_pkl?: tb_pklUpdateManyWithoutFk_nimNestedInput
    fk_nim_skripsi?: tb_skripsiUpdateManyWithoutFk_nimNestedInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_mhsUncheckedUpdateWithoutFk_kodeKabInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeProv?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    kodeWali?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_nim_irs?: tb_irsUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_khs?: tb_khsUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_pkl?: tb_pklUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_nim_skripsi?: tb_skripsiUncheckedUpdateManyWithoutFk_nimNestedInput
    fk_pemilik_akun_mhs?: tb_akun_mhsUncheckedUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_mhsUncheckedUpdateManyWithoutFk_kodeKabInput = {
    nim?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    statusAktif?: EnumStatusMhsFieldUpdateOperationsInput | $Enums.StatusMhs
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeProv?: NullableStringFieldUpdateOperationsInput | string | null
    jalurMasuk?: EnumJalurMasukFieldUpdateOperationsInput | $Enums.JalurMasuk
    angkatan?: IntFieldUpdateOperationsInput | number
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    kodeWali?: StringFieldUpdateOperationsInput | string
    foto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_dosenUpdateWithoutFk_kodeKabInput = {
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_kodeProv?: tb_provinsiUpdateOneWithoutFk_kodeProv_dosenNestedInput
    fk_kodeWali_mhs?: tb_mhsUpdateManyWithoutFk_kodeWaliNestedInput
    fk_pemilik_akun_dosen?: tb_akun_dosenUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_dosenUncheckedUpdateWithoutFk_kodeKabInput = {
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeProv?: NullableStringFieldUpdateOperationsInput | string | null
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    fk_kodeWali_mhs?: tb_mhsUncheckedUpdateManyWithoutFk_kodeWaliNestedInput
    fk_pemilik_akun_dosen?: tb_akun_dosenUncheckedUpdateOneWithoutFk_pemilikNestedInput
  }

  export type tb_dosenUncheckedUpdateManyWithoutFk_kodeKabInput = {
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kodeProv?: NullableStringFieldUpdateOperationsInput | string | null
    noHP?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_role_akun_dosenCreateManyFk_usernameInput = {
    role: $Enums.Role
  }

  export type tb_role_akun_dosenUpdateWithoutFk_usernameInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type tb_role_akun_dosenUncheckedUpdateWithoutFk_usernameInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type tb_role_akun_dosenUncheckedUpdateManyWithoutFk_usernameInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use Tb_mhsCountOutputTypeDefaultArgs instead
     */
    export type Tb_mhsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tb_mhsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tb_dosenCountOutputTypeDefaultArgs instead
     */
    export type Tb_dosenCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tb_dosenCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tb_provinsiCountOutputTypeDefaultArgs instead
     */
    export type Tb_provinsiCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tb_provinsiCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tb_kabupatenCountOutputTypeDefaultArgs instead
     */
    export type Tb_kabupatenCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tb_kabupatenCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tb_akun_dosenCountOutputTypeDefaultArgs instead
     */
    export type Tb_akun_dosenCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tb_akun_dosenCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tb_mhsDefaultArgs instead
     */
    export type tb_mhsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tb_mhsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tb_dosenDefaultArgs instead
     */
    export type tb_dosenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tb_dosenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tb_irsDefaultArgs instead
     */
    export type tb_irsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tb_irsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tb_khsDefaultArgs instead
     */
    export type tb_khsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tb_khsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tb_pklDefaultArgs instead
     */
    export type tb_pklArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tb_pklDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tb_skripsiDefaultArgs instead
     */
    export type tb_skripsiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tb_skripsiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tb_provinsiDefaultArgs instead
     */
    export type tb_provinsiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tb_provinsiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tb_kabupatenDefaultArgs instead
     */
    export type tb_kabupatenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tb_kabupatenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tb_akun_mhsDefaultArgs instead
     */
    export type tb_akun_mhsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tb_akun_mhsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tb_akun_dosenDefaultArgs instead
     */
    export type tb_akun_dosenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tb_akun_dosenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tb_role_akun_dosenDefaultArgs instead
     */
    export type tb_role_akun_dosenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tb_role_akun_dosenDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}